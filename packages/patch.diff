diff --git a/Cargo.toml b/Cargo.toml
index 81a5abf..ffcf351 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,5 +1,5 @@
-[workspace]
-members = ["./", "celery-codegen"]
+#[workspace]
+#members = ["./", "celery-codegen"]
 
 [package]
 name = "celery"
diff --git a/src/app/mod.rs b/src/app/mod.rs
index 83c873c..9a40950 100644
--- a/src/app/mod.rs
+++ b/src/app/mod.rs
@@ -20,7 +20,7 @@ mod trace;
 use crate::broker::{
     broker_builder_from_url, build_and_connect, configure_task_routes, Broker, BrokerBuilder,
     Delivery,
-};
+ ConsumerHealth};
 use crate::error::{BrokerError, CeleryError, TraceError};
 use crate::protocol::{Message, MessageContentType};
 use crate::routing::Rule;
@@ -468,6 +468,11 @@ impl Celery {
     }
 
     /// Close channels and connections.
+    /// Check the health of consumers for the specified queues.
+    pub async fn check_consumer_health(&self, queues: &Vec<String>) -> Result<Vec<ConsumerHealth>, CeleryError> {
+        Ok(self.broker.check_consumer_health(queues).await?)
+    }
+
     pub async fn close(&self) -> Result<(), CeleryError> {
         Ok(self.broker.close().await?)
     }
diff --git a/src/broker/amqp.rs b/src/broker/amqp.rs
index b38c9a4..ed6ab42 100644
--- a/src/broker/amqp.rs
+++ b/src/broker/amqp.rs
@@ -1,4 +1,6 @@
-//! AMQP broker.
+use super::{Broker, BrokerBuilder, DeliveryError, DeliveryStream, ConsumerHealth};
+use std::any::Any;
+/// AMQP broker.
 
 use async_trait::async_trait;
 use chrono::{DateTime, SecondsFormat, Utc};
@@ -17,13 +19,11 @@ use std::str::FromStr;
 use std::task::Poll;
 use tokio::sync::{Mutex, RwLock};
 
-use super::{Broker, BrokerBuilder, DeliveryError, DeliveryStream};
 use crate::error::{BrokerError, ProtocolError};
 use crate::protocol::{Message, MessageHeaders, MessageProperties, TryDeserializeMessage};
 use tokio_executor_trait::Tokio as TokioExecutor;
 
-#[cfg(test)]
-use std::any::Any;
+
 
 struct Consumer {
     wrapped: lapin::Consumer,
@@ -388,6 +388,66 @@ impl Broker for AMQPBroker {
         Ok(())
     }
 
+    
+    /// Check the health of consumers for the given queues.
+    async fn check_consumer_health(&self, queues: &Vec<String>) -> Result<Vec<ConsumerHealth>, BrokerError> {
+        let mut health_info = Vec::new();
+        
+        let consume_channel = self.consume_channel.read().await;
+        
+        for queue_name in queues.clone() {
+            // Get queue info using queue_declare with passive=true
+            let queue_result = consume_channel
+                .queue_declare(
+                    queue_name.as_str(),
+                    QueueDeclareOptions {
+                        passive: true,  // Dont create, just get info
+                        durable: true,
+                        exclusive: false,
+                        auto_delete: false,
+                        nowait: false,
+                    },
+                    FieldTable::default(),
+                )
+                .await;
+
+            match queue_result {
+                Ok(queue) => {
+                    // Get queue statistics
+                    let message_count = queue.message_count();
+                    let consumer_count = queue.consumer_count();
+                    
+                    // A queue is considered to have active consumers if:
+                    // 1. It has at least one consumer
+                    // 2. The connection and channel are active
+                    let is_consuming = consumer_count > 0 
+                        && self.conn.lock().await.status().connected()
+                        && consume_channel.status().connected();
+
+                    health_info.push(ConsumerHealth {
+                        queue_name: queue_name.to_string(),
+                        consumer_count,
+                        message_count,
+                        is_consuming,
+                    });
+                }
+                Err(e) => {
+                    // If we cant get queue info, assume its not healthy
+                    health_info.push(ConsumerHealth {
+                        queue_name: queue_name.to_string(),
+                        consumer_count: 0,
+                        message_count: 0,
+                        is_consuming: false,
+                    });
+                    // Log the error for debugging
+                    log::warn!("Failed to get health info for queue {}: {}", queue_name, e);
+                }
+            }
+        }
+
+        Ok(health_info)
+    }
+
     #[cfg(test)]
     fn into_any(self: Box<Self>) -> Box<dyn Any> {
         self
@@ -613,7 +673,7 @@ fn amqp_value_to_u32(v: &AMQPValue) -> Option<u32> {
     }
 }
 
-#[cfg(test)]
+
 mod tests {
     use super::*;
     use lapin::types::ShortString;
diff --git a/src/broker/mock.rs b/src/broker/mock.rs
index 37fa7fc..ec6fbc7 100644
--- a/src/broker/mock.rs
+++ b/src/broker/mock.rs
@@ -126,6 +126,20 @@ impl Broker for MockBroker {
     }
 
     #[cfg(test)]
+    /// Mock implementation of consumer health check.
+    async fn check_consumer_health(&self, queues: &[&str]) -> Result<Vec<super::ConsumerHealth>, BrokerError> {
+        let mut health_info = Vec::new();
+        for &queue_name in queues {
+            health_info.push(super::ConsumerHealth {
+                queue_name: queue_name.to_string(),
+                consumer_count: 1,
+                message_count: 0,
+                is_consuming: true,
+            });
+        }
+        Ok(health_info)
+    }
+
     fn into_any(self: Box<Self>) -> Box<dyn Any> {
         self
     }
diff --git a/src/broker/mod.rs b/src/broker/mod.rs
index 7077e59..9b5db5a 100644
--- a/src/broker/mod.rs
+++ b/src/broker/mod.rs
@@ -23,6 +23,15 @@ pub mod mock;
 #[cfg(test)]
 use std::any::Any;
 
+/// Consumer health information
+#[derive(Debug, Clone)]
+pub struct ConsumerHealth {
+    pub queue_name: String,
+    pub consumer_count: u32,
+    pub message_count: u32,
+    pub is_consuming: bool,
+}
+
 /// The type representing a successful delivery.
 #[async_trait]
 pub trait Delivery: TryDeserializeMessage + Send + Sync + std::fmt::Debug {
@@ -95,6 +104,10 @@ pub trait Broker: Send + Sync {
     /// Try reconnecting in the event of some sort of connection error.
     async fn reconnect(&self, connection_timeout: u32) -> Result<(), BrokerError>;
 
+    /// Check the health of consumers for the given queues.
+    /// Returns a vector of consumer health information.
+    async fn check_consumer_health(&self, queues: &Vec<String>) -> Result<Vec<ConsumerHealth>, BrokerError>;
+
     #[cfg(test)]
     fn into_any(self: Box<Self>) -> Box<dyn Any>;
 }
diff --git a/src/broker/redis.rs b/src/broker/redis.rs
index fcd7a04..9aec33b 100644
--- a/src/broker/redis.rs
+++ b/src/broker/redis.rs
@@ -1,6 +1,7 @@
 //! Redis broker.
 #![allow(dead_code)]
-use super::{Broker, BrokerBuilder, DeliveryError, DeliveryStream};
+use super::{Broker, BrokerBuilder, DeliveryError, DeliveryStream, ConsumerHealth};
+use std::any::Any;
 use crate::error::{BrokerError, ProtocolError};
 use crate::protocol::Delivery;
 use crate::protocol::DeliveryInfo;
@@ -24,8 +25,7 @@ use tokio::sync::mpsc::{channel, Receiver, Sender};
 use tokio::sync::Mutex;
 use uuid::Uuid;
 
-#[cfg(test)]
-use std::any::Any;
+
 
 struct Config {
     broker_url: String,
@@ -442,6 +442,26 @@ impl Broker for RedisBroker {
         }
     }
 
+    
+    /// Check the health of consumers for the given queues.
+    /// For Redis broker, this is a simple implementation that checks connection.
+    async fn check_consumer_health(&self, queues: &Vec<String>) -> Result<Vec<ConsumerHealth>, BrokerError> {
+        let mut health_info = Vec::new();
+        
+        // For Redis, we do a simple connection check for each queue
+        for queue_name in queues.clone() {
+            let is_connected = true; // Simplified: assume connected if manager exists
+            health_info.push(ConsumerHealth {
+                queue_name: queue_name.clone(),
+                consumer_count: if is_connected { 1 } else { 0 },
+                message_count: 0, // Redis implementation doesnt easily provide this
+                is_consuming: is_connected,
+            });
+        }
+        
+        Ok(health_info)
+    }
+
     #[cfg(test)]
     fn into_any(self: Box<Self>) -> Box<dyn Any> {
         self
diff --git a/src/lib.rs b/src/lib.rs
index a0cfe10..192383a 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -207,3 +207,4 @@ extern crate serde;
 
 #[cfg(feature = "codegen")]
 extern crate tokio;
+// Trigger rebuild
