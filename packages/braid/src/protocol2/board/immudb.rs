// SPDX-FileCopyrightText: 2023 Eduardo Robles <edu@sequentech.io>
//
// SPDX-License-Identifier: AGPL-3.0-only

use anyhow::Result;
use immu_board::{Board, BoardClient, BoardMessage};
use rusqlite::params;
use rusqlite::Connection;
use tracing::info;
use std::path::PathBuf;
use strand::serialization::StrandDeserialize;
// use strand::serialization::StrandSerialize;
use braid_messages::message::Message;

pub struct ImmudbBoard {
    pub(crate) board_client: BoardClient,
    pub(crate) board_dbname: String,
    pub(crate) store_root: Option<PathBuf>,
}

impl ImmudbBoard {
    pub async fn new(
        server_url: &str,
        username: &str,
        password: &str,
        board_dbname: String,
        store_root: Option<PathBuf>,
    ) -> Result<ImmudbBoard> {
        let board_client = BoardClient::new(server_url, username, password).await?;
        Ok(ImmudbBoard {
            board_client: board_client,
            board_dbname,
            store_root,
        })
    }

    pub async fn get_messages(&mut self, last_id: i64) -> Result<Vec<Message>> {
        
        let messages = if self.store_root.is_some() {
            self.store_and_get_messages().await?
        }
        else {
            let messages = self.get_remote_messages(last_id).await?;

            messages.iter().map(|m| {
                Message::strand_deserialize(&m.message).unwrap()
            })
            .collect::<Vec<Message>>()
        };
        
        Ok(messages)

    }

    pub async fn get_remote_messages(&mut self, last_id: i64) -> Result<Vec<BoardMessage>> {
        let messages = self
            .board_client
            .get_messages(&self.board_dbname, last_id)
            .await?;

        Ok(messages)
    }

    pub async fn insert_messages(&mut self, messages: Vec<Message>) -> Result<()> {
        if messages.len() > 0 {
            let bm: Result<Vec<BoardMessage>> =
                messages.into_iter().map(|m| m.try_into()).collect();
            self.board_client
                .insert_messages(&self.board_dbname, &bm?)
                .await
        } else {
            Ok(())
        }
    }

    fn get_store(&self) -> Result<Connection> {
        let db_path = self.store_root.as_ref().expect("only called when store_root is some").join(&self.board_dbname);
        let connection = Connection::open(&db_path)?;
        // The autogenerated id column is used to establish an order that cannot be manipulated by the external board. Once a retrieved message is
        // stored and assigned an id it cannot be "overwritten" by the external board. (overwritten in this case refers to altering the sequence
        // such that another message of the same kind would precede it)
        // The external_id column is used to retrieve _new_ messages as defined by the external board (to optimize bandwidth).
        connection.execute("CREATE TABLE if not exists MESSAGES(id INTEGER PRIMARY KEY AUTOINCREMENT, external_id INT, message BLOB NOT NULL UNIQUE)", [])?;

        Ok(connection)
    }

    async fn store_and_get_messages(&mut self) -> Result<Vec<Message>> {
        let connection = self.get_store()?;

        let last_id: Result<i64> = connection
            .query_row("SELECT max(external_id) FROM messages;", [], |row| row.get(0))
            .or(Ok(0i64));
        let last_id = last_id?;

        info!("last_id {}", last_id);

        let messages = self.get_remote_messages(last_id).await?;

        for message in messages {
            connection.execute(
                "INSERT INTO MESSAGES(external_id, message) VALUES(?1, ?2)",
                params![message.id, message.message],
            )?;
        }

        let mut stmt =
            connection.prepare("SELECT id,message FROM MESSAGES where id > ?1 order by id asc")?;
        let rows = stmt.query_map([last_id], |row| {
            Ok(MessageRow {
                _id: row.get(0)?,
                message: row.get(1)?,
            })
        })?;

        let messages: Result<Vec<Message>> = rows
            .map(|mr| Ok(Message::strand_deserialize(&mr?.message)?))
            .collect();

        
        messages

    }
    
}

pub struct ImmudbBoardIndex {
    board_client: BoardClient,
    index_dbname: String,
}

impl ImmudbBoardIndex {
    pub async fn new(
        server_url: &str,
        username: &str,
        password: &str,
        index_dbname: String,
    ) -> Result<ImmudbBoardIndex> {
        let board_client = BoardClient::new(server_url, username, password).await?;
        Ok(ImmudbBoardIndex {
            board_client: board_client,
            index_dbname,
        })
    }

    pub async fn get_board_names(&mut self) -> Result<Vec<String>> {
        self.board_client
            .get_boards(&self.index_dbname)
            .await?
            .iter()
            .map(|board: &Board| Ok(board.database_name.clone()))
            .collect()
    }
}

struct MessageRow {
    _id: u64,
    message: Vec<u8>,
}
