// SPDX-FileCopyrightText: 2023 Eduardo Robles <edu@sequentech.io>
//
// SPDX-License-Identifier: AGPL-3.0-only

use anyhow::Result;
use board_messages::braid::message::Message;
use immu_board::{Board as BoardData, BoardClient, BoardMessage};
use rusqlite::params;
use rusqlite::Connection;
use std::path::PathBuf;
use strand::serialization::StrandDeserialize;
use tracing::{warn,info};

/// A bulletin board implemented on immudb
pub struct ImmudbBoard {
    pub(crate) board_client: BoardClient,
    pub(crate) board_dbname: String,
    pub(crate) store_root: Option<PathBuf>,
}

impl ImmudbBoard {
    pub async fn new(
        server_url: &str,
        username: &str,
        password: &str,
        board_dbname: String,
        store_root: Option<PathBuf>,
    ) -> Result<ImmudbBoard> {
        let board_client = BoardClient::new(server_url, username, password).await?;
        Ok(ImmudbBoard {
            board_client: board_client,
            board_dbname: board_dbname.to_string(),
            store_root,
        })
    }

    // Returns all messages from immudb starting from last_id + 1,  using consecutive requests.
    // If the value at last_id + 1 does not exist, an empty vector will be returned.
    // If there are gaps in the sequence, the returned vector will contain messages until
    // the last value before the gap.
    // Note that there should be no gaps according to
    // https://docs.immudb.io/1.1.0/reference/sql.html?
    // The type of an AUTO_INCREMENT column must be INTEGER. Internally immudb will assign
    // sequentially increasing values for new rows ensuring this value is unique within a single table
    async fn get_remote_messages_consecutively(
        &mut self,
        last_id: i64,
    ) -> Result<Vec<BoardMessage>> {
        let mut ret = vec![];
        let mut next_id = last_id + 1;
        loop {
            let message = self
                .board_client
                .get_one_message(&self.board_dbname, next_id)
                .await?;
            if let Some(message) = message {
                ret.push(message);
                next_id = next_id + 1;
            } else {
                break;
            }
        }

        Ok(ret)
    }

    // Returns all messages whose id > last_id.
    async fn get_remote_messages(&mut self, last_id: i64) -> Result<Vec<BoardMessage>> {
        let messages = self
            .board_client
            .get_messages(&self.board_dbname, last_id)
            .await?;

        Ok(messages)
    }

    fn get_store(&self) -> Result<Connection> {
        let db_path = self
            .store_root
            .as_ref()
            .expect("only called when store_root is some")
            .join(&self.board_dbname);
        let connection = Connection::open(&db_path)?;
        // The autogenerated id column is used to establish an order that cannot be manipulated by the external board. Once a retrieved message is
        // stored and assigned a local id, it is not possible for later messages to have an earlier id.
        // The external_id column is used to retrieve _new_ messages as defined by the external board (to optimize bandwidth).
        connection.execute("CREATE TABLE if not exists MESSAGES(id INTEGER PRIMARY KEY AUTOINCREMENT, external_id INT, message BLOB NOT NULL UNIQUE)", [])?;

        Ok(connection)
    }

    async fn store_and_get_messages(&mut self, last_id: Option<i64>) -> Result<Vec<(Message, i64)>> {
        let connection = self.get_store()?;

        let external_last_id =
            connection.query_row("SELECT max(external_id) FROM messages;", [], |row| {
                row.get(0)
            });

        if external_last_id.is_err() {
            warn!(
                "sql error retrieving external_last_id {:?}",
                external_last_id
            );
        }

        // All messages in one request implementation
        // When querying for all messages from immudb we use -1 as default lower limit (this requests uses the > comparator in sql)
        // let messages = self.get_remote_messages(external_last_id.unwrap_or(-1)).await?;

        // One by one implementation
        // When retrieving messages one at a time from immudb we use 0 as default value since
        // immudb ids start at 1 (this requests uses the = comparator in sql)
        let messages = self
            .get_remote_messages_consecutively(external_last_id.unwrap_or(0))
            .await?;

        info!("Retrieved {} messages remotely, storing locally", messages.len());

        // FIXME verify message signatures before inserting in local store
        let mut statement = connection.prepare("INSERT INTO MESSAGES(external_id, message) VALUES(?1, ?2)")?;
        connection.execute("BEGIN TRANSACTION", [])?;
        for message in messages {
            statement.execute(params![message.id, message.message])?;
        }
        connection.execute("END TRANSACTION", [])?;

        let mut stmt =
            connection.prepare("SELECT id,message FROM MESSAGES where id > ?1 order by id asc")?;
        // When querying for all messages in the store we use -1 as a lower limit
        let rows = stmt.query_map([last_id.unwrap_or(-1)], |row| {
            Ok(MessageRow {
                id: row.get(0)?,
                message: row.get(1)?,
            })
        })?;

        info!("Deserializing rows into Message structs..");
        let messages: Result<Vec<(Message, i64)>> = rows
            .map(|mr| {
                let row = mr?;
                let id = row.id;
                let message = Message::strand_deserialize(&row.message)?;
                Ok((message, id))
            })
            .collect();

        messages
    }
}

impl super::Board for ImmudbBoard {
    type Params = BoardParams;

    // Returns all messages whose id > last_id. If last_id is None, all messages will be returned.
    // If a store is used only the messages not previously received will be requested.
    async fn get_messages(&mut self, last_id: Option<i64>) -> Result<Vec<(Message, i64)>> {
        let messages = if self.store_root.is_some() {
            // When using a store, only the messages not previously received will be requested
            self.store_and_get_messages(last_id).await?
        } else {
            // When not using a store, we get all messages, one at a time
            // If last_id is None, use 0 as last_id: immudb sequences start with 1
            let messages = self
                .get_remote_messages_consecutively(last_id.unwrap_or(0))
                .await?;
            // If last_id is None, use 0 as last_id: immudb sequences start with 1
            // let messages = self.get_remote_messages(last_id.unwrap_or(0)).await?;

            messages
                .iter()
                .map(|m| {
                    let message = Message::strand_deserialize(&m.message)?;
                    let id = m.id;
                    Ok((message, id))
                })
                .collect::<Result<Vec<(Message, i64)>>>()?
        };

        Ok(messages)
    }

    async fn insert_messages(&mut self, messages: Vec<Message>) -> Result<()> {
        if messages.len() > 0 {
            let bm: Result<Vec<BoardMessage>> =
                messages.into_iter().map(|m| m.try_into()).collect();
            self.board_client
                .insert_messages(&self.board_dbname, &bm?)
                .await
        } else {
            Ok(())
        }
    }
}

struct MessageRow {
    id: i64,
    message: Vec<u8>,
}

pub struct BoardParams {
    server_url: String,
    user: String,
    password: String,
    board_name: String,
    store_root: Option<PathBuf>,
}
impl BoardParams {
    pub fn new(
        server_url: &str,
        user: &str,
        password: &str,
        board_dbname: &str,
        store_root: Option<PathBuf>,
    ) -> BoardParams {
        BoardParams {
            server_url: server_url.to_string(),
            user: user.to_string(),
            password: password.to_string(),
            board_name: board_dbname.to_string(),
            store_root: store_root,
        }
    }

    pub async fn get_board(&self) -> Result<ImmudbBoard> {
        ImmudbBoard::new(
            &self.server_url,
            &self.user,
            &self.password,
            self.board_name.clone(),
            self.store_root.clone(),
        )
        .await
    }
}

/// A bulletin board index implemented on immudb
pub struct ImmudbBoardIndex {
    board_client: BoardClient,
    index_dbname: String,
}

impl ImmudbBoardIndex {
    pub async fn new(
        server_url: &str,
        username: &str,
        password: &str,
        index_dbname: String,
    ) -> Result<ImmudbBoardIndex> {
        let board_client = BoardClient::new(server_url, username, password).await?;
        Ok(ImmudbBoardIndex {
            board_client: board_client,
            index_dbname,
        })
    }

    pub async fn get_board_names(&mut self) -> Result<Vec<String>> {
        self.board_client
            .get_boards(&self.index_dbname)
            .await?
            .iter()
            .map(|board: &BoardData| Ok(board.database_name.clone()))
            .collect()
    }
}