// SPDX-FileCopyrightText: 2023 Eduardo Robles <edu@sequentech.io>
//
// SPDX-License-Identifier: AGPL-3.0-only

use anyhow::{anyhow, Result};
use board_messages::braid::message::Message;
use rusqlite::params;
use rusqlite::Connection;
use std::path::PathBuf;
use std::time::{Duration, SystemTime};
use tokio_postgres::{NoTls, Row};
use tracing::instrument;
use tracing::{info, warn};

use strand::serialization::StrandDeserialize;
use strand::serialization::StrandSerialize;

/// A bulletin board implemented on postgresql
pub struct PgsqlBoard {
    pub(crate) board_client: BoardClient,
    pub(crate) board_name: String,
    pub(crate) store_root: Option<PathBuf>,
}

impl PgsqlBoard {
    pub async fn new(
        connection: &PgsqlDbConnectionParams,
        board_name: String,
        store_root: Option<PathBuf>,
    ) -> Result<PgsqlBoard> {
        let board_client = BoardClient::new(&connection).await?;
        Ok(PgsqlBoard {
            board_client: board_client,
            board_name: board_name.to_string(),
            store_root,
        })
    }

    // Returns all messages whose id > last_id.
    async fn get_remote_messages(&mut self, last_id: i64) -> Result<Vec<BoardMessage>> {
        let messages = self
            .board_client
            .get_messages(&self.board_name, last_id)
            .await?;

        Ok(messages)
    }

    fn get_store(&self) -> Result<Connection> {
        let db_path = self
            .store_root
            .as_ref()
            .expect("only called when store_root is some")
            .join(&self.board_name);
        let connection = Connection::open(&db_path)?;
        // The autogenerated id column is used to establish an order that cannot be manipulated by the external board. Once a retrieved message is
        // stored and assigned a local id, it is not possible for later messages to have an earlier id.
        // The external_id column is used to retrieve _new_ messages as defined by the external board (to optimize bandwidth).
        connection.execute("CREATE TABLE if not exists MESSAGES(id INTEGER PRIMARY KEY AUTOINCREMENT, external_id INT, message BLOB NOT NULL UNIQUE)", [])?;

        Ok(connection)
    }

    async fn store_and_get_messages(
        &mut self,
        last_id: Option<i64>,
    ) -> Result<Vec<(Message, i64)>> {
        let connection = self.get_store()?;

        let external_last_id =
            connection.query_row("SELECT max(external_id) FROM messages;", [], |row| {
                row.get(0)
            });

        if external_last_id.is_err() {
            warn!(
                "sql error retrieving external_last_id {:?}",
                external_last_id
            );
        }

        // When querying for all messages we use -1 as default lower limit (this requests uses the > comparator in sql)
        let messages = self
            .get_remote_messages(external_last_id.unwrap_or(-1))
            .await?;

        // One by one implementation
        // When retrieving messages one at a time from immudb we use 0 as default value since
        // immudb ids start at 1 (this requests uses the = comparator in sql)
        /* let messages = self
        .get_remote_messages_consecutively(external_last_id.unwrap_or(0))
        .await?;*/

        info!(
            "Retrieved {} messages remotely, storing locally",
            messages.len()
        );

        // FIXME verify message signatures before inserting in local store
        let mut statement =
            connection.prepare("INSERT INTO MESSAGES(external_id, message) VALUES(?1, ?2)")?;
        connection.execute("BEGIN TRANSACTION", [])?;
        for message in messages {
            statement.execute(params![message.id, message.message])?;
        }
        connection.execute("END TRANSACTION", [])?;

        let mut stmt =
            connection.prepare("SELECT id,message FROM MESSAGES where id > ?1 order by id asc")?;
        // When querying for all messages in the store we use -1 as a lower limit
        let rows = stmt.query_map([last_id.unwrap_or(-1)], |row| {
            Ok(MessageRow {
                id: row.get(0)?,
                message: row.get(1)?,
            })
        })?;

        info!("Deserializing rows into Message structs..");
        let messages: Result<Vec<(Message, i64)>> = rows
            .map(|mr| {
                let row = mr?;
                let id = row.id;
                let message = Message::strand_deserialize(&row.message)?;
                Ok((message, id))
            })
            .collect();

        messages
    }
}

impl super::Board for PgsqlBoard {
    type Factory = PgsqlBoardParams;

    // Returns all messages whose id > last_id. If last_id is None, all messages will be returned.
    // If a store is used only the messages not previously received will be requested.
    async fn get_messages(&mut self, last_id: Option<i64>) -> Result<Vec<(Message, i64)>> {
        let messages = if self.store_root.is_some() {
            // When using a store, only the messages not previously received will be requested
            self.store_and_get_messages(last_id).await?
        } else {
            // If last_id is None, use -1 as last_id
            let messages = self.get_remote_messages(last_id.unwrap_or(-1)).await?;

            messages
                .iter()
                .map(|m| {
                    let message = Message::strand_deserialize(&m.message)?;
                    let id = m.id;
                    Ok((message, id))
                })
                .collect::<Result<Vec<(Message, i64)>>>()?
        };

        Ok(messages)
    }

    async fn insert_messages(&mut self, messages: Vec<Message>) -> Result<()> {
        if messages.len() > 0 {
            let bm: Result<Vec<BoardMessage>> =
                messages.into_iter().map(|m| m.try_into()).collect();
            self.board_client
                .insert_messages(&self.board_name, &bm?)
                .await
        } else {
            Ok(())
        }
    }
}

#[derive(Clone)]
pub struct PgsqlConnectionParams {
    host: String,
    port: u32,
    username: String,
    password: String,
}
impl PgsqlConnectionParams {
    pub fn new(host: &str, port: u32, username: &str, password: &str) -> PgsqlConnectionParams {
        PgsqlConnectionParams {
            host: host.to_string(),
            port: port,
            username: username.to_string(),
            password: password.to_string(),
        }
    }
    pub fn connection_string(&self) -> String {
        format!(
            "host={} port={} user={} password={}",
            self.host, self.port, self.username, self.password
        )
    }
    pub fn with_database(&self, db_name: &str) -> PgsqlDbConnectionParams {
        PgsqlDbConnectionParams::new(self, db_name)
    }
}

#[derive(Clone)]
pub struct PgsqlDbConnectionParams {
    connection: PgsqlConnectionParams,
    db_name: String,
}
impl PgsqlDbConnectionParams {
    pub fn new(connection: &PgsqlConnectionParams, db_name: &str) -> PgsqlDbConnectionParams {
        PgsqlDbConnectionParams {
            connection: connection.clone(),
            db_name: db_name.to_string(),
        }
    }
    pub fn connection_string(&self) -> String {
        format!(
            "{} dbname={}",
            self.connection.connection_string(),
            self.db_name
        )
    }
}

pub struct PgsqlBoardParams {
    connection: PgsqlDbConnectionParams,
    board_name: String,
    store_root: Option<PathBuf>,
}
impl PgsqlBoardParams {
    pub fn new(
        connection: &PgsqlDbConnectionParams,
        board_name: String,
        store_root: Option<PathBuf>,
    ) -> PgsqlBoardParams {
        PgsqlBoardParams {
            connection: connection.clone(),
            board_name,
            store_root,
        }
    }
}

impl super::BoardFactory<PgsqlBoard> for PgsqlBoardParams {
    async fn get_board(&self) -> Result<PgsqlBoard> {
        PgsqlBoard::new(
            &self.connection,
            self.board_name.clone(),
            self.store_root.clone(),
        )
        .await
    }
}

/*
/// A bulletin board index implemented on immudb
pub struct PgsqlBoardIndex {
    board_client: BoardClient,
    index_dbname: String,
}

impl PgsqlBoardIndex {
    pub async fn new(
        server_url: &str,
        username: &str,
        password: &str,
        dbname: String,
    ) -> Result<ImmudbBoardIndex> {
        let board_client = BoardClient::new(server_url, username, password).await?;
        Ok(ImmudbBoardIndex {
            board_client: board_client,
            index_dbname,
        })
    }

    pub async fn get_board_names(&mut self) -> Result<Vec<String>> {
        self.board_client
            .get_boards(&self.index_dbname)
            .await?
            .iter()
            .map(|board: &Board| Ok(board.database_name.clone()))
            .collect()
    }
}*/

struct MessageRow {
    id: i64,
    message: Vec<u8>,
}

#[derive(Debug, Clone)]
pub struct Board {
    pub id: i32,
    pub board_name: String,
    pub is_archived: bool,
}

impl TryFrom<&Row> for Board {
    type Error = anyhow::Error;

    fn try_from(row: &Row) -> Result<Self, Self::Error> {
        let id = row.get("id");
        let board_name = row.get("board_name");
        let is_archived = row.get("is_archived");

        Ok(Board {
            id,
            board_name,
            is_archived,
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct BoardMessage {
    pub id: i64,
    pub created: SystemTime,
    // Base64 encoded spki der representation.
    pub sender_pk: String,
    pub statement_timestamp: SystemTime,
    pub statement_kind: String,
    pub message: Vec<u8>,
    pub version: String,
}

impl TryFrom<&Row> for BoardMessage {
    type Error = anyhow::Error;

    fn try_from(row: &Row) -> Result<Self, Self::Error> {
        let id = row.get("id");
        let created = row.get("created");
        let sender_pk = row.get("sender_pk");
        let statement_timestamp = row.get("statement_timestamp");
        let statement_kind = row.get("statement_kind");
        let message = row.get("message");
        let version = row.get("version");

        Ok(BoardMessage {
            id,
            created,
            sender_pk,
            statement_timestamp,
            statement_kind,
            message,
            version,
        })
    }
}

impl TryFrom<Message> for BoardMessage {
    type Error = anyhow::Error;

    fn try_from(message: Message) -> Result<BoardMessage> {
        let duration = Duration::new(message.statement.get_timestamp(), 0);
        let statement_timestamp = SystemTime::UNIX_EPOCH
            .checked_add(duration)
            .ok_or(anyhow!("Could not convert incoming timestamp"))?;

        Ok(BoardMessage {
            id: 0,
            created: SystemTime::now(),
            statement_timestamp: statement_timestamp,
            statement_kind: message.statement.get_kind().to_string(),
            message: message.strand_serialize()?,
            sender_pk: message.sender.pk.to_der_b64_string()?,
            version: board_messages::get_schema_version(),
        })
    }
}
// Run ignored tests with
// cargo test <test_name> -- --include-ignored
#[cfg(test)]
pub(crate) mod tests {
    use std::alloc::System;

    use super::*;
    use serial_test::serial;

    const PG_DATABASE: &'static str = "protocoldb";
    const PG_HOST: &'static str = "postgres";
    const PG_USER: &'static str = "postgres";
    const PG_PASSW: &'static str = "postgrespassword";
    const PG_PORT: u32 = 5432;
    const TEST_BOARD: &'static str = "testboard";

    // We cannot use create_database_and_index because we additionally drop the database here
    async fn set_up() -> BoardClient {
        let c = PgsqlConnectionParams::new(PG_HOST, PG_PORT, PG_USER, PG_PASSW);
        drop_database(&c, PG_DATABASE).await.unwrap();

        let mut client = BoardClient::new(&c.with_database(PG_DATABASE))
            .await
            .unwrap();
        client.create_index_ine().await.unwrap();

        client
    }

    #[tokio::test]
    #[ignore]
    #[serial]
    async fn test_create_delete_board() {
        // let mut client = BoardClient::new(PG_HOST, PG_PORT, PG_USER, PG_PASSW, PG_DATABASE).await.unwrap();
        let mut client = set_up().await;
        client.create_board_ine(TEST_BOARD).await.unwrap();
        let board = client.get_board(TEST_BOARD).await.unwrap();
        assert_eq!(board.board_name, TEST_BOARD);
        let board = client.get_board("NOT FOUND").await;
        assert!(board.is_err());
        client.delete_board(TEST_BOARD).await.unwrap();
        let board = client.get_board(TEST_BOARD).await;
        assert!(board.is_err());
    }

    #[tokio::test]
    #[ignore]
    #[serial]
    pub async fn test_message_create_retrieve() {
        let mut client = set_up().await;
        client.create_board_ine(TEST_BOARD).await.unwrap();
        let board = client.get_board(TEST_BOARD).await.unwrap();
        assert_eq!(board.board_name, TEST_BOARD);
        let board_message = BoardMessage {
            id: 1,
            created: SystemTime::now(),
            sender_pk: "".to_string(),
            statement_timestamp: SystemTime::now(),
            statement_kind: "".to_string(),
            message: vec![],
            version: "".to_string(),
        };
        let messages = vec![board_message.clone()];
        client.insert_messages(TEST_BOARD, &messages).await.unwrap();

        let ret = client.get_messages(TEST_BOARD, 0).await.unwrap();
        assert_eq!(messages.len(), 1);
        let msg = ret.get(0).unwrap();
        // id is autogenerated by postgres
        // timestamps will not match due to less precision on postgres side
        assert_eq!(msg.sender_pk, board_message.sender_pk);
        assert_eq!(msg.statement_kind, board_message.statement_kind);
        assert_eq!(msg.message, board_message.message);
        assert_eq!(msg.version, board_message.version);
    }
}

///////////////////////////////////////////////////////////////////////////
// PostgreSql client
//
///////////////////////////////////////////////////////////////////////////

const INDEX_TABLE: &'static str = "BULLETIN_BOARDS";
const PG_DEFAULT_ENTRIES_TX_LIMIT: usize = 50;
const PG_DEFAULT_OFFSET: usize = 0;
const PG_DEFAULT_LIMIT: usize = 2500;

pub struct BoardClient {
    client: tokio_postgres::Client,
}

impl BoardClient {
    /// Creates a new BoardClient. The underlying connection will be closed when the client is dropped.
    pub async fn new(connection: &PgsqlDbConnectionParams) -> Result<BoardClient> {
        let (client, connection) =
            tokio_postgres::connect(&connection.connection_string(), NoTls).await?;

        // The connection object performs the actual communication with the database,
        // so spawn it off to run on its own.
        tokio::spawn(async move {
            if let Err(e) = connection.await {
                eprintln!("connection error: {}", e);
            }
        });

        let ret = BoardClient { client };

        Ok(ret)
    }

    /// Creates the index table if it doesn't exist.
    #[instrument(skip(self))]
    pub async fn create_index_ine(&mut self) -> Result<()> {
        let transaction = self.client.transaction().await?;
        transaction
            .execute(
                &format!(
                    r#"
            CREATE TABLE IF NOT EXISTS {} (
                id SERIAL PRIMARY KEY,
                board_name VARCHAR,
                is_archived BOOLEAN
            );
            "#,
                    INDEX_TABLE
                ),
                &[],
            )
            .await?;
        transaction
            .execute(
                &format!(
                    r#"
            CREATE UNIQUE INDEX IF NOT EXISTS BOARD_NAME_IDX ON {}(board_name);
            "#,
                    INDEX_TABLE
                ),
                &[],
            )
            .await?;
        transaction.commit().await?;

        Ok(())
    }

    /// Creates the requested board table and adds it to the index, if it doesn't exist.
    #[instrument(skip(self))]
    pub async fn create_board_ine(&mut self, board: &str) -> Result<()> {
        let transaction = self.client.transaction().await?;
        transaction
            .execute(
                &format!(
                    r#"
            CREATE TABLE IF NOT EXISTS {} (
                id BIGSERIAL PRIMARY KEY,
                created TIMESTAMP,
                sender_pk VARCHAR,
                statement_timestamp TIMESTAMP,
                statement_kind VARCHAR,
                message BYTEA,
                version VARCHAR
            );
            "#,
                    board
                ),
                &[],
            )
            .await?;

        let message_sql = r#"
            INSERT INTO bulletin_boards(
                board_name,
                is_archived
            ) VALUES (
                $1,
                $2
            ) ON CONFLICT (board_name) DO NOTHING;
        "#;
        transaction.execute(message_sql, &[&board, &false]).await?;
        transaction.commit().await?;
        Ok(())
    }

    /// Gets the requested board from the index.
    pub async fn get_board(&mut self, board_name: &str) -> Result<Board> {
        let message_sql = format!(
            r#"
        SELECT
            id,
            board_name,
            is_archived
        FROM {}
        WHERE board_name = $1;
        "#,
            INDEX_TABLE
        );

        let sql_query_response = self.client.query(&message_sql, &[&board_name]).await?;
        let boards = sql_query_response
            .iter()
            .map(Board::try_from)
            .collect::<Result<Vec<Board>>>()?;

        if boards.len() > 0 {
            Ok(boards[0].clone())
        } else {
            Err(anyhow!("board name '{}' not found", board_name))
        }
    }

    /// Get all messages whose id is bigger than `last_id`.
    pub async fn get_messages(
        &mut self,
        board_name: &str,
        last_id: i64,
    ) -> Result<Vec<BoardMessage>> {
        let mut offset: usize = 0;
        let mut last_batch = self
            .get(board_name, last_id, Some(PG_DEFAULT_LIMIT), Some(offset))
            .await?;
        let mut messages = last_batch.clone();
        while PG_DEFAULT_LIMIT == last_batch.len() {
            offset += last_batch.len();
            last_batch = self
                .get(board_name, last_id, Some(PG_DEFAULT_LIMIT), Some(offset))
                .await?;
            messages.extend(last_batch.clone());
        }
        Ok(messages)
    }

    async fn get(
        &mut self,
        board: &str,
        last_id: i64,
        limit: Option<usize>,
        offset: Option<usize>,
    ) -> Result<Vec<BoardMessage>> {
        let sql = format!(
            r#"
        SELECT
            id,
            created,
            sender_pk,
            statement_timestamp,
            statement_kind,
            message,
            version
        FROM {}
        WHERE id > $1
        ORDER BY id
        LIMIT {}
        OFFSET {};
        "#,
            board,
            limit.unwrap_or(PG_DEFAULT_LIMIT),
            offset.unwrap_or(PG_DEFAULT_OFFSET),
        );

        let sql_query_response = self.client.query(&sql, &[&last_id]).await?;
        let messages = sql_query_response
            .iter()
            .map(BoardMessage::try_from)
            .collect::<Result<Vec<BoardMessage>>>()?;

        Ok(messages)
    }

    /// Get all boards in the index
    pub async fn get_boards(&mut self) -> Result<Vec<Board>> {
        let sql = format!(
            r#"
        SELECT
            id,
            board_name,
            is_archived
        FROM bulletin_boards
        WHERE is_archived = {}
        "#,
            false
        );
        let sql_query_response = self.client.query(&sql, &[]).await?;
        let boards = sql_query_response
            .iter()
            .map(Board::try_from)
            .collect::<Result<Vec<Board>>>()?;

        Ok(boards)
    }

    pub async fn get_with_kind(
        &mut self,
        board: &str,
        kind: &str,
        sender_pk: &str,
    ) -> Result<Vec<BoardMessage>> {
        let sql = format!(
            r#"
        SELECT
            id,
            created,
            sender_pk,
            statement_timestamp,
            statement_kind,
            message,
            version
        FROM {}
        WHERE sender_pk = $1 AND statement_kind = $2
        ORDER BY id;
        "#,
            board
        );

        let sql_query_response = self.client.query(&sql, &[&sender_pk, &kind]).await?;
        let messages = sql_query_response
            .iter()
            .map(BoardMessage::try_from)
            .collect::<Result<Vec<BoardMessage>>>()?;

        Ok(messages)
    }

    /// Inserts messages into the requested board table.
    pub async fn insert_messages(
        &mut self,
        board_name: &str,
        messages: &Vec<BoardMessage>,
    ) -> Result<()> {
        for chunk in messages.chunks(PG_DEFAULT_ENTRIES_TX_LIMIT) {
            let chunk_vec: Vec<BoardMessage> = chunk.to_vec();
            self.insert(board_name, &chunk_vec).await?;
        }
        Ok(())
    }

    async fn insert(&mut self, board_name: &str, messages: &Vec<BoardMessage>) -> Result<()> {
        info!("Insert {} messages..", messages.len());

        // Start a new transaction
        let transaction = self.client.transaction().await?;

        for message in messages {
            let message_sql = format!(
                r#"
                INSERT INTO {} (
                    created,
                    sender_pk,
                    statement_timestamp,
                    statement_kind,
                    message,
                    version
                ) VALUES (
                    $1,
                    $2,
                    $3,
                    $4,
                    $5,
                    $6
                );
            "#,
                board_name
            );

            transaction
                .execute(
                    &message_sql,
                    &[
                        &message.created,
                        &message.sender_pk,
                        &message.statement_timestamp,
                        &message.statement_kind,
                        &message.message,
                        &message.version,
                    ],
                )
                .await?;
        }

        transaction.commit().await?;

        Ok(())
    }

    /// Get one messages matching id.
    pub async fn get_one_message(
        &mut self,
        board_name: &str,
        id: i64,
    ) -> Result<Option<BoardMessage>> {
        self.get_one(board_name, id).await
    }

    async fn get_one(&mut self, board_name: &str, id: i64) -> Result<Option<BoardMessage>> {
        let sql = format!(
            r#"
        SELECT
            id,
            created,
            sender_pk,
            statement_timestamp,
            statement_kind,
            message,
            version
        FROM {}
        WHERE id = @id
        "#,
            board_name
        );

        let rows = self.client.query(&sql, &[&id]).await?;

        if rows.len() > 0 {
            Ok(Some(BoardMessage::try_from(&rows[0])?))
        } else {
            Ok(None)
        }
    }

    /// Deletes the requested board table and removes it from the index.
    #[instrument(skip(self))]
    pub async fn delete_board(&mut self, board_name: &str) -> Result<()> {
        let transaction = self.client.transaction().await?;
        let message_sql = format!(
            r#"
            DELETE from {} where 
            board_name = $1
            AND
            is_archived = $2;
        "#,
            INDEX_TABLE
        );

        transaction
            .execute(&message_sql, &[&board_name, &false])
            .await?;
        transaction
            .execute(&format!("DROP TABLE IF EXISTS {};", board_name), &[])
            .await?;

        transaction.commit().await?;

        Ok(())
    }

    /// Clears all data in the database.
    pub async fn clear_database(&mut self) -> Result<()> {
        let transaction = self.client.transaction().await?;
        transaction
            .execute("drop schema if exists public cascade;", &[])
            .await?;
        transaction
            .execute("create schema if not exists public;", &[])
            .await?;
        transaction.commit().await?;
        Ok(())
    }
}

/// Utility function to create a database and the index table.
pub(crate) async fn create_database_and_index(
    c: &PgsqlConnectionParams,
    dbname: &str,
) -> Result<BoardClient> {
    let (client, connection) = tokio_postgres::connect(&c.connection_string(), NoTls).await?;

    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("connection error: {}", e);
        }
    });

    client
        .execute(&format!("CREATE DATABASE {}", dbname), &[])
        .await?;
    drop(client);

    let mut client = BoardClient::new(&c.with_database(dbname)).await?;
    client.create_index_ine().await?;

    Ok(client)
}

/// Utility function to drop a database (will not pass a database parameter in the connection string).
pub(crate) async fn drop_database(c: &PgsqlConnectionParams, dbname: &str) -> Result<()> {
    let (client, connection) = tokio_postgres::connect(&c.connection_string(), NoTls)
        .await
        .unwrap();

    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("connection error: {}", e);
        }
    });

    client
        .execute(&format!("DROP DATABASE IF EXISTS {}", dbname), &[])
        .await
        .unwrap();

    Ok(())
}
