schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60
  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

type Aggregate {
  count: Int!
}

input ApplicationChangeStatusBody {
  area_id: String
  election_event_id: String!
  id: String!
  rejection_message: String
  rejection_reason: String
  tenant_id: String
  user_id: String!
}

type ApplicationChangeStatusOutput {
  error: String
  message: String
}

input ApplicationVerifyBody {
  annotations: jsonb
  applicant_data: jsonb
  applicant_id: String
  area_id: String
  election_event_id: String
  labels: jsonb
  tenant_id: String
}

type BallotPublicationStyles {
  ballot_publication_id: String!
  ballot_styles: jsonb!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type CastVoteEntry {
  ballot_id: String!
  statement_kind: String!
  statement_timestamp: Int!
  username: String!
}

type CastVotesByIp {
  country: String
  election_id: String
  election_name: String
  id: String
  ip: String
  vote_count: Int
  voters_id: [String]
}

type CastVotesPerDay {
  day: date!
  day_count: Int!
}

input CheckPrivateKeyInput {
  election_event_id: String!
  keys_ceremony_id: String!
  private_key_base64: String!
}

type CheckPrivateKeyOutput {
  is_valid: Boolean!
}

input CountUsersInput {
  attributes: jsonb
  authorized_to_election_alias: String
  election_event_id: uuid
  election_id: uuid
  email: jsonb
  email_verified: Boolean
  enabled: Boolean
  first_name: jsonb
  has_voted: Boolean
  last_name: jsonb
  limit: Int
  offset: Int
  search: String
  show_votes_info: Boolean
  sort: jsonb
  tenant_id: uuid!
  username: jsonb
}

type CountUsersOutput {
  count: Int!
}

input CreateElectionEventInput {
  annotations: jsonb
  audit_election_event_id: String
  bulletin_board_reference: jsonb
  created_at: String
  dates: jsonb
  description: String
  encryption_protocol: String
  id: String
  is_archived: Boolean
  is_audit: Boolean
  labels: jsonb
  name: String!
  presentation: jsonb
  public_key: String
  status: jsonb
  tenant_id: String!
  updated_at: String
  user_boards: String
  voting_channels: jsonb
}

type CreateElectionEventOutput {
  error: String
  id: String
  message: String
  task_execution: tasks_execution_type
}

type CreateElectionOutput {
  id: String!
}

input CreateKeysCeremonyInput {
  election_event_id: String!
  election_id: String
  is_automatic_ceremony: Boolean
  name: String
  threshold: Int!
  trustee_names: [String!]
}

type CreateKeysCeremonyOutput {
  error_message: String
  keys_ceremony_id: String!
}

input CreatePermissionInput {
  permission: KeycloakPermission2!
  tenant_id: String!
}

type CreateTallyOutput {
  tally_session_id: uuid!
}

type DataListElectoralLog {
  items: [ElectoralLogRow]!
  total: TotalAggregate!
}

type DataListPgAudit {
  items: [PgAuditRow]!
  total: TotalAggregate!
}

type DeleteElectionEvent {
  error_msg: String
  id: String
  task_execution: tasks_execution_type
}

type DeleteUserOutput {
  id: String
}

type DeleteUsersOutput {
  ids: String
}

input EditUsersInput {
  attributes: jsonb
  election_event_id: String
  email: String
  enabled: Boolean
  first_name: String
  groups: [String!]
  last_name: String
  password: String
  temporary: Boolean
  tenant_id: String!
  user_id: String!
  username: String
}

input ElectionEventStatsInput {
  election_event_id: uuid!
  end_date: String!
  start_date: String!
  user_timezone: String!
}

type ElectionEventStatsMonitoringOutput {
  approval_stats: MonitoringApproval
  authentication_stats: MonitoringAuthentication
  total_closed_votes: Int
  total_elections: Int
  total_eligible_voters: Int
  total_enrolled_voters: Int
  total_genereated_tally: Int
  total_initialize: Int
  total_not_closed_votes: Int
  total_not_genereated_tally: Int
  total_not_initialize: Int
  total_not_open_votes: Int
  total_not_start_counting_votes: Int
  total_not_started_votes: Int
  total_open_votes: Int
  total_start_counting_votes: Int
  total_started_votes: Int
  transmission_stats: MonitoringTransmissionStatus
  voting_stats: MonitoringVotingSatus
}

type ElectionEventStatsOutput {
  total_areas: Int!
  total_distinct_voters: Int!
  total_elections: Int!
  total_eligible_voters: Int!
  votes_per_day: [CastVotesPerDay]!
}

input ElectionStatsInput {
  election_event_id: uuid!
  election_id: uuid!
  end_date: String!
  start_date: String!
  user_timezone: String!
}

type ElectionStatsMonitoringOutput {
  approval_stats: MonitoringApproval
  authentication_stats: MonitoringAuthentication
  total_eligible_voters: Int
  total_enrolled_voters: Int
  total_voted: Int
}

type ElectionStatsOutput {
  total_areas: Int!
  total_distinct_voters: Int!
  votes_per_day: [CastVotesPerDay]!
}

input ElectoralLogFilter {
  created: String
  id: String
  statement_kind: String
  statement_timestamp: String
  user_id: String
}

input ElectoralLogOrderBy {
  ballot_id: OrderDirection
  created: OrderDirection
  id: OrderDirection
  statement_kind: OrderDirection
  statement_timestamp: OrderDirection
  user_id: OrderDirection
  username: OrderDirection
}

type ElectoralLogRow {
  created: Int!
  id: Int!
  message: String!
  statement_kind: String!
  statement_timestamp: Int!
  user_id: String!
}

type EncryptReportOutput {
  document_id: String
  error_msg: String
}

type ExportApplicationOutput {
  document_id: String!
  error_msg: String
  task_execution: tasks_execution_type
}

type ExportBallotPublicationOutput {
  document_id: String!
  task_execution: tasks_execution_type
}

type ExportElectionEventOutput {
  document_id: String!
  password: String
  task_execution: tasks_execution_type!
}

type ExportLogsOutput {
  document_id: String!
  task_execution: tasks_execution_type
}

input ExportOptions {
  activity_logs: Boolean
  applications: Boolean
  bulletin_board: Boolean
  include_voters: Boolean
  is_encrypted: Boolean
  password: String
  publications: Boolean
  reports: Boolean
  s3_files: Boolean
  scheduled_events: Boolean
  tally: Boolean
}

type ExportTallyResultsOutput {
  document_id: String!
  error_msg: String
  task_execution: tasks_execution_type!
}

type ExportTasksExecutionOutput {
  document_id: String!
  error_msg: String
}

type ExportTasksOutput {
  document_id: String!
  task_id: String!
}

type ExportTemplateOutput {
  document_id: String!
  error_msg: String
}

type ExportTenantUsersOutput {
  document_id: String!
  error_msg: String
  task_execution: tasks_execution_type
}

type ExportTrusteesOutput {
  document_id: String!
  error_msg: String
  task_execution: tasks_execution_type!
}

type ExportUsersOutput {
  document_id: String!
  error_msg: String
  task_execution: tasks_execution_type
}

type FetchDocumentOutput {
  url: String!
}

type GenerateGoogleMeetOutput {
  meet_link: String
}

type GenerateTemplateOutput {
  document_id: String!
  task_execution: tasks_execution_type
}

type GetBallotPublicationChangesOutput {
  current: BallotPublicationStyles!
  previous: BallotPublicationStyles
}

input GetManualVerificationInput {
  election_event_id: String!
  tenant_id: String!
  voter_id: String!
}

type GetManualVerificationOutput {
  document_id: String
  status: String
}

input GetPermissionsInput {
  limit: Int
  offset: Int
  search: String
  tenant_id: String!
}

type GetPermissionsOutput {
  items: [KeycloakPermission!]!
  total: TotalAggregate!
}

input GetPrivateKeyInput {
  election_event_id: String!
  keys_ceremony_id: String!
}

type GetPrivateKeyOutput {
  private_key_base64: String!
}

input GetRolesInput {
  limit: Int
  offset: Int
  search: String
  tenant_id: String!
}

type GetRolesOutput {
  items: [KeycloakRole!]!
  total: TotalAggregate!
}

input GetTopCastVotesByIpInput {
  country: String
  election_event_id: uuid!
  election_id: String
  ip: String
  limit: Int
  offset: Int
}

type GetTopCastVotesByIpOutput {
  items: [CastVotesByIp!]!
  total: TotalAggregate!
}

type GetUploadUrlOutput {
  document_id: String!
  url: String!
}

type GetUserTemplateOutput {
  extra_config: String!
  template_hbs: String!
}

input GetUsersInput {
  attributes: jsonb
  authorized_to_election_alias: String
  election_event_id: uuid
  election_id: uuid
  email: jsonb
  email_verified: Boolean
  enabled: Boolean
  first_name: jsonb
  has_voted: Boolean
  last_name: jsonb
  limit: Int
  offset: Int
  search: String
  show_votes_info: Boolean
  sort: jsonb
  tenant_id: uuid!
  username: jsonb
}

type GetUsersOutput {
  items: [KeycloakUser!]!
  total: TotalAggregate!
}

input ImportOptions {
  include_keycloak: Boolean
  include_roles: Boolean
  include_tenant: Boolean
}

type ImportTenantOutput {
  error: String
  message: String
  task_execution: tasks_execution_type
}

type InsertCastVoteOutput {
  annotations: jsonb
  area_id: uuid!
  ballot_id: String
  cast_ballot_signature: bytea!
  content: String
  created_at: timestamptz
  election_event_id: uuid!
  election_id: uuid!
  id: uuid!
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid!
  voter_id_string: String
}

type InsertTenantOutput {
  id: uuid!
  slug: String!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [Int!]
  """does the array contain the given value"""
  _contains: [Int!]
  _eq: [Int!]
  _gt: [Int!]
  _gte: [Int!]
  _in: [[Int!]!]
  _is_null: Boolean
  _lt: [Int!]
  _lte: [Int!]
  _neq: [Int!]
  _nin: [[Int!]!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

type KeycloakPermission {
  attributes: jsonb
  container_id: String
  description: String
  id: String
  name: String
}

input KeycloakPermission2 {
  attributes: jsonb
  container_id: String
  description: String
  id: String
  name: String
}

type KeycloakRole {
  access: jsonb
  attributes: jsonb
  client_roles: jsonb
  id: String
  name: String
  permissions: jsonb
}

input KeycloakRole2 {
  access: jsonb
  attributes: jsonb
  client_roles: jsonb
  id: String
  name: String
  permissions: jsonb
}

type KeycloakUser {
  area: KeycloakUserArea
  attributes: jsonb
  email: String
  email_verified: Boolean
  enabled: Boolean
  first_name: String
  groups: [String!]
  id: String
  last_name: String
  username: String
  votes_info: [VotesInfo!]
}

input KeycloakUser2 {
  attributes: jsonb
  email: String
  email_verified: Boolean
  enabled: Boolean
  first_name: String
  groups: [String!]
  id: String
  last_name: String
  username: String
}

type KeycloakUserArea {
  id: uuid
  name: String
}

type KeysCeremony {
  annotations: jsonb
  created_at: String
  election_event_id: String!
  execution_status: String
  id: String!
  is_default: Boolean
  labels: jsonb
  last_updated_at: String
  name: String
  permission_label: [String]
  settings: jsonb
  status: jsonb
  tenant_id: String!
  threshold: Int!
  trustee_ids: [String!]!
}

type LimitAccessByCountriesOutput {
  success: Boolean
}

type ListCastVoteMessagesOutput {
  list: [CastVoteEntry]!
  total: Int!
}

type ListKeysCeremonyOutput {
  items: [KeysCeremony!]!
  total: TotalAggregate!
}

type LogEventOutput {
  electionEventId: String
}

type ManageElectionDatesOutput {
  error_msg: String
}

type MonitoringApproval {
  total_approved: Int
  total_automated_approved: Int
  total_automated_disapproved: Int
  total_disapproved: Int
  total_manual_approved: Int
  total_manual_disapproved: Int
}

type MonitoringAuthentication {
  total_authenticated: Int
  total_invalid_password_errors: Int
  total_invalid_users_errors: Int
  total_not_authenticated: Int
}

type MonitoringTransmissionStatus {
  total_half_transmitted_results: Int
  total_not_transmitted_results: Int
  total_transmitted_results: Int
}

type MonitoringVotingSatus {
  total_voted: Int
  total_voted_tests_elections: Int
}

type OptionalId {
  id: String
}

type OptionalImportEvent {
  error: String
  id: String
  message: String
  task_execution: tasks_execution_type
}

enum OrderDirection {
  asc
  desc
}

input PgAuditFilter {
  audit_type: String
  class: String
  command: String
  dbname: String
  id: String
  session_id: String
  statement: String
  user: String
}

input PgAuditOrderBy {
  audit_type: OrderDirection
  class: OrderDirection
  command: OrderDirection
  dbname: OrderDirection
  id: OrderDirection
  server_timestamp: OrderDirection
  session_id: OrderDirection
  statement: OrderDirection
  user: OrderDirection
}

type PgAuditRow {
  audit_type: String!
  class: String!
  command: String!
  dbname: String!
  id: Int!
  server_timestamp: Int!
  session_id: String!
  statement: String!
  user: String!
}

enum PgAuditTable {
  pgaudit_hasura
  pgaudit_keycloak
}

type PrepareBallotPublicationPreviewOutput {
  document_id: String!
  error_msg: String
  task_execution: tasks_execution_type
}

type PublishBallotOutput {
  ballot_publication_id: uuid!
}

type PublishTallyOutput {
  tally_sheet_id: uuid
}

type RenderDocumentPDFOutput {
  document_id: String
  task_execution: tasks_execution_type
}

enum ReportEncryptionPolicy {
  configured_password
  unencrypted
}

input RestorePrivateKeyInput {
  election_event_id: String!
  private_key_base64: String!
  tally_session_id: String!
}

type RestorePrivateKeyOutput {
  is_valid: Boolean!
}

type ScheduledEventOutput3 {
  id: String
}

type SetCustomUrlsOutput {
  message: String
  success: Boolean!
}

type SetRolePermissionOutput {
  id: String
}

type SetUserRoleOutput {
  id: String
}

type SetVoterAuthenticationOutput {
  message: String
  success: Boolean!
}

type StartTallyOutput {
  tally_session_id: uuid!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]
  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean
  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String
  """does the column NOT match the given pattern"""
  _nlike: String
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String
  """does the column match the given SQL regular expression"""
  _similar: String
}

type TotalAggregate {
  aggregate: Aggregate!
}

type UpdateElectionVotingStatusOutput {
  election_id: uuid
}

type UpdateEventVotingStatusOutput {
  election_event_id: uuid
}

type UpsertAreaOutput {
  id: String!
}

type UserProfileAttribute {
  annotations: jsonb
  display_name: String
  group: String
  multivalued: Boolean
  name: String
  permissions: jsonb
  read_only: Boolean
  required: jsonb
  selector: jsonb
  validations: jsonb
}

type VotesInfo {
  election_id: String!
  last_voted_at: String!
  num_votes: Int!
}

enum VotingStatus {
  CLOSED
  NOT_STARTED
  OPEN
  PAUSED
}

enum VotingStatusChannel {
  KIOSK
  ONLINE
}

type applicationOutput {
  document_id: String
  error_msg: String
  task_execution: tasks_execution_type
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

type createBallotReceiptOutput {
  ballot_id: String
  id: uuid!
  status: String
}

type createTransmissionPackageOutput {
  error_msg: String
  task_execution: tasks_execution_type
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC
  """descending ordering of the cursor"""
  DESC
}

scalar date

type documentTaskOutput {
  document_id: String!
  error_msg: String
  task_execution: tasks_execution_type!
}

type generateReportOutput {
  document_id: String!
  encryption_policy: ReportEncryptionPolicy!
  task_execution: tasks_execution_type
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  """is the column contained in the given json value"""
  _contained_in: jsonb
  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  """does the string exist as a top-level key in the column"""
  _has_key: String
  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]
  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """Confirm voter application and correlate to a Voter"""
  ApplicationChangeStatus(body: ApplicationChangeStatusBody!): ApplicationChangeStatusOutput
  """Verify User Registration Application"""
  VerifyApplication(body: ApplicationVerifyBody!): String!
  """check private key"""
  check_private_key(object: CheckPrivateKeyInput!): CheckPrivateKeyOutput
  """create scheduled event"""
  createScheduledEvent(created_by: String, cron_config: String, election_event_id: uuid, event_payload: jsonb!, event_processor: String!, tenant_id: String!): ScheduledEventOutput3
  """create_ballot_receipt"""
  create_ballot_receipt(ballot_id: String!, ballot_tracker_url: String!, election_event_id: uuid!, election_id: uuid!, tenant_id: uuid!): createBallotReceiptOutput
  create_election(description: String, election_event_id: String!, name: String!, presentation: jsonb): CreateElectionOutput
  """create keys ceremony"""
  create_keys_ceremony(object: CreateKeysCeremonyInput!): CreateKeysCeremonyOutput
  create_permission(body: CreatePermissionInput!): KeycloakPermission
  create_role(role: KeycloakRole2!, tenant_id: String!): KeycloakRole!
  create_tally_ceremony(configuration: jsonb, election_event_id: uuid!, election_ids: [uuid!]!, tally_type: String): CreateTallyOutput
  create_transmission_package(area_id: uuid!, election_event_id: uuid!, election_id: uuid!, force: Boolean!, tally_session_id: uuid!): createTransmissionPackageOutput
  create_user(election_event_id: String, tenant_id: String!, user: KeycloakUser2!, user_roles_ids: [String!]): KeycloakUser!
  delete_election_event(election_event_id: String!): DeleteElectionEvent
  delete_permission(permission_name: String!, tenant_id: String!): SetRolePermissionOutput
  delete_role(role_id: String!, tenant_id: String!): SetUserRoleOutput
  delete_role_permission(permission_name: String!, role_id: String!, tenant_id: String!): SetRolePermissionOutput
  """
  delete data from the table: "sequent_backend.applications"
  """
  delete_sequent_backend_applications(
    """filter the rows which have to be deleted"""
    where: applications_bool_exp!
  ): applications_mutation_response
  """
  delete single row from the table: "sequent_backend.applications"
  """
  delete_sequent_backend_applications_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): applications
  """
  delete data from the table: "sequent_backend.area"
  """
  delete_sequent_backend_area(
    """filter the rows which have to be deleted"""
    where: area_bool_exp!
  ): area_mutation_response
  """
  delete single row from the table: "sequent_backend.area"
  """
  delete_sequent_backend_area_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): area
  """
  delete data from the table: "sequent_backend.area_contest"
  """
  delete_sequent_backend_area_contest(
    """filter the rows which have to be deleted"""
    where: area_contest_bool_exp!
  ): area_contest_mutation_response
  """
  delete single row from the table: "sequent_backend.area_contest"
  """
  delete_sequent_backend_area_contest_by_pk(id: uuid!): area_contest
  """
  delete data from the table: "sequent_backend.ballot_publication"
  """
  delete_sequent_backend_ballot_publication(
    """filter the rows which have to be deleted"""
    where: ballot_publication_bool_exp!
  ): ballot_publication_mutation_response
  """
  delete single row from the table: "sequent_backend.ballot_publication"
  """
  delete_sequent_backend_ballot_publication_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): ballot_publication
  """
  delete data from the table: "sequent_backend.ballot_style"
  """
  delete_sequent_backend_ballot_style(
    """filter the rows which have to be deleted"""
    where: ballot_style_bool_exp!
  ): ballot_style_mutation_response
  """
  delete single row from the table: "sequent_backend.ballot_style"
  """
  delete_sequent_backend_ballot_style_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): ballot_style
  """
  delete data from the table: "sequent_backend.candidate"
  """
  delete_sequent_backend_candidate(
    """filter the rows which have to be deleted"""
    where: candidate_bool_exp!
  ): candidate_mutation_response
  """
  delete single row from the table: "sequent_backend.candidate"
  """
  delete_sequent_backend_candidate_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): candidate
  """
  delete data from the table: "sequent_backend.cast_vote"
  """
  delete_sequent_backend_cast_vote(
    """filter the rows which have to be deleted"""
    where: cast_vote_bool_exp!
  ): cast_vote_mutation_response
  """
  delete single row from the table: "sequent_backend.cast_vote"
  """
  delete_sequent_backend_cast_vote_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): cast_vote
  """
  delete data from the table: "sequent_backend.contest"
  """
  delete_sequent_backend_contest(
    """filter the rows which have to be deleted"""
    where: contest_bool_exp!
  ): contest_mutation_response
  """
  delete single row from the table: "sequent_backend.contest"
  """
  delete_sequent_backend_contest_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): contest
  """
  delete data from the table: "sequent_backend.document"
  """
  delete_sequent_backend_document(
    """filter the rows which have to be deleted"""
    where: document_bool_exp!
  ): document_mutation_response
  """
  delete single row from the table: "sequent_backend.document"
  """
  delete_sequent_backend_document_by_pk(id: uuid!): document
  """
  delete data from the table: "sequent_backend.election"
  """
  delete_sequent_backend_election(
    """filter the rows which have to be deleted"""
    where: election_bool_exp!
  ): election_mutation_response
  """
  delete single row from the table: "sequent_backend.election"
  """
  delete_sequent_backend_election_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): election
  """
  delete data from the table: "sequent_backend.election_event"
  """
  delete_sequent_backend_election_event(
    """filter the rows which have to be deleted"""
    where: election_event_bool_exp!
  ): election_event_mutation_response
  """
  delete single row from the table: "sequent_backend.election_event"
  """
  delete_sequent_backend_election_event_by_pk(id: uuid!): election_event
  """
  delete data from the table: "sequent_backend.election_result"
  """
  delete_sequent_backend_election_result(
    """filter the rows which have to be deleted"""
    where: election_result_bool_exp!
  ): election_result_mutation_response
  """
  delete single row from the table: "sequent_backend.election_result"
  """
  delete_sequent_backend_election_result_by_pk(id: uuid!): election_result
  """
  delete data from the table: "sequent_backend.election_type"
  """
  delete_sequent_backend_election_type(
    """filter the rows which have to be deleted"""
    where: election_type_bool_exp!
  ): election_type_mutation_response
  """
  delete single row from the table: "sequent_backend.election_type"
  """
  delete_sequent_backend_election_type_by_pk(id: uuid!, tenant_id: uuid!): election_type
  """
  delete data from the table: "sequent_backend.event_execution"
  """
  delete_sequent_backend_event_execution(
    """filter the rows which have to be deleted"""
    where: event_execution_bool_exp!
  ): event_execution_mutation_response
  """
  delete single row from the table: "sequent_backend.event_execution"
  """
  delete_sequent_backend_event_execution_by_pk(id: uuid!): event_execution
  """
  delete data from the table: "sequent_backend.keys_ceremony"
  """
  delete_sequent_backend_keys_ceremony(
    """filter the rows which have to be deleted"""
    where: keys_ceremony_bool_exp!
  ): keys_ceremony_mutation_response
  """
  delete single row from the table: "sequent_backend.keys_ceremony"
  """
  delete_sequent_backend_keys_ceremony_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): keys_ceremony
  """
  delete data from the table: "sequent_backend.lock"
  """
  delete_sequent_backend_lock(
    """filter the rows which have to be deleted"""
    where: lock_bool_exp!
  ): lock_mutation_response
  """
  delete single row from the table: "sequent_backend.lock"
  """
  delete_sequent_backend_lock_by_pk(key: String!): lock
  """
  delete data from the table: "sequent_backend.notification"
  """
  delete_sequent_backend_notification(
    """filter the rows which have to be deleted"""
    where: notification_bool_exp!
  ): notification_mutation_response
  """
  delete single row from the table: "sequent_backend.notification"
  """
  delete_sequent_backend_notification_by_pk(id: uuid!): notification
  """
  delete data from the table: "sequent_backend.report"
  """
  delete_sequent_backend_report(
    """filter the rows which have to be deleted"""
    where: report_bool_exp!
  ): report_mutation_response
  """
  delete single row from the table: "sequent_backend.report"
  """
  delete_sequent_backend_report_by_pk(id: uuid!): report
  """
  delete data from the table: "sequent_backend.results_area_contest"
  """
  delete_sequent_backend_results_area_contest(
    """filter the rows which have to be deleted"""
    where: results_area_contest_bool_exp!
  ): results_area_contest_mutation_response
  """
  delete single row from the table: "sequent_backend.results_area_contest"
  """
  delete_sequent_backend_results_area_contest_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_area_contest
  """
  delete data from the table: "sequent_backend.results_area_contest_candidate"
  """
  delete_sequent_backend_results_area_contest_candidate(
    """filter the rows which have to be deleted"""
    where: results_area_contest_candidate_bool_exp!
  ): results_area_contest_candidate_mutation_response
  """
  delete single row from the table: "sequent_backend.results_area_contest_candidate"
  """
  delete_sequent_backend_results_area_contest_candidate_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_area_contest_candidate
  """
  delete data from the table: "sequent_backend.results_contest"
  """
  delete_sequent_backend_results_contest(
    """filter the rows which have to be deleted"""
    where: results_contest_bool_exp!
  ): results_contest_mutation_response
  """
  delete single row from the table: "sequent_backend.results_contest"
  """
  delete_sequent_backend_results_contest_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_contest
  """
  delete data from the table: "sequent_backend.results_contest_candidate"
  """
  delete_sequent_backend_results_contest_candidate(
    """filter the rows which have to be deleted"""
    where: results_contest_candidate_bool_exp!
  ): results_contest_candidate_mutation_response
  """
  delete single row from the table: "sequent_backend.results_contest_candidate"
  """
  delete_sequent_backend_results_contest_candidate_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_contest_candidate
  """
  delete data from the table: "sequent_backend.results_election"
  """
  delete_sequent_backend_results_election(
    """filter the rows which have to be deleted"""
    where: results_election_bool_exp!
  ): results_election_mutation_response
  """
  delete data from the table: "sequent_backend.results_election_area"
  """
  delete_sequent_backend_results_election_area(
    """filter the rows which have to be deleted"""
    where: results_election_area_bool_exp!
  ): results_election_area_mutation_response
  """
  delete single row from the table: "sequent_backend.results_election_area"
  """
  delete_sequent_backend_results_election_area_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_election_area
  """
  delete single row from the table: "sequent_backend.results_election"
  """
  delete_sequent_backend_results_election_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_election
  """
  delete data from the table: "sequent_backend.results_event"
  """
  delete_sequent_backend_results_event(
    """filter the rows which have to be deleted"""
    where: results_event_bool_exp!
  ): results_event_mutation_response
  """
  delete single row from the table: "sequent_backend.results_event"
  """
  delete_sequent_backend_results_event_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): results_event
  """
  delete data from the table: "sequent_backend.scheduled_event"
  """
  delete_sequent_backend_scheduled_event(
    """filter the rows which have to be deleted"""
    where: scheduled_event_bool_exp!
  ): scheduled_event_mutation_response
  """
  delete single row from the table: "sequent_backend.scheduled_event"
  """
  delete_sequent_backend_scheduled_event_by_pk(id: uuid!): scheduled_event
  """
  delete data from the table: "sequent_backend.secret"
  """
  delete_sequent_backend_secret(
    """filter the rows which have to be deleted"""
    where: secret_bool_exp!
  ): secret_mutation_response
  """
  delete single row from the table: "sequent_backend.secret"
  """
  delete_sequent_backend_secret_by_pk(id: uuid!, key: String!, tenant_id: uuid!): secret
  """
  delete data from the table: "sequent_backend.support_material"
  """
  delete_sequent_backend_support_material(
    """filter the rows which have to be deleted"""
    where: support_material_bool_exp!
  ): support_material_mutation_response
  """
  delete single row from the table: "sequent_backend.support_material"
  """
  delete_sequent_backend_support_material_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): support_material
  """
  delete data from the table: "sequent_backend.tally_session"
  """
  delete_sequent_backend_tally_session(
    """filter the rows which have to be deleted"""
    where: tally_session_bool_exp!
  ): tally_session_mutation_response
  """
  delete single row from the table: "sequent_backend.tally_session"
  """
  delete_sequent_backend_tally_session_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session
  """
  delete data from the table: "sequent_backend.tally_session_contest"
  """
  delete_sequent_backend_tally_session_contest(
    """filter the rows which have to be deleted"""
    where: tally_session_contest_bool_exp!
  ): tally_session_contest_mutation_response
  """
  delete single row from the table: "sequent_backend.tally_session_contest"
  """
  delete_sequent_backend_tally_session_contest_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session_contest
  """
  delete data from the table: "sequent_backend.tally_session_execution"
  """
  delete_sequent_backend_tally_session_execution(
    """filter the rows which have to be deleted"""
    where: tally_session_execution_bool_exp!
  ): tally_session_execution_mutation_response
  """
  delete single row from the table: "sequent_backend.tally_session_execution"
  """
  delete_sequent_backend_tally_session_execution_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session_execution
  """
  delete data from the table: "sequent_backend.tally_sheet"
  """
  delete_sequent_backend_tally_sheet(
    """filter the rows which have to be deleted"""
    where: tally_sheet_bool_exp!
  ): tally_sheet_mutation_response
  """
  delete single row from the table: "sequent_backend.tally_sheet"
  """
  delete_sequent_backend_tally_sheet_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_sheet
  """
  delete data from the table: "sequent_backend.tasks_execution"
  """
  delete_sequent_backend_tasks_execution(
    """filter the rows which have to be deleted"""
    where: tasks_execution_bool_exp!
  ): tasks_execution_mutation_response
  """
  delete single row from the table: "sequent_backend.tasks_execution"
  """
  delete_sequent_backend_tasks_execution_by_pk(id: uuid!, tenant_id: uuid!): tasks_execution
  """
  delete data from the table: "sequent_backend.template"
  """
  delete_sequent_backend_template(
    """filter the rows which have to be deleted"""
    where: template_bool_exp!
  ): template_mutation_response
  """
  delete single row from the table: "sequent_backend.template"
  """
  delete_sequent_backend_template_by_pk(id: uuid!, tenant_id: uuid!): template
  """
  delete data from the table: "sequent_backend.tenant"
  """
  delete_sequent_backend_tenant(
    """filter the rows which have to be deleted"""
    where: tenant_bool_exp!
  ): tenant_mutation_response
  """
  delete single row from the table: "sequent_backend.tenant"
  """
  delete_sequent_backend_tenant_by_pk(id: uuid!): tenant
  """
  delete data from the table: "sequent_backend.trustee"
  """
  delete_sequent_backend_trustee(
    """filter the rows which have to be deleted"""
    where: trustee_bool_exp!
  ): trustee_mutation_response
  """
  delete single row from the table: "sequent_backend.trustee"
  """
  delete_sequent_backend_trustee_by_pk(id: uuid!): trustee
  delete_user(election_event_id: String, tenant_id: String!, user_id: String!): DeleteUserOutput
  delete_user_role(role_id: String!, tenant_id: String!, user_id: String!): SetUserRoleOutput
  """delete users"""
  delete_users(election_event_id: String, tenant_id: String!, users_id: [String!]!): DeleteUsersOutput
  edit_user(body: EditUsersInput!): KeycloakUser!
  encrypt_report(election_event_id: String!, password: String!, report_id: String): EncryptReportOutput
  exportTrustees(password: String!): ExportTrusteesOutput
  export_application(election_event_id: String, election_id: String, tenant_id: String!): ExportApplicationOutput
  export_ballot_publication(ballot_publication_id: String!, election_event_id: String!, election_id: String, tenant_id: String!): ExportBallotPublicationOutput
  export_election_event(election_event_id: String, export_configurations: ExportOptions): ExportElectionEventOutput
  export_election_event_logs(election_event_id: String!, format: String!): ExportLogsOutput
  export_election_event_tasks(election_event_id: String): ExportTasksOutput
  export_tally_results(election_event_id: String!, tally_session_id: String!): ExportTallyResultsOutput
  export_tasks_execution(election_event_id: String!, tenant_id: String!): ExportTasksExecutionOutput
  export_template(election_event_id: String, election_id: String, tenant_id: String!): ExportTemplateOutput
  export_tenant_config(tenant_id: String): documentTaskOutput
  export_tenant_users(tenant_id: String!): ExportTenantUsersOutput
  export_users(election_event_id: String, election_id: String, tenant_id: String!): ExportUsersOutput
  generate_ballot_publication(election_event_id: uuid!, election_id: uuid): PublishBallotOutput
  """generate Google Meet link for election events"""
  generate_google_meet(attendee_email: String!, description: String!, end_date_time: String!, start_date_time: String!, summary: String!, time_zone: String!): GenerateGoogleMeetOutput
  generate_report(election_event_id: String, report_id: String!, report_mode: String!, tenant_id: String!): generateReportOutput
  generate_template(election_event_id: String!, election_id: String!, tally_session_id: String!, type: String!): GenerateTemplateOutput
  generate_transmission_report(election_event_id: String!, election_id: String, tally_session_id: String, tenant_id: String!): generateReportOutput
  get_ballot_publication_changes(ballot_publication_id: uuid!, election_event_id: uuid!, limit: Int): GetBallotPublicationChangesOutput
  get_manual_verification_pdf(body: GetManualVerificationInput!): GetManualVerificationOutput
  """get private key"""
  get_private_key(object: GetPrivateKeyInput!): GetPrivateKeyOutput
  get_upload_url(election_event_id: String, is_local: Boolean, is_public: Boolean!, media_type: String!, name: String!, size: Int!): GetUploadUrlOutput
  get_user(election_event_id: uuid, tenant_id: uuid!, user_id: String!): KeycloakUser!
  get_user_template(template_type: String!): GetUserTemplateOutput
  import_application(document_id: String!, election_event_id: String, election_id: String, sha256: String, tenant_id: String!): applicationOutput
  import_areas(document_id: String!, election_event_id: String!, sha256: String): OptionalId
  import_candidates(document_id: String!, election_event_id: String!, sha256: String): documentTaskOutput
  """import_election_event"""
  import_election_event(check_only: Boolean, document_id: String!, password: String, sha256: String, tenant_id: String!): OptionalImportEvent
  import_templates(document_id: String!, sha256: String, tenant_id: String!): templateOutput
  import_tenant_config(document_id: String!, import_configurations: ImportOptions, sha256: String, tenant_id: String!): ImportTenantOutput
  import_users(document_id: String!, election_event_id: String, sha256: String, tenant_id: String!): taskOutput
  insertElectionEvent(object: CreateElectionEventInput!): CreateElectionEventOutput
  """insertTenant"""
  insertTenant(slug: String!): InsertTenantOutput
  """insert_cast_vote"""
  insert_cast_vote(ballot_id: String!, content: String!, election_id: uuid!): InsertCastVoteOutput
  """
  insert data into the table: "sequent_backend.applications"
  """
  insert_sequent_backend_applications(
    """the rows to be inserted"""
    objects: [applications_insert_input!]!
    """upsert condition"""
    on_conflict: applications_on_conflict
  ): applications_mutation_response
  """
  insert a single row into the table: "sequent_backend.applications"
  """
  insert_sequent_backend_applications_one(
    """the row to be inserted"""
    object: applications_insert_input!
    """upsert condition"""
    on_conflict: applications_on_conflict
  ): applications
  """
  insert data into the table: "sequent_backend.area"
  """
  insert_sequent_backend_area(
    """the rows to be inserted"""
    objects: [area_insert_input!]!
    """upsert condition"""
    on_conflict: area_on_conflict
  ): area_mutation_response
  """
  insert data into the table: "sequent_backend.area_contest"
  """
  insert_sequent_backend_area_contest(
    """the rows to be inserted"""
    objects: [area_contest_insert_input!]!
    """upsert condition"""
    on_conflict: area_contest_on_conflict
  ): area_contest_mutation_response
  """
  insert a single row into the table: "sequent_backend.area_contest"
  """
  insert_sequent_backend_area_contest_one(
    """the row to be inserted"""
    object: area_contest_insert_input!
    """upsert condition"""
    on_conflict: area_contest_on_conflict
  ): area_contest
  """
  insert a single row into the table: "sequent_backend.area"
  """
  insert_sequent_backend_area_one(
    """the row to be inserted"""
    object: area_insert_input!
    """upsert condition"""
    on_conflict: area_on_conflict
  ): area
  """
  insert data into the table: "sequent_backend.ballot_publication"
  """
  insert_sequent_backend_ballot_publication(
    """the rows to be inserted"""
    objects: [ballot_publication_insert_input!]!
    """upsert condition"""
    on_conflict: ballot_publication_on_conflict
  ): ballot_publication_mutation_response
  """
  insert a single row into the table: "sequent_backend.ballot_publication"
  """
  insert_sequent_backend_ballot_publication_one(
    """the row to be inserted"""
    object: ballot_publication_insert_input!
    """upsert condition"""
    on_conflict: ballot_publication_on_conflict
  ): ballot_publication
  """
  insert data into the table: "sequent_backend.ballot_style"
  """
  insert_sequent_backend_ballot_style(
    """the rows to be inserted"""
    objects: [ballot_style_insert_input!]!
    """upsert condition"""
    on_conflict: ballot_style_on_conflict
  ): ballot_style_mutation_response
  """
  insert a single row into the table: "sequent_backend.ballot_style"
  """
  insert_sequent_backend_ballot_style_one(
    """the row to be inserted"""
    object: ballot_style_insert_input!
    """upsert condition"""
    on_conflict: ballot_style_on_conflict
  ): ballot_style
  """
  insert data into the table: "sequent_backend.candidate"
  """
  insert_sequent_backend_candidate(
    """the rows to be inserted"""
    objects: [candidate_insert_input!]!
    """upsert condition"""
    on_conflict: candidate_on_conflict
  ): candidate_mutation_response
  """
  insert a single row into the table: "sequent_backend.candidate"
  """
  insert_sequent_backend_candidate_one(
    """the row to be inserted"""
    object: candidate_insert_input!
    """upsert condition"""
    on_conflict: candidate_on_conflict
  ): candidate
  """
  insert data into the table: "sequent_backend.cast_vote"
  """
  insert_sequent_backend_cast_vote(
    """the rows to be inserted"""
    objects: [cast_vote_insert_input!]!
    """upsert condition"""
    on_conflict: cast_vote_on_conflict
  ): cast_vote_mutation_response
  """
  insert a single row into the table: "sequent_backend.cast_vote"
  """
  insert_sequent_backend_cast_vote_one(
    """the row to be inserted"""
    object: cast_vote_insert_input!
    """upsert condition"""
    on_conflict: cast_vote_on_conflict
  ): cast_vote
  """
  insert data into the table: "sequent_backend.contest"
  """
  insert_sequent_backend_contest(
    """the rows to be inserted"""
    objects: [contest_insert_input!]!
    """upsert condition"""
    on_conflict: contest_on_conflict
  ): contest_mutation_response
  """
  insert a single row into the table: "sequent_backend.contest"
  """
  insert_sequent_backend_contest_one(
    """the row to be inserted"""
    object: contest_insert_input!
    """upsert condition"""
    on_conflict: contest_on_conflict
  ): contest
  """
  insert data into the table: "sequent_backend.document"
  """
  insert_sequent_backend_document(
    """the rows to be inserted"""
    objects: [document_insert_input!]!
    """upsert condition"""
    on_conflict: document_on_conflict
  ): document_mutation_response
  """
  insert a single row into the table: "sequent_backend.document"
  """
  insert_sequent_backend_document_one(
    """the row to be inserted"""
    object: document_insert_input!
    """upsert condition"""
    on_conflict: document_on_conflict
  ): document
  """
  insert data into the table: "sequent_backend.election"
  """
  insert_sequent_backend_election(
    """the rows to be inserted"""
    objects: [election_insert_input!]!
    """upsert condition"""
    on_conflict: election_on_conflict
  ): election_mutation_response
  """
  insert data into the table: "sequent_backend.election_event"
  """
  insert_sequent_backend_election_event(
    """the rows to be inserted"""
    objects: [election_event_insert_input!]!
    """upsert condition"""
    on_conflict: election_event_on_conflict
  ): election_event_mutation_response
  """
  insert a single row into the table: "sequent_backend.election_event"
  """
  insert_sequent_backend_election_event_one(
    """the row to be inserted"""
    object: election_event_insert_input!
    """upsert condition"""
    on_conflict: election_event_on_conflict
  ): election_event
  """
  insert a single row into the table: "sequent_backend.election"
  """
  insert_sequent_backend_election_one(
    """the row to be inserted"""
    object: election_insert_input!
    """upsert condition"""
    on_conflict: election_on_conflict
  ): election
  """
  insert data into the table: "sequent_backend.election_result"
  """
  insert_sequent_backend_election_result(
    """the rows to be inserted"""
    objects: [election_result_insert_input!]!
    """upsert condition"""
    on_conflict: election_result_on_conflict
  ): election_result_mutation_response
  """
  insert a single row into the table: "sequent_backend.election_result"
  """
  insert_sequent_backend_election_result_one(
    """the row to be inserted"""
    object: election_result_insert_input!
    """upsert condition"""
    on_conflict: election_result_on_conflict
  ): election_result
  """
  insert data into the table: "sequent_backend.election_type"
  """
  insert_sequent_backend_election_type(
    """the rows to be inserted"""
    objects: [election_type_insert_input!]!
    """upsert condition"""
    on_conflict: election_type_on_conflict
  ): election_type_mutation_response
  """
  insert a single row into the table: "sequent_backend.election_type"
  """
  insert_sequent_backend_election_type_one(
    """the row to be inserted"""
    object: election_type_insert_input!
    """upsert condition"""
    on_conflict: election_type_on_conflict
  ): election_type
  """
  insert data into the table: "sequent_backend.event_execution"
  """
  insert_sequent_backend_event_execution(
    """the rows to be inserted"""
    objects: [event_execution_insert_input!]!
    """upsert condition"""
    on_conflict: event_execution_on_conflict
  ): event_execution_mutation_response
  """
  insert a single row into the table: "sequent_backend.event_execution"
  """
  insert_sequent_backend_event_execution_one(
    """the row to be inserted"""
    object: event_execution_insert_input!
    """upsert condition"""
    on_conflict: event_execution_on_conflict
  ): event_execution
  """
  insert data into the table: "sequent_backend.keys_ceremony"
  """
  insert_sequent_backend_keys_ceremony(
    """the rows to be inserted"""
    objects: [keys_ceremony_insert_input!]!
    """upsert condition"""
    on_conflict: keys_ceremony_on_conflict
  ): keys_ceremony_mutation_response
  """
  insert a single row into the table: "sequent_backend.keys_ceremony"
  """
  insert_sequent_backend_keys_ceremony_one(
    """the row to be inserted"""
    object: keys_ceremony_insert_input!
    """upsert condition"""
    on_conflict: keys_ceremony_on_conflict
  ): keys_ceremony
  """
  insert data into the table: "sequent_backend.lock"
  """
  insert_sequent_backend_lock(
    """the rows to be inserted"""
    objects: [lock_insert_input!]!
    """upsert condition"""
    on_conflict: lock_on_conflict
  ): lock_mutation_response
  """
  insert a single row into the table: "sequent_backend.lock"
  """
  insert_sequent_backend_lock_one(
    """the row to be inserted"""
    object: lock_insert_input!
    """upsert condition"""
    on_conflict: lock_on_conflict
  ): lock
  """
  insert data into the table: "sequent_backend.notification"
  """
  insert_sequent_backend_notification(
    """the rows to be inserted"""
    objects: [notification_insert_input!]!
    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification_mutation_response
  """
  insert a single row into the table: "sequent_backend.notification"
  """
  insert_sequent_backend_notification_one(
    """the row to be inserted"""
    object: notification_insert_input!
    """upsert condition"""
    on_conflict: notification_on_conflict
  ): notification
  """
  insert data into the table: "sequent_backend.report"
  """
  insert_sequent_backend_report(
    """the rows to be inserted"""
    objects: [report_insert_input!]!
    """upsert condition"""
    on_conflict: report_on_conflict
  ): report_mutation_response
  """
  insert a single row into the table: "sequent_backend.report"
  """
  insert_sequent_backend_report_one(
    """the row to be inserted"""
    object: report_insert_input!
    """upsert condition"""
    on_conflict: report_on_conflict
  ): report
  """
  insert data into the table: "sequent_backend.results_area_contest"
  """
  insert_sequent_backend_results_area_contest(
    """the rows to be inserted"""
    objects: [results_area_contest_insert_input!]!
    """upsert condition"""
    on_conflict: results_area_contest_on_conflict
  ): results_area_contest_mutation_response
  """
  insert data into the table: "sequent_backend.results_area_contest_candidate"
  """
  insert_sequent_backend_results_area_contest_candidate(
    """the rows to be inserted"""
    objects: [results_area_contest_candidate_insert_input!]!
    """upsert condition"""
    on_conflict: results_area_contest_candidate_on_conflict
  ): results_area_contest_candidate_mutation_response
  """
  insert a single row into the table: "sequent_backend.results_area_contest_candidate"
  """
  insert_sequent_backend_results_area_contest_candidate_one(
    """the row to be inserted"""
    object: results_area_contest_candidate_insert_input!
    """upsert condition"""
    on_conflict: results_area_contest_candidate_on_conflict
  ): results_area_contest_candidate
  """
  insert a single row into the table: "sequent_backend.results_area_contest"
  """
  insert_sequent_backend_results_area_contest_one(
    """the row to be inserted"""
    object: results_area_contest_insert_input!
    """upsert condition"""
    on_conflict: results_area_contest_on_conflict
  ): results_area_contest
  """
  insert data into the table: "sequent_backend.results_contest"
  """
  insert_sequent_backend_results_contest(
    """the rows to be inserted"""
    objects: [results_contest_insert_input!]!
    """upsert condition"""
    on_conflict: results_contest_on_conflict
  ): results_contest_mutation_response
  """
  insert data into the table: "sequent_backend.results_contest_candidate"
  """
  insert_sequent_backend_results_contest_candidate(
    """the rows to be inserted"""
    objects: [results_contest_candidate_insert_input!]!
    """upsert condition"""
    on_conflict: results_contest_candidate_on_conflict
  ): results_contest_candidate_mutation_response
  """
  insert a single row into the table: "sequent_backend.results_contest_candidate"
  """
  insert_sequent_backend_results_contest_candidate_one(
    """the row to be inserted"""
    object: results_contest_candidate_insert_input!
    """upsert condition"""
    on_conflict: results_contest_candidate_on_conflict
  ): results_contest_candidate
  """
  insert a single row into the table: "sequent_backend.results_contest"
  """
  insert_sequent_backend_results_contest_one(
    """the row to be inserted"""
    object: results_contest_insert_input!
    """upsert condition"""
    on_conflict: results_contest_on_conflict
  ): results_contest
  """
  insert data into the table: "sequent_backend.results_election"
  """
  insert_sequent_backend_results_election(
    """the rows to be inserted"""
    objects: [results_election_insert_input!]!
    """upsert condition"""
    on_conflict: results_election_on_conflict
  ): results_election_mutation_response
  """
  insert data into the table: "sequent_backend.results_election_area"
  """
  insert_sequent_backend_results_election_area(
    """the rows to be inserted"""
    objects: [results_election_area_insert_input!]!
    """upsert condition"""
    on_conflict: results_election_area_on_conflict
  ): results_election_area_mutation_response
  """
  insert a single row into the table: "sequent_backend.results_election_area"
  """
  insert_sequent_backend_results_election_area_one(
    """the row to be inserted"""
    object: results_election_area_insert_input!
    """upsert condition"""
    on_conflict: results_election_area_on_conflict
  ): results_election_area
  """
  insert a single row into the table: "sequent_backend.results_election"
  """
  insert_sequent_backend_results_election_one(
    """the row to be inserted"""
    object: results_election_insert_input!
    """upsert condition"""
    on_conflict: results_election_on_conflict
  ): results_election
  """
  insert data into the table: "sequent_backend.results_event"
  """
  insert_sequent_backend_results_event(
    """the rows to be inserted"""
    objects: [results_event_insert_input!]!
    """upsert condition"""
    on_conflict: results_event_on_conflict
  ): results_event_mutation_response
  """
  insert a single row into the table: "sequent_backend.results_event"
  """
  insert_sequent_backend_results_event_one(
    """the row to be inserted"""
    object: results_event_insert_input!
    """upsert condition"""
    on_conflict: results_event_on_conflict
  ): results_event
  """
  insert data into the table: "sequent_backend.scheduled_event"
  """
  insert_sequent_backend_scheduled_event(
    """the rows to be inserted"""
    objects: [scheduled_event_insert_input!]!
    """upsert condition"""
    on_conflict: scheduled_event_on_conflict
  ): scheduled_event_mutation_response
  """
  insert a single row into the table: "sequent_backend.scheduled_event"
  """
  insert_sequent_backend_scheduled_event_one(
    """the row to be inserted"""
    object: scheduled_event_insert_input!
    """upsert condition"""
    on_conflict: scheduled_event_on_conflict
  ): scheduled_event
  """
  insert data into the table: "sequent_backend.secret"
  """
  insert_sequent_backend_secret(
    """the rows to be inserted"""
    objects: [secret_insert_input!]!
    """upsert condition"""
    on_conflict: secret_on_conflict
  ): secret_mutation_response
  """
  insert a single row into the table: "sequent_backend.secret"
  """
  insert_sequent_backend_secret_one(
    """the row to be inserted"""
    object: secret_insert_input!
    """upsert condition"""
    on_conflict: secret_on_conflict
  ): secret
  """
  insert data into the table: "sequent_backend.support_material"
  """
  insert_sequent_backend_support_material(
    """the rows to be inserted"""
    objects: [support_material_insert_input!]!
    """upsert condition"""
    on_conflict: support_material_on_conflict
  ): support_material_mutation_response
  """
  insert a single row into the table: "sequent_backend.support_material"
  """
  insert_sequent_backend_support_material_one(
    """the row to be inserted"""
    object: support_material_insert_input!
    """upsert condition"""
    on_conflict: support_material_on_conflict
  ): support_material
  """
  insert data into the table: "sequent_backend.tally_session"
  """
  insert_sequent_backend_tally_session(
    """the rows to be inserted"""
    objects: [tally_session_insert_input!]!
    """upsert condition"""
    on_conflict: tally_session_on_conflict
  ): tally_session_mutation_response
  """
  insert data into the table: "sequent_backend.tally_session_contest"
  """
  insert_sequent_backend_tally_session_contest(
    """the rows to be inserted"""
    objects: [tally_session_contest_insert_input!]!
    """upsert condition"""
    on_conflict: tally_session_contest_on_conflict
  ): tally_session_contest_mutation_response
  """
  insert a single row into the table: "sequent_backend.tally_session_contest"
  """
  insert_sequent_backend_tally_session_contest_one(
    """the row to be inserted"""
    object: tally_session_contest_insert_input!
    """upsert condition"""
    on_conflict: tally_session_contest_on_conflict
  ): tally_session_contest
  """
  insert data into the table: "sequent_backend.tally_session_execution"
  """
  insert_sequent_backend_tally_session_execution(
    """the rows to be inserted"""
    objects: [tally_session_execution_insert_input!]!
    """upsert condition"""
    on_conflict: tally_session_execution_on_conflict
  ): tally_session_execution_mutation_response
  """
  insert a single row into the table: "sequent_backend.tally_session_execution"
  """
  insert_sequent_backend_tally_session_execution_one(
    """the row to be inserted"""
    object: tally_session_execution_insert_input!
    """upsert condition"""
    on_conflict: tally_session_execution_on_conflict
  ): tally_session_execution
  """
  insert a single row into the table: "sequent_backend.tally_session"
  """
  insert_sequent_backend_tally_session_one(
    """the row to be inserted"""
    object: tally_session_insert_input!
    """upsert condition"""
    on_conflict: tally_session_on_conflict
  ): tally_session
  """
  insert data into the table: "sequent_backend.tally_sheet"
  """
  insert_sequent_backend_tally_sheet(
    """the rows to be inserted"""
    objects: [tally_sheet_insert_input!]!
    """upsert condition"""
    on_conflict: tally_sheet_on_conflict
  ): tally_sheet_mutation_response
  """
  insert a single row into the table: "sequent_backend.tally_sheet"
  """
  insert_sequent_backend_tally_sheet_one(
    """the row to be inserted"""
    object: tally_sheet_insert_input!
    """upsert condition"""
    on_conflict: tally_sheet_on_conflict
  ): tally_sheet
  """
  insert data into the table: "sequent_backend.tasks_execution"
  """
  insert_sequent_backend_tasks_execution(
    """the rows to be inserted"""
    objects: [tasks_execution_insert_input!]!
    """upsert condition"""
    on_conflict: tasks_execution_on_conflict
  ): tasks_execution_mutation_response
  """
  insert a single row into the table: "sequent_backend.tasks_execution"
  """
  insert_sequent_backend_tasks_execution_one(
    """the row to be inserted"""
    object: tasks_execution_insert_input!
    """upsert condition"""
    on_conflict: tasks_execution_on_conflict
  ): tasks_execution
  """
  insert data into the table: "sequent_backend.template"
  """
  insert_sequent_backend_template(
    """the rows to be inserted"""
    objects: [template_insert_input!]!
    """upsert condition"""
    on_conflict: template_on_conflict
  ): template_mutation_response
  """
  insert a single row into the table: "sequent_backend.template"
  """
  insert_sequent_backend_template_one(
    """the row to be inserted"""
    object: template_insert_input!
    """upsert condition"""
    on_conflict: template_on_conflict
  ): template
  """
  insert data into the table: "sequent_backend.tenant"
  """
  insert_sequent_backend_tenant(
    """the rows to be inserted"""
    objects: [tenant_insert_input!]!
    """upsert condition"""
    on_conflict: tenant_on_conflict
  ): tenant_mutation_response
  """
  insert a single row into the table: "sequent_backend.tenant"
  """
  insert_sequent_backend_tenant_one(
    """the row to be inserted"""
    object: tenant_insert_input!
    """upsert condition"""
    on_conflict: tenant_on_conflict
  ): tenant
  """
  insert data into the table: "sequent_backend.trustee"
  """
  insert_sequent_backend_trustee(
    """the rows to be inserted"""
    objects: [trustee_insert_input!]!
    """upsert condition"""
    on_conflict: trustee_on_conflict
  ): trustee_mutation_response
  """
  insert a single row into the table: "sequent_backend.trustee"
  """
  insert_sequent_backend_trustee_one(
    """the row to be inserted"""
    object: trustee_insert_input!
    """upsert condition"""
    on_conflict: trustee_on_conflict
  ): trustee
  limit_access_by_countries(enroll_countries: [String!]!, voting_countries: [String!]!): LimitAccessByCountriesOutput
  manage_election_dates(election_event_id: String!, election_id: String, event_processor: String!, scheduled_date: String): ManageElectionDatesOutput
  prepare_ballot_publication_preview(ballot_publication_id: String!, election_event_id: String!): PrepareBallotPublicationPreviewOutput
  publish_ballot(ballot_publication_id: uuid!, election_event_id: uuid!): PublishBallotOutput
  """publish_tally_sheet"""
  publish_tally_sheet(election_event_id: uuid!, publish: Boolean, tally_sheet_id: uuid!): PublishTallyOutput
  render_document_pdf(document_id: uuid!, election_event_id: uuid, tally_session_id: uuid): RenderDocumentPDFOutput
  restore_private_key(object: RestorePrivateKeyInput!): RestorePrivateKeyOutput
  send_transmission_package(area_id: uuid!, election_id: uuid!, tally_session_id: uuid!): OptionalId
  set_custom_urls(dns_prefix: String!, election_id: String!, key: String!, origin: String!, redirect_to: String!): SetCustomUrlsOutput
  set_role_permission(permission_name: String!, role_id: String!, tenant_id: String!): SetRolePermissionOutput
  set_user_role(role_id: String!, tenant_id: String!, user_id: String!): SetUserRoleOutput
  set_voter_authentication(election_event_id: String!, enrollment: String!, otp: String!): SetVoterAuthenticationOutput
  update_election_voting_status(election_event_id: uuid!, election_id: uuid!, voting_channels: [VotingStatusChannel], voting_status: VotingStatus!): UpdateElectionVotingStatusOutput
  update_event_voting_status(election_event_id: uuid!, voting_channels: [VotingStatusChannel], voting_status: VotingStatus!): UpdateEventVotingStatusOutput
  """
  update data of the table: "sequent_backend.applications"
  """
  update_sequent_backend_applications(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: applications_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: applications_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: applications_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: applications_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: applications_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: applications_set_input
    """filter the rows which have to be updated"""
    where: applications_bool_exp!
  ): applications_mutation_response
  """
  update single row of the table: "sequent_backend.applications"
  """
  update_sequent_backend_applications_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: applications_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: applications_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: applications_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: applications_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: applications_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: applications_set_input
    pk_columns: applications_pk_columns_input!
  ): applications
  """
  update multiples rows of table: "sequent_backend.applications"
  """
  update_sequent_backend_applications_many(
    """updates to execute, in order"""
    updates: [applications_updates!]!
  ): [applications_mutation_response]
  """
  update data of the table: "sequent_backend.area"
  """
  update_sequent_backend_area(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: area_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: area_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: area_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: area_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: area_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: area_set_input
    """filter the rows which have to be updated"""
    where: area_bool_exp!
  ): area_mutation_response
  """
  update single row of the table: "sequent_backend.area"
  """
  update_sequent_backend_area_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: area_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: area_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: area_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: area_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: area_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: area_set_input
    pk_columns: area_pk_columns_input!
  ): area
  """
  update data of the table: "sequent_backend.area_contest"
  """
  update_sequent_backend_area_contest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: area_contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: area_contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: area_contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: area_contest_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: area_contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: area_contest_set_input
    """filter the rows which have to be updated"""
    where: area_contest_bool_exp!
  ): area_contest_mutation_response
  """
  update single row of the table: "sequent_backend.area_contest"
  """
  update_sequent_backend_area_contest_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: area_contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: area_contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: area_contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: area_contest_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: area_contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: area_contest_set_input
    pk_columns: area_contest_pk_columns_input!
  ): area_contest
  """
  update multiples rows of table: "sequent_backend.area_contest"
  """
  update_sequent_backend_area_contest_many(
    """updates to execute, in order"""
    updates: [area_contest_updates!]!
  ): [area_contest_mutation_response]
  """
  update multiples rows of table: "sequent_backend.area"
  """
  update_sequent_backend_area_many(
    """updates to execute, in order"""
    updates: [area_updates!]!
  ): [area_mutation_response]
  """
  update data of the table: "sequent_backend.ballot_publication"
  """
  update_sequent_backend_ballot_publication(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ballot_publication_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: ballot_publication_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: ballot_publication_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: ballot_publication_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ballot_publication_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: ballot_publication_set_input
    """filter the rows which have to be updated"""
    where: ballot_publication_bool_exp!
  ): ballot_publication_mutation_response
  """
  update single row of the table: "sequent_backend.ballot_publication"
  """
  update_sequent_backend_ballot_publication_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ballot_publication_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: ballot_publication_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: ballot_publication_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: ballot_publication_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ballot_publication_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: ballot_publication_set_input
    pk_columns: ballot_publication_pk_columns_input!
  ): ballot_publication
  """
  update multiples rows of table: "sequent_backend.ballot_publication"
  """
  update_sequent_backend_ballot_publication_many(
    """updates to execute, in order"""
    updates: [ballot_publication_updates!]!
  ): [ballot_publication_mutation_response]
  """
  update data of the table: "sequent_backend.ballot_style"
  """
  update_sequent_backend_ballot_style(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ballot_style_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: ballot_style_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: ballot_style_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: ballot_style_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ballot_style_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: ballot_style_set_input
    """filter the rows which have to be updated"""
    where: ballot_style_bool_exp!
  ): ballot_style_mutation_response
  """
  update single row of the table: "sequent_backend.ballot_style"
  """
  update_sequent_backend_ballot_style_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ballot_style_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: ballot_style_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: ballot_style_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: ballot_style_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ballot_style_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: ballot_style_set_input
    pk_columns: ballot_style_pk_columns_input!
  ): ballot_style
  """
  update multiples rows of table: "sequent_backend.ballot_style"
  """
  update_sequent_backend_ballot_style_many(
    """updates to execute, in order"""
    updates: [ballot_style_updates!]!
  ): [ballot_style_mutation_response]
  """
  update data of the table: "sequent_backend.candidate"
  """
  update_sequent_backend_candidate(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: candidate_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: candidate_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: candidate_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: candidate_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: candidate_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: candidate_set_input
    """filter the rows which have to be updated"""
    where: candidate_bool_exp!
  ): candidate_mutation_response
  """
  update single row of the table: "sequent_backend.candidate"
  """
  update_sequent_backend_candidate_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: candidate_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: candidate_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: candidate_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: candidate_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: candidate_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: candidate_set_input
    pk_columns: candidate_pk_columns_input!
  ): candidate
  """
  update multiples rows of table: "sequent_backend.candidate"
  """
  update_sequent_backend_candidate_many(
    """updates to execute, in order"""
    updates: [candidate_updates!]!
  ): [candidate_mutation_response]
  """
  update data of the table: "sequent_backend.cast_vote"
  """
  update_sequent_backend_cast_vote(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: cast_vote_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: cast_vote_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: cast_vote_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: cast_vote_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: cast_vote_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: cast_vote_set_input
    """filter the rows which have to be updated"""
    where: cast_vote_bool_exp!
  ): cast_vote_mutation_response
  """
  update single row of the table: "sequent_backend.cast_vote"
  """
  update_sequent_backend_cast_vote_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: cast_vote_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: cast_vote_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: cast_vote_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: cast_vote_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: cast_vote_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: cast_vote_set_input
    pk_columns: cast_vote_pk_columns_input!
  ): cast_vote
  """
  update multiples rows of table: "sequent_backend.cast_vote"
  """
  update_sequent_backend_cast_vote_many(
    """updates to execute, in order"""
    updates: [cast_vote_updates!]!
  ): [cast_vote_mutation_response]
  """
  update data of the table: "sequent_backend.contest"
  """
  update_sequent_backend_contest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: contest_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: contest_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: contest_set_input
    """filter the rows which have to be updated"""
    where: contest_bool_exp!
  ): contest_mutation_response
  """
  update single row of the table: "sequent_backend.contest"
  """
  update_sequent_backend_contest_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: contest_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: contest_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: contest_set_input
    pk_columns: contest_pk_columns_input!
  ): contest
  """
  update multiples rows of table: "sequent_backend.contest"
  """
  update_sequent_backend_contest_many(
    """updates to execute, in order"""
    updates: [contest_updates!]!
  ): [contest_mutation_response]
  """
  update data of the table: "sequent_backend.document"
  """
  update_sequent_backend_document(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: document_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: document_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: document_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: document_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: document_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: document_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: document_set_input
    """filter the rows which have to be updated"""
    where: document_bool_exp!
  ): document_mutation_response
  """
  update single row of the table: "sequent_backend.document"
  """
  update_sequent_backend_document_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: document_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: document_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: document_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: document_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: document_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: document_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: document_set_input
    pk_columns: document_pk_columns_input!
  ): document
  """
  update multiples rows of table: "sequent_backend.document"
  """
  update_sequent_backend_document_many(
    """updates to execute, in order"""
    updates: [document_updates!]!
  ): [document_mutation_response]
  """
  update data of the table: "sequent_backend.election"
  """
  update_sequent_backend_election(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: election_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: election_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: election_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: election_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: election_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: election_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: election_set_input
    """filter the rows which have to be updated"""
    where: election_bool_exp!
  ): election_mutation_response
  """
  update single row of the table: "sequent_backend.election"
  """
  update_sequent_backend_election_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: election_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: election_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: election_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: election_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: election_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: election_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: election_set_input
    pk_columns: election_pk_columns_input!
  ): election
  """
  update data of the table: "sequent_backend.election_event"
  """
  update_sequent_backend_election_event(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: election_event_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: election_event_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: election_event_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: election_event_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: election_event_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: election_event_set_input
    """filter the rows which have to be updated"""
    where: election_event_bool_exp!
  ): election_event_mutation_response
  """
  update single row of the table: "sequent_backend.election_event"
  """
  update_sequent_backend_election_event_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: election_event_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: election_event_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: election_event_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: election_event_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: election_event_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: election_event_set_input
    pk_columns: election_event_pk_columns_input!
  ): election_event
  """
  update multiples rows of table: "sequent_backend.election_event"
  """
  update_sequent_backend_election_event_many(
    """updates to execute, in order"""
    updates: [election_event_updates!]!
  ): [election_event_mutation_response]
  """
  update multiples rows of table: "sequent_backend.election"
  """
  update_sequent_backend_election_many(
    """updates to execute, in order"""
    updates: [election_updates!]!
  ): [election_mutation_response]
  """
  update data of the table: "sequent_backend.election_result"
  """
  update_sequent_backend_election_result(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: election_result_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: election_result_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: election_result_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: election_result_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: election_result_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: election_result_set_input
    """filter the rows which have to be updated"""
    where: election_result_bool_exp!
  ): election_result_mutation_response
  """
  update single row of the table: "sequent_backend.election_result"
  """
  update_sequent_backend_election_result_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: election_result_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: election_result_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: election_result_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: election_result_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: election_result_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: election_result_set_input
    pk_columns: election_result_pk_columns_input!
  ): election_result
  """
  update multiples rows of table: "sequent_backend.election_result"
  """
  update_sequent_backend_election_result_many(
    """updates to execute, in order"""
    updates: [election_result_updates!]!
  ): [election_result_mutation_response]
  """
  update data of the table: "sequent_backend.election_type"
  """
  update_sequent_backend_election_type(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: election_type_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: election_type_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: election_type_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: election_type_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: election_type_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: election_type_set_input
    """filter the rows which have to be updated"""
    where: election_type_bool_exp!
  ): election_type_mutation_response
  """
  update single row of the table: "sequent_backend.election_type"
  """
  update_sequent_backend_election_type_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: election_type_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: election_type_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: election_type_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: election_type_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: election_type_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: election_type_set_input
    pk_columns: election_type_pk_columns_input!
  ): election_type
  """
  update multiples rows of table: "sequent_backend.election_type"
  """
  update_sequent_backend_election_type_many(
    """updates to execute, in order"""
    updates: [election_type_updates!]!
  ): [election_type_mutation_response]
  """
  update data of the table: "sequent_backend.event_execution"
  """
  update_sequent_backend_event_execution(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: event_execution_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: event_execution_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: event_execution_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: event_execution_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: event_execution_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: event_execution_set_input
    """filter the rows which have to be updated"""
    where: event_execution_bool_exp!
  ): event_execution_mutation_response
  """
  update single row of the table: "sequent_backend.event_execution"
  """
  update_sequent_backend_event_execution_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: event_execution_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: event_execution_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: event_execution_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: event_execution_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: event_execution_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: event_execution_set_input
    pk_columns: event_execution_pk_columns_input!
  ): event_execution
  """
  update multiples rows of table: "sequent_backend.event_execution"
  """
  update_sequent_backend_event_execution_many(
    """updates to execute, in order"""
    updates: [event_execution_updates!]!
  ): [event_execution_mutation_response]
  """
  update data of the table: "sequent_backend.keys_ceremony"
  """
  update_sequent_backend_keys_ceremony(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: keys_ceremony_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: keys_ceremony_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: keys_ceremony_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: keys_ceremony_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: keys_ceremony_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: keys_ceremony_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: keys_ceremony_set_input
    """filter the rows which have to be updated"""
    where: keys_ceremony_bool_exp!
  ): keys_ceremony_mutation_response
  """
  update single row of the table: "sequent_backend.keys_ceremony"
  """
  update_sequent_backend_keys_ceremony_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: keys_ceremony_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: keys_ceremony_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: keys_ceremony_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: keys_ceremony_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: keys_ceremony_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: keys_ceremony_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: keys_ceremony_set_input
    pk_columns: keys_ceremony_pk_columns_input!
  ): keys_ceremony
  """
  update multiples rows of table: "sequent_backend.keys_ceremony"
  """
  update_sequent_backend_keys_ceremony_many(
    """updates to execute, in order"""
    updates: [keys_ceremony_updates!]!
  ): [keys_ceremony_mutation_response]
  """
  update data of the table: "sequent_backend.lock"
  """
  update_sequent_backend_lock(
    """sets the columns of the filtered rows to the given values"""
    _set: lock_set_input
    """filter the rows which have to be updated"""
    where: lock_bool_exp!
  ): lock_mutation_response
  """
  update single row of the table: "sequent_backend.lock"
  """
  update_sequent_backend_lock_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: lock_set_input
    pk_columns: lock_pk_columns_input!
  ): lock
  """
  update multiples rows of table: "sequent_backend.lock"
  """
  update_sequent_backend_lock_many(
    """updates to execute, in order"""
    updates: [lock_updates!]!
  ): [lock_mutation_response]
  """
  update data of the table: "sequent_backend.notification"
  """
  update_sequent_backend_notification(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notification_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notification_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notification_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notification_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notification_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input
    """filter the rows which have to be updated"""
    where: notification_bool_exp!
  ): notification_mutation_response
  """
  update single row of the table: "sequent_backend.notification"
  """
  update_sequent_backend_notification_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notification_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notification_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notification_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notification_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notification_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification
  """
  update multiples rows of table: "sequent_backend.notification"
  """
  update_sequent_backend_notification_many(
    """updates to execute, in order"""
    updates: [notification_updates!]!
  ): [notification_mutation_response]
  """
  update data of the table: "sequent_backend.report"
  """
  update_sequent_backend_report(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: report_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: report_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: report_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: report_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: report_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: report_set_input
    """filter the rows which have to be updated"""
    where: report_bool_exp!
  ): report_mutation_response
  """
  update single row of the table: "sequent_backend.report"
  """
  update_sequent_backend_report_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: report_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: report_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: report_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: report_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: report_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: report_set_input
    pk_columns: report_pk_columns_input!
  ): report
  """
  update multiples rows of table: "sequent_backend.report"
  """
  update_sequent_backend_report_many(
    """updates to execute, in order"""
    updates: [report_updates!]!
  ): [report_mutation_response]
  """
  update data of the table: "sequent_backend.results_area_contest"
  """
  update_sequent_backend_results_area_contest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_area_contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_area_contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_area_contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_area_contest_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_area_contest_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_area_contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_area_contest_set_input
    """filter the rows which have to be updated"""
    where: results_area_contest_bool_exp!
  ): results_area_contest_mutation_response
  """
  update single row of the table: "sequent_backend.results_area_contest"
  """
  update_sequent_backend_results_area_contest_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_area_contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_area_contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_area_contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_area_contest_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_area_contest_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_area_contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_area_contest_set_input
    pk_columns: results_area_contest_pk_columns_input!
  ): results_area_contest
  """
  update data of the table: "sequent_backend.results_area_contest_candidate"
  """
  update_sequent_backend_results_area_contest_candidate(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_area_contest_candidate_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_area_contest_candidate_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_area_contest_candidate_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_area_contest_candidate_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_area_contest_candidate_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_area_contest_candidate_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_area_contest_candidate_set_input
    """filter the rows which have to be updated"""
    where: results_area_contest_candidate_bool_exp!
  ): results_area_contest_candidate_mutation_response
  """
  update single row of the table: "sequent_backend.results_area_contest_candidate"
  """
  update_sequent_backend_results_area_contest_candidate_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_area_contest_candidate_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_area_contest_candidate_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_area_contest_candidate_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_area_contest_candidate_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_area_contest_candidate_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_area_contest_candidate_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_area_contest_candidate_set_input
    pk_columns: results_area_contest_candidate_pk_columns_input!
  ): results_area_contest_candidate
  """
  update multiples rows of table: "sequent_backend.results_area_contest_candidate"
  """
  update_sequent_backend_results_area_contest_candidate_many(
    """updates to execute, in order"""
    updates: [results_area_contest_candidate_updates!]!
  ): [results_area_contest_candidate_mutation_response]
  """
  update multiples rows of table: "sequent_backend.results_area_contest"
  """
  update_sequent_backend_results_area_contest_many(
    """updates to execute, in order"""
    updates: [results_area_contest_updates!]!
  ): [results_area_contest_mutation_response]
  """
  update data of the table: "sequent_backend.results_contest"
  """
  update_sequent_backend_results_contest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_contest_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_contest_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_contest_set_input
    """filter the rows which have to be updated"""
    where: results_contest_bool_exp!
  ): results_contest_mutation_response
  """
  update single row of the table: "sequent_backend.results_contest"
  """
  update_sequent_backend_results_contest_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_contest_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_contest_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_contest_set_input
    pk_columns: results_contest_pk_columns_input!
  ): results_contest
  """
  update data of the table: "sequent_backend.results_contest_candidate"
  """
  update_sequent_backend_results_contest_candidate(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_contest_candidate_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_contest_candidate_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_contest_candidate_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_contest_candidate_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_contest_candidate_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_contest_candidate_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_contest_candidate_set_input
    """filter the rows which have to be updated"""
    where: results_contest_candidate_bool_exp!
  ): results_contest_candidate_mutation_response
  """
  update single row of the table: "sequent_backend.results_contest_candidate"
  """
  update_sequent_backend_results_contest_candidate_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_contest_candidate_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_contest_candidate_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_contest_candidate_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_contest_candidate_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_contest_candidate_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_contest_candidate_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_contest_candidate_set_input
    pk_columns: results_contest_candidate_pk_columns_input!
  ): results_contest_candidate
  """
  update multiples rows of table: "sequent_backend.results_contest_candidate"
  """
  update_sequent_backend_results_contest_candidate_many(
    """updates to execute, in order"""
    updates: [results_contest_candidate_updates!]!
  ): [results_contest_candidate_mutation_response]
  """
  update multiples rows of table: "sequent_backend.results_contest"
  """
  update_sequent_backend_results_contest_many(
    """updates to execute, in order"""
    updates: [results_contest_updates!]!
  ): [results_contest_mutation_response]
  """
  update data of the table: "sequent_backend.results_election"
  """
  update_sequent_backend_results_election(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_election_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_election_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_election_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_election_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_election_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_election_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_election_set_input
    """filter the rows which have to be updated"""
    where: results_election_bool_exp!
  ): results_election_mutation_response
  """
  update data of the table: "sequent_backend.results_election_area"
  """
  update_sequent_backend_results_election_area(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_election_area_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_election_area_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_election_area_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_election_area_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_election_area_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_election_area_set_input
    """filter the rows which have to be updated"""
    where: results_election_area_bool_exp!
  ): results_election_area_mutation_response
  """
  update single row of the table: "sequent_backend.results_election_area"
  """
  update_sequent_backend_results_election_area_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_election_area_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_election_area_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_election_area_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_election_area_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_election_area_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_election_area_set_input
    pk_columns: results_election_area_pk_columns_input!
  ): results_election_area
  """
  update multiples rows of table: "sequent_backend.results_election_area"
  """
  update_sequent_backend_results_election_area_many(
    """updates to execute, in order"""
    updates: [results_election_area_updates!]!
  ): [results_election_area_mutation_response]
  """
  update single row of the table: "sequent_backend.results_election"
  """
  update_sequent_backend_results_election_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_election_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_election_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_election_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_election_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: results_election_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_election_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_election_set_input
    pk_columns: results_election_pk_columns_input!
  ): results_election
  """
  update multiples rows of table: "sequent_backend.results_election"
  """
  update_sequent_backend_results_election_many(
    """updates to execute, in order"""
    updates: [results_election_updates!]!
  ): [results_election_mutation_response]
  """
  update data of the table: "sequent_backend.results_event"
  """
  update_sequent_backend_results_event(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_event_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_event_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_event_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_event_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_event_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_event_set_input
    """filter the rows which have to be updated"""
    where: results_event_bool_exp!
  ): results_event_mutation_response
  """
  update single row of the table: "sequent_backend.results_event"
  """
  update_sequent_backend_results_event_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: results_event_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: results_event_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: results_event_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: results_event_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: results_event_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: results_event_set_input
    pk_columns: results_event_pk_columns_input!
  ): results_event
  """
  update multiples rows of table: "sequent_backend.results_event"
  """
  update_sequent_backend_results_event_many(
    """updates to execute, in order"""
    updates: [results_event_updates!]!
  ): [results_event_mutation_response]
  """
  update data of the table: "sequent_backend.scheduled_event"
  """
  update_sequent_backend_scheduled_event(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: scheduled_event_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: scheduled_event_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: scheduled_event_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: scheduled_event_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: scheduled_event_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: scheduled_event_set_input
    """filter the rows which have to be updated"""
    where: scheduled_event_bool_exp!
  ): scheduled_event_mutation_response
  """
  update single row of the table: "sequent_backend.scheduled_event"
  """
  update_sequent_backend_scheduled_event_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: scheduled_event_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: scheduled_event_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: scheduled_event_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: scheduled_event_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: scheduled_event_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: scheduled_event_set_input
    pk_columns: scheduled_event_pk_columns_input!
  ): scheduled_event
  """
  update multiples rows of table: "sequent_backend.scheduled_event"
  """
  update_sequent_backend_scheduled_event_many(
    """updates to execute, in order"""
    updates: [scheduled_event_updates!]!
  ): [scheduled_event_mutation_response]
  """
  update data of the table: "sequent_backend.secret"
  """
  update_sequent_backend_secret(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: secret_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: secret_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: secret_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: secret_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: secret_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: secret_set_input
    """filter the rows which have to be updated"""
    where: secret_bool_exp!
  ): secret_mutation_response
  """
  update single row of the table: "sequent_backend.secret"
  """
  update_sequent_backend_secret_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: secret_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: secret_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: secret_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: secret_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: secret_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: secret_set_input
    pk_columns: secret_pk_columns_input!
  ): secret
  """
  update multiples rows of table: "sequent_backend.secret"
  """
  update_sequent_backend_secret_many(
    """updates to execute, in order"""
    updates: [secret_updates!]!
  ): [secret_mutation_response]
  """
  update data of the table: "sequent_backend.support_material"
  """
  update_sequent_backend_support_material(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_material_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_material_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_material_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_material_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_material_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: support_material_set_input
    """filter the rows which have to be updated"""
    where: support_material_bool_exp!
  ): support_material_mutation_response
  """
  update single row of the table: "sequent_backend.support_material"
  """
  update_sequent_backend_support_material_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: support_material_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: support_material_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: support_material_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: support_material_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: support_material_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: support_material_set_input
    pk_columns: support_material_pk_columns_input!
  ): support_material
  """
  update multiples rows of table: "sequent_backend.support_material"
  """
  update_sequent_backend_support_material_many(
    """updates to execute, in order"""
    updates: [support_material_updates!]!
  ): [support_material_mutation_response]
  """
  update data of the table: "sequent_backend.tally_session"
  """
  update_sequent_backend_tally_session(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tally_session_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tally_session_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tally_session_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tally_session_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: tally_session_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tally_session_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tally_session_set_input
    """filter the rows which have to be updated"""
    where: tally_session_bool_exp!
  ): tally_session_mutation_response
  """
  update single row of the table: "sequent_backend.tally_session"
  """
  update_sequent_backend_tally_session_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tally_session_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tally_session_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tally_session_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tally_session_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: tally_session_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tally_session_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tally_session_set_input
    pk_columns: tally_session_pk_columns_input!
  ): tally_session
  """
  update data of the table: "sequent_backend.tally_session_contest"
  """
  update_sequent_backend_tally_session_contest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tally_session_contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tally_session_contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tally_session_contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tally_session_contest_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: tally_session_contest_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tally_session_contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tally_session_contest_set_input
    """filter the rows which have to be updated"""
    where: tally_session_contest_bool_exp!
  ): tally_session_contest_mutation_response
  """
  update single row of the table: "sequent_backend.tally_session_contest"
  """
  update_sequent_backend_tally_session_contest_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tally_session_contest_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tally_session_contest_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tally_session_contest_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tally_session_contest_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: tally_session_contest_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tally_session_contest_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tally_session_contest_set_input
    pk_columns: tally_session_contest_pk_columns_input!
  ): tally_session_contest
  """
  update multiples rows of table: "sequent_backend.tally_session_contest"
  """
  update_sequent_backend_tally_session_contest_many(
    """updates to execute, in order"""
    updates: [tally_session_contest_updates!]!
  ): [tally_session_contest_mutation_response]
  """
  update data of the table: "sequent_backend.tally_session_execution"
  """
  update_sequent_backend_tally_session_execution(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tally_session_execution_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tally_session_execution_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tally_session_execution_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tally_session_execution_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: tally_session_execution_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tally_session_execution_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tally_session_execution_set_input
    """filter the rows which have to be updated"""
    where: tally_session_execution_bool_exp!
  ): tally_session_execution_mutation_response
  """
  update single row of the table: "sequent_backend.tally_session_execution"
  """
  update_sequent_backend_tally_session_execution_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tally_session_execution_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tally_session_execution_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tally_session_execution_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tally_session_execution_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: tally_session_execution_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tally_session_execution_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tally_session_execution_set_input
    pk_columns: tally_session_execution_pk_columns_input!
  ): tally_session_execution
  """
  update multiples rows of table: "sequent_backend.tally_session_execution"
  """
  update_sequent_backend_tally_session_execution_many(
    """updates to execute, in order"""
    updates: [tally_session_execution_updates!]!
  ): [tally_session_execution_mutation_response]
  """
  update multiples rows of table: "sequent_backend.tally_session"
  """
  update_sequent_backend_tally_session_many(
    """updates to execute, in order"""
    updates: [tally_session_updates!]!
  ): [tally_session_mutation_response]
  """
  update data of the table: "sequent_backend.tally_sheet"
  """
  update_sequent_backend_tally_sheet(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tally_sheet_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tally_sheet_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tally_sheet_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tally_sheet_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tally_sheet_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tally_sheet_set_input
    """filter the rows which have to be updated"""
    where: tally_sheet_bool_exp!
  ): tally_sheet_mutation_response
  """
  update single row of the table: "sequent_backend.tally_sheet"
  """
  update_sequent_backend_tally_sheet_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tally_sheet_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tally_sheet_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tally_sheet_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tally_sheet_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tally_sheet_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tally_sheet_set_input
    pk_columns: tally_sheet_pk_columns_input!
  ): tally_sheet
  """
  update multiples rows of table: "sequent_backend.tally_sheet"
  """
  update_sequent_backend_tally_sheet_many(
    """updates to execute, in order"""
    updates: [tally_sheet_updates!]!
  ): [tally_sheet_mutation_response]
  """
  update data of the table: "sequent_backend.tasks_execution"
  """
  update_sequent_backend_tasks_execution(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tasks_execution_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tasks_execution_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tasks_execution_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tasks_execution_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tasks_execution_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tasks_execution_set_input
    """filter the rows which have to be updated"""
    where: tasks_execution_bool_exp!
  ): tasks_execution_mutation_response
  """
  update single row of the table: "sequent_backend.tasks_execution"
  """
  update_sequent_backend_tasks_execution_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tasks_execution_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tasks_execution_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tasks_execution_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tasks_execution_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tasks_execution_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tasks_execution_set_input
    pk_columns: tasks_execution_pk_columns_input!
  ): tasks_execution
  """
  update multiples rows of table: "sequent_backend.tasks_execution"
  """
  update_sequent_backend_tasks_execution_many(
    """updates to execute, in order"""
    updates: [tasks_execution_updates!]!
  ): [tasks_execution_mutation_response]
  """
  update data of the table: "sequent_backend.template"
  """
  update_sequent_backend_template(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: template_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: template_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: template_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: template_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: template_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: template_set_input
    """filter the rows which have to be updated"""
    where: template_bool_exp!
  ): template_mutation_response
  """
  update single row of the table: "sequent_backend.template"
  """
  update_sequent_backend_template_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: template_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: template_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: template_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: template_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: template_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: template_set_input
    pk_columns: template_pk_columns_input!
  ): template
  """
  update multiples rows of table: "sequent_backend.template"
  """
  update_sequent_backend_template_many(
    """updates to execute, in order"""
    updates: [template_updates!]!
  ): [template_mutation_response]
  """
  update data of the table: "sequent_backend.tenant"
  """
  update_sequent_backend_tenant(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tenant_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tenant_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tenant_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tenant_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tenant_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tenant_set_input
    """filter the rows which have to be updated"""
    where: tenant_bool_exp!
  ): tenant_mutation_response
  """
  update single row of the table: "sequent_backend.tenant"
  """
  update_sequent_backend_tenant_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tenant_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tenant_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: tenant_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tenant_delete_key_input
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_inc_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tenant_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: tenant_set_input
    pk_columns: tenant_pk_columns_input!
  ): tenant
  """
  update multiples rows of table: "sequent_backend.tenant"
  """
  update_sequent_backend_tenant_many(
    """updates to execute, in order"""
    updates: [tenant_updates!]!
  ): [tenant_mutation_response]
  """
  update data of the table: "sequent_backend.trustee"
  """
  update_sequent_backend_trustee(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: trustee_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: trustee_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: trustee_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: trustee_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: trustee_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: trustee_set_input
    """filter the rows which have to be updated"""
    where: trustee_bool_exp!
  ): trustee_mutation_response
  """
  update single row of the table: "sequent_backend.trustee"
  """
  update_sequent_backend_trustee_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: trustee_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: trustee_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: trustee_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: trustee_delete_key_input
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: trustee_prepend_input
    """sets the columns of the filtered rows to the given values"""
    _set: trustee_set_input
    pk_columns: trustee_pk_columns_input!
  ): trustee
  """
  update multiples rows of table: "sequent_backend.trustee"
  """
  update_sequent_backend_trustee_many(
    """updates to execute, in order"""
    updates: [trustee_updates!]!
  ): [trustee_mutation_response]
  update_tally_ceremony(election_event_id: uuid!, status: String!, tally_session_id: uuid!): StartTallyOutput
  upload_signature(area_id: uuid!, document_id: uuid!, election_id: uuid!, password: String!, tally_session_id: uuid!): OptionalId
  upsert_area(annotations: jsonb, area_contest_ids: [String], description: String, election_event_id: String!, id: String, labels: jsonb, name: String!, parent_id: String, tenant_id: String!, type: String): UpsertAreaOutput
  """upsert_areas"""
  upsert_areas(document_id: String!, election_event_id: String!): OptionalId
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc
  """in ascending order, nulls first"""
  asc_nulls_first
  """in ascending order, nulls last"""
  asc_nulls_last
  """in descending order, nulls first"""
  desc
  """in descending order, nulls first"""
  desc_nulls_first
  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  count_users(body: CountUsersInput!): CountUsersOutput!
  """fetch document"""
  fetchDocument(document_id: String!, election_event_id: String): FetchDocumentOutput
  """get election event stats"""
  getElectionEventStats(object: ElectionEventStatsInput!): ElectionEventStatsOutput
  """get election event stats"""
  getElectionStats(object: ElectionStatsInput!): ElectionStatsOutput
  get_election_event_monitoring(election_event_id: uuid!): ElectionEventStatsMonitoringOutput
  get_election_monitoring(election_event_id: uuid!, election_id: uuid!): ElectionStatsMonitoringOutput
  """list permissions"""
  get_permissions(body: GetPermissionsInput!): GetPermissionsOutput!
  get_roles(body: GetRolesInput!): GetRolesOutput!
  get_top_votes_by_ip(body: GetTopCastVotesByIpInput!): GetTopCastVotesByIpOutput
  get_user_profile_attributes(election_event_id: String, tenant_id: String!): [UserProfileAttribute!]!
  get_users(body: GetUsersInput!): GetUsersOutput!
  """List Electoral Log"""
  listElectoralLog(election_event_id: String, filter: ElectoralLogFilter, limit: Int, offset: Int, order_by: ElectoralLogOrderBy): DataListElectoralLog
  """List PostgreSQL audit logs"""
  listPgaudit(audit_table: PgAuditTable, filter: PgAuditFilter, limit: Int, offset: Int, order_by: PgAuditOrderBy): DataListPgAudit
  """List electoral log entries of statement_kind CastVote"""
  list_cast_vote_messages(ballot_id: String!, election_event_id: String!, election_id: String, limit: Int, offset: Int, order_by: ElectoralLogOrderBy, tenant_id: String!): ListCastVoteMessagesOutput
  list_keys_ceremony(election_event_id: String!): ListKeysCeremonyOutput
  list_user_roles(election_event_id: String, tenant_id: String!, user_id: String!): [KeycloakRole!]!
  """log an event in immudb"""
  logEvent(body: String!, election_event_id: String!, message_type: String!, user_id: String): LogEventOutput
  """
  fetch data from the table: "sequent_backend.applications"
  """
  sequent_backend_applications(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]
    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!
  """
  fetch aggregated fields from the table: "sequent_backend.applications"
  """
  sequent_backend_applications_aggregate(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]
    """filter the rows returned"""
    where: applications_bool_exp
  ): applications_aggregate!
  """
  fetch data from the table: "sequent_backend.applications" using primary key columns
  """
  sequent_backend_applications_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): applications
  """
  fetch data from the table: "sequent_backend.area"
  """
  sequent_backend_area(
    """distinct select on columns"""
    distinct_on: [area_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [area_order_by!]
    """filter the rows returned"""
    where: area_bool_exp
  ): [area!]!
  """
  fetch aggregated fields from the table: "sequent_backend.area"
  """
  sequent_backend_area_aggregate(
    """distinct select on columns"""
    distinct_on: [area_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [area_order_by!]
    """filter the rows returned"""
    where: area_bool_exp
  ): area_aggregate!
  """
  fetch data from the table: "sequent_backend.area" using primary key columns
  """
  sequent_backend_area_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): area
  """
  fetch data from the table: "sequent_backend.area_contest"
  """
  sequent_backend_area_contest(
    """distinct select on columns"""
    distinct_on: [area_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [area_contest_order_by!]
    """filter the rows returned"""
    where: area_contest_bool_exp
  ): [area_contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.area_contest"
  """
  sequent_backend_area_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [area_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [area_contest_order_by!]
    """filter the rows returned"""
    where: area_contest_bool_exp
  ): area_contest_aggregate!
  """
  fetch data from the table: "sequent_backend.area_contest" using primary key columns
  """
  sequent_backend_area_contest_by_pk(id: uuid!): area_contest
  """
  fetch data from the table: "sequent_backend.ballot_publication"
  """
  sequent_backend_ballot_publication(
    """distinct select on columns"""
    distinct_on: [ballot_publication_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [ballot_publication_order_by!]
    """filter the rows returned"""
    where: ballot_publication_bool_exp
  ): [ballot_publication!]!
  """
  fetch aggregated fields from the table: "sequent_backend.ballot_publication"
  """
  sequent_backend_ballot_publication_aggregate(
    """distinct select on columns"""
    distinct_on: [ballot_publication_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [ballot_publication_order_by!]
    """filter the rows returned"""
    where: ballot_publication_bool_exp
  ): ballot_publication_aggregate!
  """
  fetch data from the table: "sequent_backend.ballot_publication" using primary key columns
  """
  sequent_backend_ballot_publication_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): ballot_publication
  """
  fetch data from the table: "sequent_backend.ballot_style"
  """
  sequent_backend_ballot_style(
    """distinct select on columns"""
    distinct_on: [ballot_style_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [ballot_style_order_by!]
    """filter the rows returned"""
    where: ballot_style_bool_exp
  ): [ballot_style!]!
  """
  fetch aggregated fields from the table: "sequent_backend.ballot_style"
  """
  sequent_backend_ballot_style_aggregate(
    """distinct select on columns"""
    distinct_on: [ballot_style_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [ballot_style_order_by!]
    """filter the rows returned"""
    where: ballot_style_bool_exp
  ): ballot_style_aggregate!
  """
  fetch data from the table: "sequent_backend.ballot_style" using primary key columns
  """
  sequent_backend_ballot_style_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): ballot_style
  """
  fetch data from the table: "sequent_backend.candidate"
  """
  sequent_backend_candidate(
    """distinct select on columns"""
    distinct_on: [candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [candidate_order_by!]
    """filter the rows returned"""
    where: candidate_bool_exp
  ): [candidate!]!
  """
  fetch aggregated fields from the table: "sequent_backend.candidate"
  """
  sequent_backend_candidate_aggregate(
    """distinct select on columns"""
    distinct_on: [candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [candidate_order_by!]
    """filter the rows returned"""
    where: candidate_bool_exp
  ): candidate_aggregate!
  """
  fetch data from the table: "sequent_backend.candidate" using primary key columns
  """
  sequent_backend_candidate_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): candidate
  """
  fetch data from the table: "sequent_backend.cast_vote"
  """
  sequent_backend_cast_vote(
    """distinct select on columns"""
    distinct_on: [cast_vote_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [cast_vote_order_by!]
    """filter the rows returned"""
    where: cast_vote_bool_exp
  ): [cast_vote!]!
  """
  fetch aggregated fields from the table: "sequent_backend.cast_vote"
  """
  sequent_backend_cast_vote_aggregate(
    """distinct select on columns"""
    distinct_on: [cast_vote_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [cast_vote_order_by!]
    """filter the rows returned"""
    where: cast_vote_bool_exp
  ): cast_vote_aggregate!
  """
  fetch data from the table: "sequent_backend.cast_vote" using primary key columns
  """
  sequent_backend_cast_vote_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): cast_vote
  """
  fetch data from the table: "sequent_backend.contest"
  """
  sequent_backend_contest(
    """distinct select on columns"""
    distinct_on: [contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [contest_order_by!]
    """filter the rows returned"""
    where: contest_bool_exp
  ): [contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.contest"
  """
  sequent_backend_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [contest_order_by!]
    """filter the rows returned"""
    where: contest_bool_exp
  ): contest_aggregate!
  """
  fetch data from the table: "sequent_backend.contest" using primary key columns
  """
  sequent_backend_contest_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): contest
  """
  fetch data from the table: "sequent_backend.document"
  """
  sequent_backend_document(
    """distinct select on columns"""
    distinct_on: [document_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [document_order_by!]
    """filter the rows returned"""
    where: document_bool_exp
  ): [document!]!
  """
  fetch aggregated fields from the table: "sequent_backend.document"
  """
  sequent_backend_document_aggregate(
    """distinct select on columns"""
    distinct_on: [document_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [document_order_by!]
    """filter the rows returned"""
    where: document_bool_exp
  ): document_aggregate!
  """
  fetch data from the table: "sequent_backend.document" using primary key columns
  """
  sequent_backend_document_by_pk(id: uuid!): document
  """
  fetch data from the table: "sequent_backend.election"
  """
  sequent_backend_election(
    """distinct select on columns"""
    distinct_on: [election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_order_by!]
    """filter the rows returned"""
    where: election_bool_exp
  ): [election!]!
  """
  fetch aggregated fields from the table: "sequent_backend.election"
  """
  sequent_backend_election_aggregate(
    """distinct select on columns"""
    distinct_on: [election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_order_by!]
    """filter the rows returned"""
    where: election_bool_exp
  ): election_aggregate!
  """
  fetch data from the table: "sequent_backend.election" using primary key columns
  """
  sequent_backend_election_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): election
  """
  fetch data from the table: "sequent_backend.election_event"
  """
  sequent_backend_election_event(
    """distinct select on columns"""
    distinct_on: [election_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_event_order_by!]
    """filter the rows returned"""
    where: election_event_bool_exp
  ): [election_event!]!
  """
  fetch aggregated fields from the table: "sequent_backend.election_event"
  """
  sequent_backend_election_event_aggregate(
    """distinct select on columns"""
    distinct_on: [election_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_event_order_by!]
    """filter the rows returned"""
    where: election_event_bool_exp
  ): election_event_aggregate!
  """
  fetch data from the table: "sequent_backend.election_event" using primary key columns
  """
  sequent_backend_election_event_by_pk(id: uuid!): election_event
  """
  fetch data from the table: "sequent_backend.election_result"
  """
  sequent_backend_election_result(
    """distinct select on columns"""
    distinct_on: [election_result_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_result_order_by!]
    """filter the rows returned"""
    where: election_result_bool_exp
  ): [election_result!]!
  """
  fetch aggregated fields from the table: "sequent_backend.election_result"
  """
  sequent_backend_election_result_aggregate(
    """distinct select on columns"""
    distinct_on: [election_result_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_result_order_by!]
    """filter the rows returned"""
    where: election_result_bool_exp
  ): election_result_aggregate!
  """
  fetch data from the table: "sequent_backend.election_result" using primary key columns
  """
  sequent_backend_election_result_by_pk(id: uuid!): election_result
  """
  fetch data from the table: "sequent_backend.election_type"
  """
  sequent_backend_election_type(
    """distinct select on columns"""
    distinct_on: [election_type_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_type_order_by!]
    """filter the rows returned"""
    where: election_type_bool_exp
  ): [election_type!]!
  """
  fetch aggregated fields from the table: "sequent_backend.election_type"
  """
  sequent_backend_election_type_aggregate(
    """distinct select on columns"""
    distinct_on: [election_type_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_type_order_by!]
    """filter the rows returned"""
    where: election_type_bool_exp
  ): election_type_aggregate!
  """
  fetch data from the table: "sequent_backend.election_type" using primary key columns
  """
  sequent_backend_election_type_by_pk(id: uuid!, tenant_id: uuid!): election_type
  """
  fetch data from the table: "sequent_backend.event_execution"
  """
  sequent_backend_event_execution(
    """distinct select on columns"""
    distinct_on: [event_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [event_execution_order_by!]
    """filter the rows returned"""
    where: event_execution_bool_exp
  ): [event_execution!]!
  """
  fetch aggregated fields from the table: "sequent_backend.event_execution"
  """
  sequent_backend_event_execution_aggregate(
    """distinct select on columns"""
    distinct_on: [event_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [event_execution_order_by!]
    """filter the rows returned"""
    where: event_execution_bool_exp
  ): event_execution_aggregate!
  """
  fetch data from the table: "sequent_backend.event_execution" using primary key columns
  """
  sequent_backend_event_execution_by_pk(id: uuid!): event_execution
  """
  fetch data from the table: "sequent_backend.keys_ceremony"
  """
  sequent_backend_keys_ceremony(
    """distinct select on columns"""
    distinct_on: [keys_ceremony_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [keys_ceremony_order_by!]
    """filter the rows returned"""
    where: keys_ceremony_bool_exp
  ): [keys_ceremony!]!
  """
  fetch aggregated fields from the table: "sequent_backend.keys_ceremony"
  """
  sequent_backend_keys_ceremony_aggregate(
    """distinct select on columns"""
    distinct_on: [keys_ceremony_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [keys_ceremony_order_by!]
    """filter the rows returned"""
    where: keys_ceremony_bool_exp
  ): keys_ceremony_aggregate!
  """
  fetch data from the table: "sequent_backend.keys_ceremony" using primary key columns
  """
  sequent_backend_keys_ceremony_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): keys_ceremony
  """
  fetch data from the table: "sequent_backend.lock"
  """
  sequent_backend_lock(
    """distinct select on columns"""
    distinct_on: [lock_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [lock_order_by!]
    """filter the rows returned"""
    where: lock_bool_exp
  ): [lock!]!
  """
  fetch aggregated fields from the table: "sequent_backend.lock"
  """
  sequent_backend_lock_aggregate(
    """distinct select on columns"""
    distinct_on: [lock_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [lock_order_by!]
    """filter the rows returned"""
    where: lock_bool_exp
  ): lock_aggregate!
  """
  fetch data from the table: "sequent_backend.lock" using primary key columns
  """
  sequent_backend_lock_by_pk(key: String!): lock
  """
  fetch data from the table: "sequent_backend.notification"
  """
  sequent_backend_notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]
    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!
  """
  fetch aggregated fields from the table: "sequent_backend.notification"
  """
  sequent_backend_notification_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]
    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!
  """
  fetch data from the table: "sequent_backend.notification" using primary key columns
  """
  sequent_backend_notification_by_pk(id: uuid!): notification
  """
  fetch data from the table: "sequent_backend.report"
  """
  sequent_backend_report(
    """distinct select on columns"""
    distinct_on: [report_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [report_order_by!]
    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!
  """
  fetch aggregated fields from the table: "sequent_backend.report"
  """
  sequent_backend_report_aggregate(
    """distinct select on columns"""
    distinct_on: [report_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [report_order_by!]
    """filter the rows returned"""
    where: report_bool_exp
  ): report_aggregate!
  """
  fetch data from the table: "sequent_backend.report" using primary key columns
  """
  sequent_backend_report_by_pk(id: uuid!): report
  """
  fetch data from the table: "sequent_backend.results_area_contest"
  """
  sequent_backend_results_area_contest(
    """distinct select on columns"""
    distinct_on: [results_area_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_area_contest_order_by!]
    """filter the rows returned"""
    where: results_area_contest_bool_exp
  ): [results_area_contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_area_contest"
  """
  sequent_backend_results_area_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [results_area_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_area_contest_order_by!]
    """filter the rows returned"""
    where: results_area_contest_bool_exp
  ): results_area_contest_aggregate!
  """
  fetch data from the table: "sequent_backend.results_area_contest" using primary key columns
  """
  sequent_backend_results_area_contest_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_area_contest
  """
  fetch data from the table: "sequent_backend.results_area_contest_candidate"
  """
  sequent_backend_results_area_contest_candidate(
    """distinct select on columns"""
    distinct_on: [results_area_contest_candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_area_contest_candidate_order_by!]
    """filter the rows returned"""
    where: results_area_contest_candidate_bool_exp
  ): [results_area_contest_candidate!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_area_contest_candidate"
  """
  sequent_backend_results_area_contest_candidate_aggregate(
    """distinct select on columns"""
    distinct_on: [results_area_contest_candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_area_contest_candidate_order_by!]
    """filter the rows returned"""
    where: results_area_contest_candidate_bool_exp
  ): results_area_contest_candidate_aggregate!
  """
  fetch data from the table: "sequent_backend.results_area_contest_candidate" using primary key columns
  """
  sequent_backend_results_area_contest_candidate_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_area_contest_candidate
  """
  fetch data from the table: "sequent_backend.results_contest"
  """
  sequent_backend_results_contest(
    """distinct select on columns"""
    distinct_on: [results_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_contest_order_by!]
    """filter the rows returned"""
    where: results_contest_bool_exp
  ): [results_contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_contest"
  """
  sequent_backend_results_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [results_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_contest_order_by!]
    """filter the rows returned"""
    where: results_contest_bool_exp
  ): results_contest_aggregate!
  """
  fetch data from the table: "sequent_backend.results_contest" using primary key columns
  """
  sequent_backend_results_contest_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_contest
  """
  fetch data from the table: "sequent_backend.results_contest_candidate"
  """
  sequent_backend_results_contest_candidate(
    """distinct select on columns"""
    distinct_on: [results_contest_candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_contest_candidate_order_by!]
    """filter the rows returned"""
    where: results_contest_candidate_bool_exp
  ): [results_contest_candidate!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_contest_candidate"
  """
  sequent_backend_results_contest_candidate_aggregate(
    """distinct select on columns"""
    distinct_on: [results_contest_candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_contest_candidate_order_by!]
    """filter the rows returned"""
    where: results_contest_candidate_bool_exp
  ): results_contest_candidate_aggregate!
  """
  fetch data from the table: "sequent_backend.results_contest_candidate" using primary key columns
  """
  sequent_backend_results_contest_candidate_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_contest_candidate
  """
  fetch data from the table: "sequent_backend.results_election"
  """
  sequent_backend_results_election(
    """distinct select on columns"""
    distinct_on: [results_election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_election_order_by!]
    """filter the rows returned"""
    where: results_election_bool_exp
  ): [results_election!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_election"
  """
  sequent_backend_results_election_aggregate(
    """distinct select on columns"""
    distinct_on: [results_election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_election_order_by!]
    """filter the rows returned"""
    where: results_election_bool_exp
  ): results_election_aggregate!
  """
  fetch data from the table: "sequent_backend.results_election_area"
  """
  sequent_backend_results_election_area(
    """distinct select on columns"""
    distinct_on: [results_election_area_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_election_area_order_by!]
    """filter the rows returned"""
    where: results_election_area_bool_exp
  ): [results_election_area!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_election_area"
  """
  sequent_backend_results_election_area_aggregate(
    """distinct select on columns"""
    distinct_on: [results_election_area_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_election_area_order_by!]
    """filter the rows returned"""
    where: results_election_area_bool_exp
  ): results_election_area_aggregate!
  """
  fetch data from the table: "sequent_backend.results_election_area" using primary key columns
  """
  sequent_backend_results_election_area_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_election_area
  """
  fetch data from the table: "sequent_backend.results_election" using primary key columns
  """
  sequent_backend_results_election_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_election
  """
  fetch data from the table: "sequent_backend.results_event"
  """
  sequent_backend_results_event(
    """distinct select on columns"""
    distinct_on: [results_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_event_order_by!]
    """filter the rows returned"""
    where: results_event_bool_exp
  ): [results_event!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_event"
  """
  sequent_backend_results_event_aggregate(
    """distinct select on columns"""
    distinct_on: [results_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_event_order_by!]
    """filter the rows returned"""
    where: results_event_bool_exp
  ): results_event_aggregate!
  """
  fetch data from the table: "sequent_backend.results_event" using primary key columns
  """
  sequent_backend_results_event_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): results_event
  """
  fetch data from the table: "sequent_backend.scheduled_event"
  """
  sequent_backend_scheduled_event(
    """distinct select on columns"""
    distinct_on: [scheduled_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [scheduled_event_order_by!]
    """filter the rows returned"""
    where: scheduled_event_bool_exp
  ): [scheduled_event!]!
  """
  fetch aggregated fields from the table: "sequent_backend.scheduled_event"
  """
  sequent_backend_scheduled_event_aggregate(
    """distinct select on columns"""
    distinct_on: [scheduled_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [scheduled_event_order_by!]
    """filter the rows returned"""
    where: scheduled_event_bool_exp
  ): scheduled_event_aggregate!
  """
  fetch data from the table: "sequent_backend.scheduled_event" using primary key columns
  """
  sequent_backend_scheduled_event_by_pk(id: uuid!): scheduled_event
  """
  fetch data from the table: "sequent_backend.secret"
  """
  sequent_backend_secret(
    """distinct select on columns"""
    distinct_on: [secret_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [secret_order_by!]
    """filter the rows returned"""
    where: secret_bool_exp
  ): [secret!]!
  """
  fetch aggregated fields from the table: "sequent_backend.secret"
  """
  sequent_backend_secret_aggregate(
    """distinct select on columns"""
    distinct_on: [secret_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [secret_order_by!]
    """filter the rows returned"""
    where: secret_bool_exp
  ): secret_aggregate!
  """
  fetch data from the table: "sequent_backend.secret" using primary key columns
  """
  sequent_backend_secret_by_pk(id: uuid!, key: String!, tenant_id: uuid!): secret
  """
  fetch data from the table: "sequent_backend.support_material"
  """
  sequent_backend_support_material(
    """distinct select on columns"""
    distinct_on: [support_material_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [support_material_order_by!]
    """filter the rows returned"""
    where: support_material_bool_exp
  ): [support_material!]!
  """
  fetch aggregated fields from the table: "sequent_backend.support_material"
  """
  sequent_backend_support_material_aggregate(
    """distinct select on columns"""
    distinct_on: [support_material_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [support_material_order_by!]
    """filter the rows returned"""
    where: support_material_bool_exp
  ): support_material_aggregate!
  """
  fetch data from the table: "sequent_backend.support_material" using primary key columns
  """
  sequent_backend_support_material_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): support_material
  """
  fetch data from the table: "sequent_backend.tally_session"
  """
  sequent_backend_tally_session(
    """distinct select on columns"""
    distinct_on: [tally_session_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_order_by!]
    """filter the rows returned"""
    where: tally_session_bool_exp
  ): [tally_session!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tally_session"
  """
  sequent_backend_tally_session_aggregate(
    """distinct select on columns"""
    distinct_on: [tally_session_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_order_by!]
    """filter the rows returned"""
    where: tally_session_bool_exp
  ): tally_session_aggregate!
  """
  fetch data from the table: "sequent_backend.tally_session" using primary key columns
  """
  sequent_backend_tally_session_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session
  """
  fetch data from the table: "sequent_backend.tally_session_contest"
  """
  sequent_backend_tally_session_contest(
    """distinct select on columns"""
    distinct_on: [tally_session_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_contest_order_by!]
    """filter the rows returned"""
    where: tally_session_contest_bool_exp
  ): [tally_session_contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tally_session_contest"
  """
  sequent_backend_tally_session_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [tally_session_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_contest_order_by!]
    """filter the rows returned"""
    where: tally_session_contest_bool_exp
  ): tally_session_contest_aggregate!
  """
  fetch data from the table: "sequent_backend.tally_session_contest" using primary key columns
  """
  sequent_backend_tally_session_contest_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session_contest
  """
  fetch data from the table: "sequent_backend.tally_session_execution"
  """
  sequent_backend_tally_session_execution(
    """distinct select on columns"""
    distinct_on: [tally_session_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_execution_order_by!]
    """filter the rows returned"""
    where: tally_session_execution_bool_exp
  ): [tally_session_execution!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tally_session_execution"
  """
  sequent_backend_tally_session_execution_aggregate(
    """distinct select on columns"""
    distinct_on: [tally_session_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_execution_order_by!]
    """filter the rows returned"""
    where: tally_session_execution_bool_exp
  ): tally_session_execution_aggregate!
  """
  fetch data from the table: "sequent_backend.tally_session_execution" using primary key columns
  """
  sequent_backend_tally_session_execution_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session_execution
  """
  fetch data from the table: "sequent_backend.tally_sheet"
  """
  sequent_backend_tally_sheet(
    """distinct select on columns"""
    distinct_on: [tally_sheet_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_sheet_order_by!]
    """filter the rows returned"""
    where: tally_sheet_bool_exp
  ): [tally_sheet!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tally_sheet"
  """
  sequent_backend_tally_sheet_aggregate(
    """distinct select on columns"""
    distinct_on: [tally_sheet_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_sheet_order_by!]
    """filter the rows returned"""
    where: tally_sheet_bool_exp
  ): tally_sheet_aggregate!
  """
  fetch data from the table: "sequent_backend.tally_sheet" using primary key columns
  """
  sequent_backend_tally_sheet_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_sheet
  """
  fetch data from the table: "sequent_backend.tasks_execution"
  """
  sequent_backend_tasks_execution(
    """distinct select on columns"""
    distinct_on: [tasks_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tasks_execution_order_by!]
    """filter the rows returned"""
    where: tasks_execution_bool_exp
  ): [tasks_execution!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tasks_execution"
  """
  sequent_backend_tasks_execution_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tasks_execution_order_by!]
    """filter the rows returned"""
    where: tasks_execution_bool_exp
  ): tasks_execution_aggregate!
  """
  fetch data from the table: "sequent_backend.tasks_execution" using primary key columns
  """
  sequent_backend_tasks_execution_by_pk(id: uuid!, tenant_id: uuid!): tasks_execution
  """
  fetch data from the table: "sequent_backend.template"
  """
  sequent_backend_template(
    """distinct select on columns"""
    distinct_on: [template_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [template_order_by!]
    """filter the rows returned"""
    where: template_bool_exp
  ): [template!]!
  """
  fetch aggregated fields from the table: "sequent_backend.template"
  """
  sequent_backend_template_aggregate(
    """distinct select on columns"""
    distinct_on: [template_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [template_order_by!]
    """filter the rows returned"""
    where: template_bool_exp
  ): template_aggregate!
  """
  fetch data from the table: "sequent_backend.template" using primary key columns
  """
  sequent_backend_template_by_pk(id: uuid!, tenant_id: uuid!): template
  """
  fetch data from the table: "sequent_backend.tenant"
  """
  sequent_backend_tenant(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]
    """filter the rows returned"""
    where: tenant_bool_exp
  ): [tenant!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tenant"
  """
  sequent_backend_tenant_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]
    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenant_aggregate!
  """
  fetch data from the table: "sequent_backend.tenant" using primary key columns
  """
  sequent_backend_tenant_by_pk(id: uuid!): tenant
  """
  fetch data from the table: "sequent_backend.trustee"
  """
  sequent_backend_trustee(
    """distinct select on columns"""
    distinct_on: [trustee_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [trustee_order_by!]
    """filter the rows returned"""
    where: trustee_bool_exp
  ): [trustee!]!
  """
  fetch aggregated fields from the table: "sequent_backend.trustee"
  """
  sequent_backend_trustee_aggregate(
    """distinct select on columns"""
    distinct_on: [trustee_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [trustee_order_by!]
    """filter the rows returned"""
    where: trustee_bool_exp
  ): trustee_aggregate!
  """
  fetch data from the table: "sequent_backend.trustee" using primary key columns
  """
  sequent_backend_trustee_by_pk(id: uuid!): trustee
}

"""
columns and relationships of "sequent_backend.applications"
"""
type applications {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  applicant_data(
    """JSON select path"""
    path: String
  ): jsonb!
  applicant_id: String!
  area_id: uuid
  created_at: timestamptz!
  election_event_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  permission_label: String
  status: String!
  tenant_id: uuid!
  updated_at: timestamptz!
  verification_type: String!
}

"""
aggregated selection of "sequent_backend.applications"
"""
type applications_aggregate {
  aggregate: applications_aggregate_fields
  nodes: [applications!]!
}

"""
aggregate fields of "sequent_backend.applications"
"""
type applications_aggregate_fields {
  count(columns: [applications_select_column!], distinct: Boolean): Int!
  max: applications_max_fields
  min: applications_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input applications_append_input {
  annotations: jsonb
  applicant_data: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.applications". All fields are combined with a logical 'AND'.
"""
input applications_bool_exp {
  _and: [applications_bool_exp!]
  _not: applications_bool_exp
  _or: [applications_bool_exp!]
  annotations: jsonb_comparison_exp
  applicant_data: jsonb_comparison_exp
  applicant_id: String_comparison_exp
  area_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  permission_label: String_comparison_exp
  status: String_comparison_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  verification_type: String_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.applications"
"""
enum applications_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  applications_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input applications_delete_at_path_input {
  annotations: [String!]
  applicant_data: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input applications_delete_elem_input {
  annotations: Int
  applicant_data: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input applications_delete_key_input {
  annotations: String
  applicant_data: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.applications"
"""
input applications_insert_input {
  annotations: jsonb
  applicant_data: jsonb
  applicant_id: String
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  labels: jsonb
  permission_label: String
  status: String
  tenant_id: uuid
  updated_at: timestamptz
  verification_type: String
}

"""aggregate max on columns"""
type applications_max_fields {
  applicant_id: String
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  permission_label: String
  status: String
  tenant_id: uuid
  updated_at: timestamptz
  verification_type: String
}

"""aggregate min on columns"""
type applications_min_fields {
  applicant_id: String
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  permission_label: String
  status: String
  tenant_id: uuid
  updated_at: timestamptz
  verification_type: String
}

"""
response of any mutation on the table "sequent_backend.applications"
"""
type applications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [applications!]!
}

"""
on_conflict condition type for table "sequent_backend.applications"
"""
input applications_on_conflict {
  constraint: applications_constraint!
  update_columns: [applications_update_column!]! = []
  where: applications_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.applications".
"""
input applications_order_by {
  annotations: order_by
  applicant_data: order_by
  applicant_id: order_by
  area_id: order_by
  created_at: order_by
  election_event_id: order_by
  id: order_by
  labels: order_by
  permission_label: order_by
  status: order_by
  tenant_id: order_by
  updated_at: order_by
  verification_type: order_by
}

"""primary key columns input for table: sequent_backend.applications"""
input applications_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input applications_prepend_input {
  annotations: jsonb
  applicant_data: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.applications"
"""
enum applications_select_column {
  """column name"""
  annotations
  """column name"""
  applicant_data
  """column name"""
  applicant_id
  """column name"""
  area_id
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  permission_label
  """column name"""
  status
  """column name"""
  tenant_id
  """column name"""
  updated_at
  """column name"""
  verification_type
}

"""
input type for updating data in table "sequent_backend.applications"
"""
input applications_set_input {
  annotations: jsonb
  applicant_data: jsonb
  applicant_id: String
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  labels: jsonb
  permission_label: String
  status: String
  tenant_id: uuid
  updated_at: timestamptz
  verification_type: String
}

"""
Streaming cursor of the table "sequent_backend_applications"
"""
input applications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: applications_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input applications_stream_cursor_value_input {
  annotations: jsonb
  applicant_data: jsonb
  applicant_id: String
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  labels: jsonb
  permission_label: String
  status: String
  tenant_id: uuid
  updated_at: timestamptz
  verification_type: String
}

"""
update columns of table "sequent_backend.applications"
"""
enum applications_update_column {
  """column name"""
  annotations
  """column name"""
  applicant_data
  """column name"""
  applicant_id
  """column name"""
  area_id
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  permission_label
  """column name"""
  status
  """column name"""
  tenant_id
  """column name"""
  updated_at
  """column name"""
  verification_type
}

input applications_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: applications_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: applications_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: applications_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: applications_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: applications_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: applications_set_input
  """filter the rows which have to be updated"""
  where: applications_bool_exp!
}

"""
columns and relationships of "sequent_backend.area"
"""
type area {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  description: String
  election_event_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  name: String
  parent_id: uuid
  presentation(
    """JSON select path"""
    path: String
  ): jsonb
  tenant_id: uuid!
  type: String
}

"""
aggregated selection of "sequent_backend.area"
"""
type area_aggregate {
  aggregate: area_aggregate_fields
  nodes: [area!]!
}

"""
aggregate fields of "sequent_backend.area"
"""
type area_aggregate_fields {
  count(columns: [area_select_column!], distinct: Boolean): Int!
  max: area_max_fields
  min: area_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input area_append_input {
  annotations: jsonb
  labels: jsonb
  presentation: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.area". All fields are combined with a logical 'AND'.
"""
input area_bool_exp {
  _and: [area_bool_exp!]
  _not: area_bool_exp
  _or: [area_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  parent_id: uuid_comparison_exp
  presentation: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.area"
"""
enum area_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  area_pkey
}

"""
columns and relationships of "sequent_backend.area_contest"
"""
type area_contest {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  """An object relationship"""
  area: area
  area_id: uuid
  """An object relationship"""
  contest: contest
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""
aggregated selection of "sequent_backend.area_contest"
"""
type area_contest_aggregate {
  aggregate: area_contest_aggregate_fields
  nodes: [area_contest!]!
}

"""
aggregate fields of "sequent_backend.area_contest"
"""
type area_contest_aggregate_fields {
  count(columns: [area_contest_select_column!], distinct: Boolean): Int!
  max: area_contest_max_fields
  min: area_contest_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input area_contest_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.area_contest". All fields are combined with a logical 'AND'.
"""
input area_contest_bool_exp {
  _and: [area_contest_bool_exp!]
  _not: area_contest_bool_exp
  _or: [area_contest_bool_exp!]
  annotations: jsonb_comparison_exp
  area: area_bool_exp
  area_id: uuid_comparison_exp
  contest: contest_bool_exp
  contest_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.area_contest"
"""
enum area_contest_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  area_context_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input area_contest_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input area_contest_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input area_contest_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.area_contest"
"""
input area_contest_insert_input {
  annotations: jsonb
  area: area_obj_rel_insert_input
  area_id: uuid
  contest: contest_obj_rel_insert_input
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""aggregate max on columns"""
type area_contest_max_fields {
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""aggregate min on columns"""
type area_contest_min_fields {
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.area_contest"
"""
type area_contest_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [area_contest!]!
}

"""
on_conflict condition type for table "sequent_backend.area_contest"
"""
input area_contest_on_conflict {
  constraint: area_contest_constraint!
  update_columns: [area_contest_update_column!]! = []
  where: area_contest_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.area_contest".
"""
input area_contest_order_by {
  annotations: order_by
  area: area_order_by
  area_id: order_by
  contest: contest_order_by
  contest_id: order_by
  created_at: order_by
  election_event_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.area_contest"""
input area_contest_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input area_contest_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.area_contest"
"""
enum area_contest_select_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.area_contest"
"""
input area_contest_set_input {
  annotations: jsonb
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_area_contest"
"""
input area_contest_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: area_contest_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input area_contest_stream_cursor_value_input {
  annotations: jsonb
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.area_contest"
"""
enum area_contest_update_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  tenant_id
}

input area_contest_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: area_contest_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: area_contest_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: area_contest_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: area_contest_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: area_contest_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: area_contest_set_input
  """filter the rows which have to be updated"""
  where: area_contest_bool_exp!
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input area_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
  presentation: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input area_delete_elem_input {
  annotations: Int
  labels: Int
  presentation: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input area_delete_key_input {
  annotations: String
  labels: String
  presentation: String
}

"""
input type for inserting data into table "sequent_backend.area"
"""
input area_insert_input {
  annotations: jsonb
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  parent_id: uuid
  presentation: jsonb
  tenant_id: uuid
  type: String
}

"""aggregate max on columns"""
type area_max_fields {
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  parent_id: uuid
  tenant_id: uuid
  type: String
}

"""aggregate min on columns"""
type area_min_fields {
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  parent_id: uuid
  tenant_id: uuid
  type: String
}

"""
response of any mutation on the table "sequent_backend.area"
"""
type area_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [area!]!
}

"""
input type for inserting object relation for remote table "sequent_backend.area"
"""
input area_obj_rel_insert_input {
  data: area_insert_input!
  """upsert condition"""
  on_conflict: area_on_conflict
}

"""
on_conflict condition type for table "sequent_backend.area"
"""
input area_on_conflict {
  constraint: area_constraint!
  update_columns: [area_update_column!]! = []
  where: area_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.area"."""
input area_order_by {
  annotations: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  name: order_by
  parent_id: order_by
  presentation: order_by
  tenant_id: order_by
  type: order_by
}

"""primary key columns input for table: sequent_backend.area"""
input area_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input area_prepend_input {
  annotations: jsonb
  labels: jsonb
  presentation: jsonb
}

"""
select columns of table "sequent_backend.area"
"""
enum area_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  parent_id
  """column name"""
  presentation
  """column name"""
  tenant_id
  """column name"""
  type
}

"""
input type for updating data in table "sequent_backend.area"
"""
input area_set_input {
  annotations: jsonb
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  parent_id: uuid
  presentation: jsonb
  tenant_id: uuid
  type: String
}

"""
Streaming cursor of the table "sequent_backend_area"
"""
input area_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: area_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input area_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  parent_id: uuid
  presentation: jsonb
  tenant_id: uuid
  type: String
}

"""
update columns of table "sequent_backend.area"
"""
enum area_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  parent_id
  """column name"""
  presentation
  """column name"""
  tenant_id
  """column name"""
  type
}

input area_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: area_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: area_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: area_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: area_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: area_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: area_set_input
  """filter the rows which have to be updated"""
  where: area_bool_exp!
}

"""
columns and relationships of "sequent_backend.ballot_publication"
"""
type ballot_publication {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid!
  election_id: uuid
  election_ids: [uuid!]
  id: uuid!
  is_generated: Boolean!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  published_at: timestamptz
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.ballot_publication"
"""
type ballot_publication_aggregate {
  aggregate: ballot_publication_aggregate_fields
  nodes: [ballot_publication!]!
}

"""
aggregate fields of "sequent_backend.ballot_publication"
"""
type ballot_publication_aggregate_fields {
  count(columns: [ballot_publication_select_column!], distinct: Boolean): Int!
  max: ballot_publication_max_fields
  min: ballot_publication_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ballot_publication_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.ballot_publication". All fields are combined with a logical 'AND'.
"""
input ballot_publication_bool_exp {
  _and: [ballot_publication_bool_exp!]
  _not: ballot_publication_bool_exp
  _or: [ballot_publication_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by_user_id: String_comparison_exp
  deleted_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  election_ids: uuid_array_comparison_exp
  id: uuid_comparison_exp
  is_generated: Boolean_comparison_exp
  labels: jsonb_comparison_exp
  published_at: timestamptz_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.ballot_publication"
"""
enum ballot_publication_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  ballot_publication_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ballot_publication_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ballot_publication_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ballot_publication_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.ballot_publication"
"""
input ballot_publication_insert_input {
  annotations: jsonb
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  election_ids: [uuid!]
  id: uuid
  is_generated: Boolean
  labels: jsonb
  published_at: timestamptz
  tenant_id: uuid
}

"""aggregate max on columns"""
type ballot_publication_max_fields {
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  election_ids: [uuid!]
  id: uuid
  published_at: timestamptz
  tenant_id: uuid
}

"""aggregate min on columns"""
type ballot_publication_min_fields {
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  election_ids: [uuid!]
  id: uuid
  published_at: timestamptz
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.ballot_publication"
"""
type ballot_publication_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [ballot_publication!]!
}

"""
on_conflict condition type for table "sequent_backend.ballot_publication"
"""
input ballot_publication_on_conflict {
  constraint: ballot_publication_constraint!
  update_columns: [ballot_publication_update_column!]! = []
  where: ballot_publication_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.ballot_publication".
"""
input ballot_publication_order_by {
  annotations: order_by
  created_at: order_by
  created_by_user_id: order_by
  deleted_at: order_by
  election_event_id: order_by
  election_id: order_by
  election_ids: order_by
  id: order_by
  is_generated: order_by
  labels: order_by
  published_at: order_by
  tenant_id: order_by
}

"""
primary key columns input for table: sequent_backend.ballot_publication
"""
input ballot_publication_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ballot_publication_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.ballot_publication"
"""
enum ballot_publication_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  created_by_user_id
  """column name"""
  deleted_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  election_ids
  """column name"""
  id
  """column name"""
  is_generated
  """column name"""
  labels
  """column name"""
  published_at
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.ballot_publication"
"""
input ballot_publication_set_input {
  annotations: jsonb
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  election_ids: [uuid!]
  id: uuid
  is_generated: Boolean
  labels: jsonb
  published_at: timestamptz
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_ballot_publication"
"""
input ballot_publication_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ballot_publication_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ballot_publication_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  election_ids: [uuid!]
  id: uuid
  is_generated: Boolean
  labels: jsonb
  published_at: timestamptz
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.ballot_publication"
"""
enum ballot_publication_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  created_by_user_id
  """column name"""
  deleted_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  election_ids
  """column name"""
  id
  """column name"""
  is_generated
  """column name"""
  labels
  """column name"""
  published_at
  """column name"""
  tenant_id
}

input ballot_publication_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ballot_publication_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: ballot_publication_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: ballot_publication_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: ballot_publication_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ballot_publication_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: ballot_publication_set_input
  """filter the rows which have to be updated"""
  where: ballot_publication_bool_exp!
}

"""
columns and relationships of "sequent_backend.ballot_style"
"""
type ballot_style {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  area_id: uuid
  ballot_eml: String
  ballot_publication_id: uuid!
  ballot_signature: bytea
  created_at: timestamptz
  deleted_at: timestamptz
  election_event_id: uuid!
  election_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  status: String
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.ballot_style"
"""
type ballot_style_aggregate {
  aggregate: ballot_style_aggregate_fields
  nodes: [ballot_style!]!
}

"""
aggregate fields of "sequent_backend.ballot_style"
"""
type ballot_style_aggregate_fields {
  count(columns: [ballot_style_select_column!], distinct: Boolean): Int!
  max: ballot_style_max_fields
  min: ballot_style_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ballot_style_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.ballot_style". All fields are combined with a logical 'AND'.
"""
input ballot_style_bool_exp {
  _and: [ballot_style_bool_exp!]
  _not: ballot_style_bool_exp
  _or: [ballot_style_bool_exp!]
  annotations: jsonb_comparison_exp
  area_id: uuid_comparison_exp
  ballot_eml: String_comparison_exp
  ballot_publication_id: uuid_comparison_exp
  ballot_signature: bytea_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  status: String_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.ballot_style"
"""
enum ballot_style_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  ballot_style_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ballot_style_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ballot_style_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ballot_style_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.ballot_style"
"""
input ballot_style_insert_input {
  annotations: jsonb
  area_id: uuid
  ballot_eml: String
  ballot_publication_id: uuid
  ballot_signature: bytea
  created_at: timestamptz
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  status: String
  tenant_id: uuid
}

"""aggregate max on columns"""
type ballot_style_max_fields {
  area_id: uuid
  ballot_eml: String
  ballot_publication_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  status: String
  tenant_id: uuid
}

"""aggregate min on columns"""
type ballot_style_min_fields {
  area_id: uuid
  ballot_eml: String
  ballot_publication_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  status: String
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.ballot_style"
"""
type ballot_style_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [ballot_style!]!
}

"""
on_conflict condition type for table "sequent_backend.ballot_style"
"""
input ballot_style_on_conflict {
  constraint: ballot_style_constraint!
  update_columns: [ballot_style_update_column!]! = []
  where: ballot_style_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.ballot_style".
"""
input ballot_style_order_by {
  annotations: order_by
  area_id: order_by
  ballot_eml: order_by
  ballot_publication_id: order_by
  ballot_signature: order_by
  created_at: order_by
  deleted_at: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  status: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.ballot_style"""
input ballot_style_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ballot_style_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.ballot_style"
"""
enum ballot_style_select_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  ballot_eml
  """column name"""
  ballot_publication_id
  """column name"""
  ballot_signature
  """column name"""
  created_at
  """column name"""
  deleted_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  status
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.ballot_style"
"""
input ballot_style_set_input {
  annotations: jsonb
  area_id: uuid
  ballot_eml: String
  ballot_publication_id: uuid
  ballot_signature: bytea
  created_at: timestamptz
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  status: String
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_ballot_style"
"""
input ballot_style_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ballot_style_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ballot_style_stream_cursor_value_input {
  annotations: jsonb
  area_id: uuid
  ballot_eml: String
  ballot_publication_id: uuid
  ballot_signature: bytea
  created_at: timestamptz
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  status: String
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.ballot_style"
"""
enum ballot_style_update_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  ballot_eml
  """column name"""
  ballot_publication_id
  """column name"""
  ballot_signature
  """column name"""
  created_at
  """column name"""
  deleted_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  status
  """column name"""
  tenant_id
}

input ballot_style_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ballot_style_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: ballot_style_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: ballot_style_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: ballot_style_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ballot_style_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: ballot_style_set_input
  """filter the rows which have to be updated"""
  where: ballot_style_bool_exp!
}

"""
columns and relationships of "sequent_backend.candidate"
"""
type candidate {
  alias: String
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  contest_id: uuid
  created_at: timestamptz
  description: String
  election_event_id: uuid!
  id: uuid!
  image_document_id: String
  is_public: Boolean
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  name: String
  presentation(
    """JSON select path"""
    path: String
  ): jsonb
  tenant_id: uuid!
  type: String
}

"""
aggregated selection of "sequent_backend.candidate"
"""
type candidate_aggregate {
  aggregate: candidate_aggregate_fields
  nodes: [candidate!]!
}

input candidate_aggregate_bool_exp {
  bool_and: candidate_aggregate_bool_exp_bool_and
  bool_or: candidate_aggregate_bool_exp_bool_or
  count: candidate_aggregate_bool_exp_count
}

input candidate_aggregate_bool_exp_bool_and {
  arguments: candidate_select_column_sequent_backend_candidate_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: candidate_bool_exp
  predicate: Boolean_comparison_exp!
}

input candidate_aggregate_bool_exp_bool_or {
  arguments: candidate_select_column_sequent_backend_candidate_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: candidate_bool_exp
  predicate: Boolean_comparison_exp!
}

input candidate_aggregate_bool_exp_count {
  arguments: [candidate_select_column!]
  distinct: Boolean
  filter: candidate_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sequent_backend.candidate"
"""
type candidate_aggregate_fields {
  count(columns: [candidate_select_column!], distinct: Boolean): Int!
  max: candidate_max_fields
  min: candidate_min_fields
}

"""
order by aggregate values of table "sequent_backend.candidate"
"""
input candidate_aggregate_order_by {
  count: order_by
  max: candidate_max_order_by
  min: candidate_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input candidate_append_input {
  annotations: jsonb
  labels: jsonb
  presentation: jsonb
}

"""
input type for inserting array relation for remote table "sequent_backend.candidate"
"""
input candidate_arr_rel_insert_input {
  data: [candidate_insert_input!]!
  """upsert condition"""
  on_conflict: candidate_on_conflict
}

"""
Boolean expression to filter rows from the table "sequent_backend.candidate". All fields are combined with a logical 'AND'.
"""
input candidate_bool_exp {
  _and: [candidate_bool_exp!]
  _not: candidate_bool_exp
  _or: [candidate_bool_exp!]
  alias: String_comparison_exp
  annotations: jsonb_comparison_exp
  contest_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  image_document_id: String_comparison_exp
  is_public: Boolean_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  presentation: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.candidate"
"""
enum candidate_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  candidate_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input candidate_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
  presentation: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input candidate_delete_elem_input {
  annotations: Int
  labels: Int
  presentation: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input candidate_delete_key_input {
  annotations: String
  labels: String
  presentation: String
}

"""
input type for inserting data into table "sequent_backend.candidate"
"""
input candidate_insert_input {
  alias: String
  annotations: jsonb
  contest_id: uuid
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  image_document_id: String
  is_public: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  presentation: jsonb
  tenant_id: uuid
  type: String
}

"""aggregate max on columns"""
type candidate_max_fields {
  alias: String
  contest_id: uuid
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  image_document_id: String
  last_updated_at: timestamptz
  name: String
  tenant_id: uuid
  type: String
}

"""
order by max() on columns of table "sequent_backend.candidate"
"""
input candidate_max_order_by {
  alias: order_by
  contest_id: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  id: order_by
  image_document_id: order_by
  last_updated_at: order_by
  name: order_by
  tenant_id: order_by
  type: order_by
}

"""aggregate min on columns"""
type candidate_min_fields {
  alias: String
  contest_id: uuid
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  image_document_id: String
  last_updated_at: timestamptz
  name: String
  tenant_id: uuid
  type: String
}

"""
order by min() on columns of table "sequent_backend.candidate"
"""
input candidate_min_order_by {
  alias: order_by
  contest_id: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  id: order_by
  image_document_id: order_by
  last_updated_at: order_by
  name: order_by
  tenant_id: order_by
  type: order_by
}

"""
response of any mutation on the table "sequent_backend.candidate"
"""
type candidate_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [candidate!]!
}

"""
on_conflict condition type for table "sequent_backend.candidate"
"""
input candidate_on_conflict {
  constraint: candidate_constraint!
  update_columns: [candidate_update_column!]! = []
  where: candidate_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.candidate"."""
input candidate_order_by {
  alias: order_by
  annotations: order_by
  contest_id: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  id: order_by
  image_document_id: order_by
  is_public: order_by
  labels: order_by
  last_updated_at: order_by
  name: order_by
  presentation: order_by
  tenant_id: order_by
  type: order_by
}

"""primary key columns input for table: sequent_backend.candidate"""
input candidate_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input candidate_prepend_input {
  annotations: jsonb
  labels: jsonb
  presentation: jsonb
}

"""
select columns of table "sequent_backend.candidate"
"""
enum candidate_select_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  image_document_id
  """column name"""
  is_public
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  presentation
  """column name"""
  tenant_id
  """column name"""
  type
}

"""
select "sequent_backend_candidate_aggregate_bool_exp_bool_and_arguments_columns" columns of table "sequent_backend.candidate"
"""
enum candidate_select_column_sequent_backend_candidate_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_public
}

"""
select "sequent_backend_candidate_aggregate_bool_exp_bool_or_arguments_columns" columns of table "sequent_backend.candidate"
"""
enum candidate_select_column_sequent_backend_candidate_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_public
}

"""
input type for updating data in table "sequent_backend.candidate"
"""
input candidate_set_input {
  alias: String
  annotations: jsonb
  contest_id: uuid
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  image_document_id: String
  is_public: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  presentation: jsonb
  tenant_id: uuid
  type: String
}

"""
Streaming cursor of the table "sequent_backend_candidate"
"""
input candidate_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: candidate_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input candidate_stream_cursor_value_input {
  alias: String
  annotations: jsonb
  contest_id: uuid
  created_at: timestamptz
  description: String
  election_event_id: uuid
  id: uuid
  image_document_id: String
  is_public: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  presentation: jsonb
  tenant_id: uuid
  type: String
}

"""
update columns of table "sequent_backend.candidate"
"""
enum candidate_update_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  image_document_id
  """column name"""
  is_public
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  presentation
  """column name"""
  tenant_id
  """column name"""
  type
}

input candidate_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: candidate_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: candidate_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: candidate_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: candidate_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: candidate_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: candidate_set_input
  """filter the rows which have to be updated"""
  where: candidate_bool_exp!
}

"""
columns and relationships of "sequent_backend.cast_vote"
"""
type cast_vote {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  area_id: uuid
  ballot_id: String
  cast_ballot_signature: bytea
  content: String
  created_at: timestamptz
  election_event_id: uuid!
  election_id: uuid
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  tenant_id: uuid!
  voter_id_string: String
}

"""
aggregated selection of "sequent_backend.cast_vote"
"""
type cast_vote_aggregate {
  aggregate: cast_vote_aggregate_fields
  nodes: [cast_vote!]!
}

"""
aggregate fields of "sequent_backend.cast_vote"
"""
type cast_vote_aggregate_fields {
  count(columns: [cast_vote_select_column!], distinct: Boolean): Int!
  max: cast_vote_max_fields
  min: cast_vote_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input cast_vote_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.cast_vote". All fields are combined with a logical 'AND'.
"""
input cast_vote_bool_exp {
  _and: [cast_vote_bool_exp!]
  _not: cast_vote_bool_exp
  _or: [cast_vote_bool_exp!]
  annotations: jsonb_comparison_exp
  area_id: uuid_comparison_exp
  ballot_id: String_comparison_exp
  cast_ballot_signature: bytea_comparison_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  tenant_id: uuid_comparison_exp
  voter_id_string: String_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.cast_vote"
"""
enum cast_vote_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  cast_vote_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input cast_vote_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input cast_vote_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input cast_vote_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.cast_vote"
"""
input cast_vote_insert_input {
  annotations: jsonb
  area_id: uuid
  ballot_id: String
  cast_ballot_signature: bytea
  content: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
  voter_id_string: String
}

"""aggregate max on columns"""
type cast_vote_max_fields {
  area_id: uuid
  ballot_id: String
  content: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  tenant_id: uuid
  voter_id_string: String
}

"""aggregate min on columns"""
type cast_vote_min_fields {
  area_id: uuid
  ballot_id: String
  content: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  tenant_id: uuid
  voter_id_string: String
}

"""
response of any mutation on the table "sequent_backend.cast_vote"
"""
type cast_vote_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [cast_vote!]!
}

"""
on_conflict condition type for table "sequent_backend.cast_vote"
"""
input cast_vote_on_conflict {
  constraint: cast_vote_constraint!
  update_columns: [cast_vote_update_column!]! = []
  where: cast_vote_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.cast_vote"."""
input cast_vote_order_by {
  annotations: order_by
  area_id: order_by
  ballot_id: order_by
  cast_ballot_signature: order_by
  content: order_by
  created_at: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  tenant_id: order_by
  voter_id_string: order_by
}

"""primary key columns input for table: sequent_backend.cast_vote"""
input cast_vote_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input cast_vote_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.cast_vote"
"""
enum cast_vote_select_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  ballot_id
  """column name"""
  cast_ballot_signature
  """column name"""
  content
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  tenant_id
  """column name"""
  voter_id_string
}

"""
input type for updating data in table "sequent_backend.cast_vote"
"""
input cast_vote_set_input {
  annotations: jsonb
  area_id: uuid
  ballot_id: String
  cast_ballot_signature: bytea
  content: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
  voter_id_string: String
}

"""
Streaming cursor of the table "sequent_backend_cast_vote"
"""
input cast_vote_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cast_vote_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cast_vote_stream_cursor_value_input {
  annotations: jsonb
  area_id: uuid
  ballot_id: String
  cast_ballot_signature: bytea
  content: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
  voter_id_string: String
}

"""
update columns of table "sequent_backend.cast_vote"
"""
enum cast_vote_update_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  ballot_id
  """column name"""
  cast_ballot_signature
  """column name"""
  content
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  tenant_id
  """column name"""
  voter_id_string
}

input cast_vote_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: cast_vote_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: cast_vote_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: cast_vote_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: cast_vote_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: cast_vote_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: cast_vote_set_input
  """filter the rows which have to be updated"""
  where: cast_vote_bool_exp!
}

"""
columns and relationships of "sequent_backend.contest"
"""
type contest {
  alias: String
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  """An array relationship"""
  candidates(
    """distinct select on columns"""
    distinct_on: [candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [candidate_order_by!]
    """filter the rows returned"""
    where: candidate_bool_exp
  ): [candidate!]!
  """An aggregate relationship"""
  candidates_aggregate(
    """distinct select on columns"""
    distinct_on: [candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [candidate_order_by!]
    """filter the rows returned"""
    where: candidate_bool_exp
  ): candidate_aggregate!
  conditions(
    """JSON select path"""
    path: String
  ): jsonb
  counting_algorithm: String
  created_at: timestamptz
  description: String
  election_event_id: uuid!
  election_id: uuid!
  id: uuid!
  image_document_id: String
  is_acclaimed: Boolean
  is_active: Boolean
  is_encrypted: Boolean
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  max_votes: Int
  min_votes: Int
  name: String
  presentation(
    """JSON select path"""
    path: String
  ): jsonb
  tally_configuration(
    """JSON select path"""
    path: String
  ): jsonb
  tenant_id: uuid!
  voting_type: String
  winning_candidates_num: Int
}

"""
aggregated selection of "sequent_backend.contest"
"""
type contest_aggregate {
  aggregate: contest_aggregate_fields
  nodes: [contest!]!
}

input contest_aggregate_bool_exp {
  bool_and: contest_aggregate_bool_exp_bool_and
  bool_or: contest_aggregate_bool_exp_bool_or
  count: contest_aggregate_bool_exp_count
}

input contest_aggregate_bool_exp_bool_and {
  arguments: contest_select_column_sequent_backend_contest_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: contest_bool_exp
  predicate: Boolean_comparison_exp!
}

input contest_aggregate_bool_exp_bool_or {
  arguments: contest_select_column_sequent_backend_contest_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: contest_bool_exp
  predicate: Boolean_comparison_exp!
}

input contest_aggregate_bool_exp_count {
  arguments: [contest_select_column!]
  distinct: Boolean
  filter: contest_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sequent_backend.contest"
"""
type contest_aggregate_fields {
  avg: contest_avg_fields
  count(columns: [contest_select_column!], distinct: Boolean): Int!
  max: contest_max_fields
  min: contest_min_fields
  stddev: contest_stddev_fields
  stddev_pop: contest_stddev_pop_fields
  stddev_samp: contest_stddev_samp_fields
  sum: contest_sum_fields
  var_pop: contest_var_pop_fields
  var_samp: contest_var_samp_fields
  variance: contest_variance_fields
}

"""
order by aggregate values of table "sequent_backend.contest"
"""
input contest_aggregate_order_by {
  avg: contest_avg_order_by
  count: order_by
  max: contest_max_order_by
  min: contest_min_order_by
  stddev: contest_stddev_order_by
  stddev_pop: contest_stddev_pop_order_by
  stddev_samp: contest_stddev_samp_order_by
  sum: contest_sum_order_by
  var_pop: contest_var_pop_order_by
  var_samp: contest_var_samp_order_by
  variance: contest_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input contest_append_input {
  annotations: jsonb
  conditions: jsonb
  labels: jsonb
  presentation: jsonb
  tally_configuration: jsonb
}

"""
input type for inserting array relation for remote table "sequent_backend.contest"
"""
input contest_arr_rel_insert_input {
  data: [contest_insert_input!]!
  """upsert condition"""
  on_conflict: contest_on_conflict
}

"""aggregate avg on columns"""
type contest_avg_fields {
  max_votes: Float
  min_votes: Float
  winning_candidates_num: Float
}

"""
order by avg() on columns of table "sequent_backend.contest"
"""
input contest_avg_order_by {
  max_votes: order_by
  min_votes: order_by
  winning_candidates_num: order_by
}

"""
Boolean expression to filter rows from the table "sequent_backend.contest". All fields are combined with a logical 'AND'.
"""
input contest_bool_exp {
  _and: [contest_bool_exp!]
  _not: contest_bool_exp
  _or: [contest_bool_exp!]
  alias: String_comparison_exp
  annotations: jsonb_comparison_exp
  candidates: candidate_bool_exp
  candidates_aggregate: candidate_aggregate_bool_exp
  conditions: jsonb_comparison_exp
  counting_algorithm: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  image_document_id: String_comparison_exp
  is_acclaimed: Boolean_comparison_exp
  is_active: Boolean_comparison_exp
  is_encrypted: Boolean_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  max_votes: Int_comparison_exp
  min_votes: Int_comparison_exp
  name: String_comparison_exp
  presentation: jsonb_comparison_exp
  tally_configuration: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
  voting_type: String_comparison_exp
  winning_candidates_num: Int_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.contest"
"""
enum contest_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  contest_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input contest_delete_at_path_input {
  annotations: [String!]
  conditions: [String!]
  labels: [String!]
  presentation: [String!]
  tally_configuration: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input contest_delete_elem_input {
  annotations: Int
  conditions: Int
  labels: Int
  presentation: Int
  tally_configuration: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input contest_delete_key_input {
  annotations: String
  conditions: String
  labels: String
  presentation: String
  tally_configuration: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.contest"
"""
input contest_inc_input {
  max_votes: Int
  min_votes: Int
  winning_candidates_num: Int
}

"""
input type for inserting data into table "sequent_backend.contest"
"""
input contest_insert_input {
  alias: String
  annotations: jsonb
  candidates: candidate_arr_rel_insert_input
  conditions: jsonb
  counting_algorithm: String
  created_at: timestamptz
  description: String
  election_event_id: uuid
  election_id: uuid
  id: uuid
  image_document_id: String
  is_acclaimed: Boolean
  is_active: Boolean
  is_encrypted: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  max_votes: Int
  min_votes: Int
  name: String
  presentation: jsonb
  tally_configuration: jsonb
  tenant_id: uuid
  voting_type: String
  winning_candidates_num: Int
}

"""aggregate max on columns"""
type contest_max_fields {
  alias: String
  counting_algorithm: String
  created_at: timestamptz
  description: String
  election_event_id: uuid
  election_id: uuid
  id: uuid
  image_document_id: String
  last_updated_at: timestamptz
  max_votes: Int
  min_votes: Int
  name: String
  tenant_id: uuid
  voting_type: String
  winning_candidates_num: Int
}

"""
order by max() on columns of table "sequent_backend.contest"
"""
input contest_max_order_by {
  alias: order_by
  counting_algorithm: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  image_document_id: order_by
  last_updated_at: order_by
  max_votes: order_by
  min_votes: order_by
  name: order_by
  tenant_id: order_by
  voting_type: order_by
  winning_candidates_num: order_by
}

"""aggregate min on columns"""
type contest_min_fields {
  alias: String
  counting_algorithm: String
  created_at: timestamptz
  description: String
  election_event_id: uuid
  election_id: uuid
  id: uuid
  image_document_id: String
  last_updated_at: timestamptz
  max_votes: Int
  min_votes: Int
  name: String
  tenant_id: uuid
  voting_type: String
  winning_candidates_num: Int
}

"""
order by min() on columns of table "sequent_backend.contest"
"""
input contest_min_order_by {
  alias: order_by
  counting_algorithm: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  image_document_id: order_by
  last_updated_at: order_by
  max_votes: order_by
  min_votes: order_by
  name: order_by
  tenant_id: order_by
  voting_type: order_by
  winning_candidates_num: order_by
}

"""
response of any mutation on the table "sequent_backend.contest"
"""
type contest_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [contest!]!
}

"""
input type for inserting object relation for remote table "sequent_backend.contest"
"""
input contest_obj_rel_insert_input {
  data: contest_insert_input!
  """upsert condition"""
  on_conflict: contest_on_conflict
}

"""
on_conflict condition type for table "sequent_backend.contest"
"""
input contest_on_conflict {
  constraint: contest_constraint!
  update_columns: [contest_update_column!]! = []
  where: contest_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.contest"."""
input contest_order_by {
  alias: order_by
  annotations: order_by
  candidates_aggregate: candidate_aggregate_order_by
  conditions: order_by
  counting_algorithm: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  image_document_id: order_by
  is_acclaimed: order_by
  is_active: order_by
  is_encrypted: order_by
  labels: order_by
  last_updated_at: order_by
  max_votes: order_by
  min_votes: order_by
  name: order_by
  presentation: order_by
  tally_configuration: order_by
  tenant_id: order_by
  voting_type: order_by
  winning_candidates_num: order_by
}

"""primary key columns input for table: sequent_backend.contest"""
input contest_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input contest_prepend_input {
  annotations: jsonb
  conditions: jsonb
  labels: jsonb
  presentation: jsonb
  tally_configuration: jsonb
}

"""
select columns of table "sequent_backend.contest"
"""
enum contest_select_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  conditions
  """column name"""
  counting_algorithm
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  image_document_id
  """column name"""
  is_acclaimed
  """column name"""
  is_active
  """column name"""
  is_encrypted
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  max_votes
  """column name"""
  min_votes
  """column name"""
  name
  """column name"""
  presentation
  """column name"""
  tally_configuration
  """column name"""
  tenant_id
  """column name"""
  voting_type
  """column name"""
  winning_candidates_num
}

"""
select "sequent_backend_contest_aggregate_bool_exp_bool_and_arguments_columns" columns of table "sequent_backend.contest"
"""
enum contest_select_column_sequent_backend_contest_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_acclaimed
  """column name"""
  is_active
  """column name"""
  is_encrypted
}

"""
select "sequent_backend_contest_aggregate_bool_exp_bool_or_arguments_columns" columns of table "sequent_backend.contest"
"""
enum contest_select_column_sequent_backend_contest_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_acclaimed
  """column name"""
  is_active
  """column name"""
  is_encrypted
}

"""
input type for updating data in table "sequent_backend.contest"
"""
input contest_set_input {
  alias: String
  annotations: jsonb
  conditions: jsonb
  counting_algorithm: String
  created_at: timestamptz
  description: String
  election_event_id: uuid
  election_id: uuid
  id: uuid
  image_document_id: String
  is_acclaimed: Boolean
  is_active: Boolean
  is_encrypted: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  max_votes: Int
  min_votes: Int
  name: String
  presentation: jsonb
  tally_configuration: jsonb
  tenant_id: uuid
  voting_type: String
  winning_candidates_num: Int
}

"""aggregate stddev on columns"""
type contest_stddev_fields {
  max_votes: Float
  min_votes: Float
  winning_candidates_num: Float
}

"""
order by stddev() on columns of table "sequent_backend.contest"
"""
input contest_stddev_order_by {
  max_votes: order_by
  min_votes: order_by
  winning_candidates_num: order_by
}

"""aggregate stddev_pop on columns"""
type contest_stddev_pop_fields {
  max_votes: Float
  min_votes: Float
  winning_candidates_num: Float
}

"""
order by stddev_pop() on columns of table "sequent_backend.contest"
"""
input contest_stddev_pop_order_by {
  max_votes: order_by
  min_votes: order_by
  winning_candidates_num: order_by
}

"""aggregate stddev_samp on columns"""
type contest_stddev_samp_fields {
  max_votes: Float
  min_votes: Float
  winning_candidates_num: Float
}

"""
order by stddev_samp() on columns of table "sequent_backend.contest"
"""
input contest_stddev_samp_order_by {
  max_votes: order_by
  min_votes: order_by
  winning_candidates_num: order_by
}

"""
Streaming cursor of the table "sequent_backend_contest"
"""
input contest_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: contest_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input contest_stream_cursor_value_input {
  alias: String
  annotations: jsonb
  conditions: jsonb
  counting_algorithm: String
  created_at: timestamptz
  description: String
  election_event_id: uuid
  election_id: uuid
  id: uuid
  image_document_id: String
  is_acclaimed: Boolean
  is_active: Boolean
  is_encrypted: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  max_votes: Int
  min_votes: Int
  name: String
  presentation: jsonb
  tally_configuration: jsonb
  tenant_id: uuid
  voting_type: String
  winning_candidates_num: Int
}

"""aggregate sum on columns"""
type contest_sum_fields {
  max_votes: Int
  min_votes: Int
  winning_candidates_num: Int
}

"""
order by sum() on columns of table "sequent_backend.contest"
"""
input contest_sum_order_by {
  max_votes: order_by
  min_votes: order_by
  winning_candidates_num: order_by
}

"""
update columns of table "sequent_backend.contest"
"""
enum contest_update_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  conditions
  """column name"""
  counting_algorithm
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  image_document_id
  """column name"""
  is_acclaimed
  """column name"""
  is_active
  """column name"""
  is_encrypted
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  max_votes
  """column name"""
  min_votes
  """column name"""
  name
  """column name"""
  presentation
  """column name"""
  tally_configuration
  """column name"""
  tenant_id
  """column name"""
  voting_type
  """column name"""
  winning_candidates_num
}

input contest_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: contest_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: contest_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: contest_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: contest_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: contest_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: contest_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: contest_set_input
  """filter the rows which have to be updated"""
  where: contest_bool_exp!
}

"""aggregate var_pop on columns"""
type contest_var_pop_fields {
  max_votes: Float
  min_votes: Float
  winning_candidates_num: Float
}

"""
order by var_pop() on columns of table "sequent_backend.contest"
"""
input contest_var_pop_order_by {
  max_votes: order_by
  min_votes: order_by
  winning_candidates_num: order_by
}

"""aggregate var_samp on columns"""
type contest_var_samp_fields {
  max_votes: Float
  min_votes: Float
  winning_candidates_num: Float
}

"""
order by var_samp() on columns of table "sequent_backend.contest"
"""
input contest_var_samp_order_by {
  max_votes: order_by
  min_votes: order_by
  winning_candidates_num: order_by
}

"""aggregate variance on columns"""
type contest_variance_fields {
  max_votes: Float
  min_votes: Float
  winning_candidates_num: Float
}

"""
order by variance() on columns of table "sequent_backend.contest"
"""
input contest_variance_order_by {
  max_votes: order_by
  min_votes: order_by
  winning_candidates_num: order_by
}

"""
columns and relationships of "sequent_backend.document"
"""
type document {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  election_event_id: uuid
  id: uuid!
  is_public: Boolean
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  media_type: String
  name: String
  size: bigint
  tenant_id: uuid
}

"""
aggregated selection of "sequent_backend.document"
"""
type document_aggregate {
  aggregate: document_aggregate_fields
  nodes: [document!]!
}

"""
aggregate fields of "sequent_backend.document"
"""
type document_aggregate_fields {
  avg: document_avg_fields
  count(columns: [document_select_column!], distinct: Boolean): Int!
  max: document_max_fields
  min: document_min_fields
  stddev: document_stddev_fields
  stddev_pop: document_stddev_pop_fields
  stddev_samp: document_stddev_samp_fields
  sum: document_sum_fields
  var_pop: document_var_pop_fields
  var_samp: document_var_samp_fields
  variance: document_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input document_append_input {
  annotations: jsonb
  labels: jsonb
}

"""aggregate avg on columns"""
type document_avg_fields {
  size: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.document". All fields are combined with a logical 'AND'.
"""
input document_bool_exp {
  _and: [document_bool_exp!]
  _not: document_bool_exp
  _or: [document_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_public: Boolean_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  media_type: String_comparison_exp
  name: String_comparison_exp
  size: bigint_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.document"
"""
enum document_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  election_document_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input document_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input document_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input document_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.document"
"""
input document_inc_input {
  size: bigint
}

"""
input type for inserting data into table "sequent_backend.document"
"""
input document_insert_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  is_public: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  media_type: String
  name: String
  size: bigint
  tenant_id: uuid
}

"""aggregate max on columns"""
type document_max_fields {
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  media_type: String
  name: String
  size: bigint
  tenant_id: uuid
}

"""aggregate min on columns"""
type document_min_fields {
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  media_type: String
  name: String
  size: bigint
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.document"
"""
type document_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [document!]!
}

"""
on_conflict condition type for table "sequent_backend.document"
"""
input document_on_conflict {
  constraint: document_constraint!
  update_columns: [document_update_column!]! = []
  where: document_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.document"."""
input document_order_by {
  annotations: order_by
  created_at: order_by
  election_event_id: order_by
  id: order_by
  is_public: order_by
  labels: order_by
  last_updated_at: order_by
  media_type: order_by
  name: order_by
  size: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.document"""
input document_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input document_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.document"
"""
enum document_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  is_public
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  media_type
  """column name"""
  name
  """column name"""
  size
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.document"
"""
input document_set_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  is_public: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  media_type: String
  name: String
  size: bigint
  tenant_id: uuid
}

"""aggregate stddev on columns"""
type document_stddev_fields {
  size: Float
}

"""aggregate stddev_pop on columns"""
type document_stddev_pop_fields {
  size: Float
}

"""aggregate stddev_samp on columns"""
type document_stddev_samp_fields {
  size: Float
}

"""
Streaming cursor of the table "sequent_backend_document"
"""
input document_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: document_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input document_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  is_public: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  media_type: String
  name: String
  size: bigint
  tenant_id: uuid
}

"""aggregate sum on columns"""
type document_sum_fields {
  size: bigint
}

"""
update columns of table "sequent_backend.document"
"""
enum document_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  is_public
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  media_type
  """column name"""
  name
  """column name"""
  size
  """column name"""
  tenant_id
}

input document_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: document_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: document_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: document_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: document_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: document_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: document_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: document_set_input
  """filter the rows which have to be updated"""
  where: document_bool_exp!
}

"""aggregate var_pop on columns"""
type document_var_pop_fields {
  size: Float
}

"""aggregate var_samp on columns"""
type document_var_samp_fields {
  size: Float
}

"""aggregate variance on columns"""
type document_variance_fields {
  size: Float
}

"""
columns and relationships of "sequent_backend.election"
"""
type election {
  alias: String
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  """An array relationship"""
  contests(
    """distinct select on columns"""
    distinct_on: [contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [contest_order_by!]
    """filter the rows returned"""
    where: contest_bool_exp
  ): [contest!]!
  """An aggregate relationship"""
  contests_aggregate(
    """distinct select on columns"""
    distinct_on: [contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [contest_order_by!]
    """filter the rows returned"""
    where: contest_bool_exp
  ): contest_aggregate!
  created_at: timestamptz
  description: String
  election_event_id: uuid!
  eml: String
  id: uuid!
  image_document_id: String
  initialization_report_generated: Boolean
  is_consolidated_ballot_encoding: Boolean
  is_kiosk: Boolean
  keys_ceremony_id: uuid
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  name: String!
  num_allowed_revotes: Int
  permission_label: String
  presentation(
    """JSON select path"""
    path: String
  ): jsonb
  receipts(
    """JSON select path"""
    path: String
  ): jsonb
  spoil_ballot_option: Boolean
  statistics(
    """JSON select path"""
    path: String
  ): jsonb
  status(
    """JSON select path"""
    path: String
  ): jsonb
  tenant_id: uuid!
  voting_channels(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "sequent_backend.election"
"""
type election_aggregate {
  aggregate: election_aggregate_fields
  nodes: [election!]!
}

input election_aggregate_bool_exp {
  bool_and: election_aggregate_bool_exp_bool_and
  bool_or: election_aggregate_bool_exp_bool_or
  count: election_aggregate_bool_exp_count
}

input election_aggregate_bool_exp_bool_and {
  arguments: election_select_column_sequent_backend_election_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: election_bool_exp
  predicate: Boolean_comparison_exp!
}

input election_aggregate_bool_exp_bool_or {
  arguments: election_select_column_sequent_backend_election_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: election_bool_exp
  predicate: Boolean_comparison_exp!
}

input election_aggregate_bool_exp_count {
  arguments: [election_select_column!]
  distinct: Boolean
  filter: election_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sequent_backend.election"
"""
type election_aggregate_fields {
  avg: election_avg_fields
  count(columns: [election_select_column!], distinct: Boolean): Int!
  max: election_max_fields
  min: election_min_fields
  stddev: election_stddev_fields
  stddev_pop: election_stddev_pop_fields
  stddev_samp: election_stddev_samp_fields
  sum: election_sum_fields
  var_pop: election_var_pop_fields
  var_samp: election_var_samp_fields
  variance: election_variance_fields
}

"""
order by aggregate values of table "sequent_backend.election"
"""
input election_aggregate_order_by {
  avg: election_avg_order_by
  count: order_by
  max: election_max_order_by
  min: election_min_order_by
  stddev: election_stddev_order_by
  stddev_pop: election_stddev_pop_order_by
  stddev_samp: election_stddev_samp_order_by
  sum: election_sum_order_by
  var_pop: election_var_pop_order_by
  var_samp: election_var_samp_order_by
  variance: election_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input election_append_input {
  annotations: jsonb
  labels: jsonb
  presentation: jsonb
  receipts: jsonb
  statistics: jsonb
  status: jsonb
  voting_channels: jsonb
}

"""
input type for inserting array relation for remote table "sequent_backend.election"
"""
input election_arr_rel_insert_input {
  data: [election_insert_input!]!
  """upsert condition"""
  on_conflict: election_on_conflict
}

"""aggregate avg on columns"""
type election_avg_fields {
  num_allowed_revotes: Float
}

"""
order by avg() on columns of table "sequent_backend.election"
"""
input election_avg_order_by {
  num_allowed_revotes: order_by
}

"""
Boolean expression to filter rows from the table "sequent_backend.election". All fields are combined with a logical 'AND'.
"""
input election_bool_exp {
  _and: [election_bool_exp!]
  _not: election_bool_exp
  _or: [election_bool_exp!]
  alias: String_comparison_exp
  annotations: jsonb_comparison_exp
  contests: contest_bool_exp
  contests_aggregate: contest_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  election_event_id: uuid_comparison_exp
  eml: String_comparison_exp
  id: uuid_comparison_exp
  image_document_id: String_comparison_exp
  initialization_report_generated: Boolean_comparison_exp
  is_consolidated_ballot_encoding: Boolean_comparison_exp
  is_kiosk: Boolean_comparison_exp
  keys_ceremony_id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  num_allowed_revotes: Int_comparison_exp
  permission_label: String_comparison_exp
  presentation: jsonb_comparison_exp
  receipts: jsonb_comparison_exp
  spoil_ballot_option: Boolean_comparison_exp
  statistics: jsonb_comparison_exp
  status: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
  voting_channels: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.election"
"""
enum election_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  election_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input election_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
  presentation: [String!]
  receipts: [String!]
  statistics: [String!]
  status: [String!]
  voting_channels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input election_delete_elem_input {
  annotations: Int
  labels: Int
  presentation: Int
  receipts: Int
  statistics: Int
  status: Int
  voting_channels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input election_delete_key_input {
  annotations: String
  labels: String
  presentation: String
  receipts: String
  statistics: String
  status: String
  voting_channels: String
}

"""
columns and relationships of "sequent_backend.election_event"
"""
type election_event {
  alias: String
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  audit_election_event_id: uuid
  bulletin_board_reference(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  description: String
  """An array relationship"""
  elections(
    """distinct select on columns"""
    distinct_on: [election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_order_by!]
    """filter the rows returned"""
    where: election_bool_exp
  ): [election!]!
  """An aggregate relationship"""
  elections_aggregate(
    """distinct select on columns"""
    distinct_on: [election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_order_by!]
    """filter the rows returned"""
    where: election_bool_exp
  ): election_aggregate!
  encryption_protocol: String!
  id: uuid!
  is_archived: Boolean!
  is_audit: Boolean
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  name: String!
  presentation(
    """JSON select path"""
    path: String
  ): jsonb
  public_key: String
  statistics(
    """JSON select path"""
    path: String
  ): jsonb
  status(
    """JSON select path"""
    path: String
  ): jsonb
  tenant_id: uuid!
  updated_at: timestamptz
  user_boards: String
  voting_channels(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "sequent_backend.election_event"
"""
type election_event_aggregate {
  aggregate: election_event_aggregate_fields
  nodes: [election_event!]!
}

"""
aggregate fields of "sequent_backend.election_event"
"""
type election_event_aggregate_fields {
  count(columns: [election_event_select_column!], distinct: Boolean): Int!
  max: election_event_max_fields
  min: election_event_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input election_event_append_input {
  annotations: jsonb
  bulletin_board_reference: jsonb
  labels: jsonb
  presentation: jsonb
  statistics: jsonb
  status: jsonb
  voting_channels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.election_event". All fields are combined with a logical 'AND'.
"""
input election_event_bool_exp {
  _and: [election_event_bool_exp!]
  _not: election_event_bool_exp
  _or: [election_event_bool_exp!]
  alias: String_comparison_exp
  annotations: jsonb_comparison_exp
  audit_election_event_id: uuid_comparison_exp
  bulletin_board_reference: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  elections: election_bool_exp
  elections_aggregate: election_aggregate_bool_exp
  encryption_protocol: String_comparison_exp
  id: uuid_comparison_exp
  is_archived: Boolean_comparison_exp
  is_audit: Boolean_comparison_exp
  labels: jsonb_comparison_exp
  name: String_comparison_exp
  presentation: jsonb_comparison_exp
  public_key: String_comparison_exp
  statistics: jsonb_comparison_exp
  status: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_boards: String_comparison_exp
  voting_channels: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.election_event"
"""
enum election_event_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input election_event_delete_at_path_input {
  annotations: [String!]
  bulletin_board_reference: [String!]
  labels: [String!]
  presentation: [String!]
  statistics: [String!]
  status: [String!]
  voting_channels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input election_event_delete_elem_input {
  annotations: Int
  bulletin_board_reference: Int
  labels: Int
  presentation: Int
  statistics: Int
  status: Int
  voting_channels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input election_event_delete_key_input {
  annotations: String
  bulletin_board_reference: String
  labels: String
  presentation: String
  statistics: String
  status: String
  voting_channels: String
}

"""
input type for inserting data into table "sequent_backend.election_event"
"""
input election_event_insert_input {
  alias: String
  annotations: jsonb
  audit_election_event_id: uuid
  bulletin_board_reference: jsonb
  created_at: timestamptz
  description: String
  elections: election_arr_rel_insert_input
  encryption_protocol: String
  id: uuid
  is_archived: Boolean
  is_audit: Boolean
  labels: jsonb
  name: String
  presentation: jsonb
  public_key: String
  statistics: jsonb
  status: jsonb
  tenant_id: uuid
  updated_at: timestamptz
  user_boards: String
  voting_channels: jsonb
}

"""aggregate max on columns"""
type election_event_max_fields {
  alias: String
  audit_election_event_id: uuid
  created_at: timestamptz
  description: String
  encryption_protocol: String
  id: uuid
  name: String
  public_key: String
  tenant_id: uuid
  updated_at: timestamptz
  user_boards: String
}

"""aggregate min on columns"""
type election_event_min_fields {
  alias: String
  audit_election_event_id: uuid
  created_at: timestamptz
  description: String
  encryption_protocol: String
  id: uuid
  name: String
  public_key: String
  tenant_id: uuid
  updated_at: timestamptz
  user_boards: String
}

"""
response of any mutation on the table "sequent_backend.election_event"
"""
type election_event_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [election_event!]!
}

"""
on_conflict condition type for table "sequent_backend.election_event"
"""
input election_event_on_conflict {
  constraint: election_event_constraint!
  update_columns: [election_event_update_column!]! = []
  where: election_event_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.election_event".
"""
input election_event_order_by {
  alias: order_by
  annotations: order_by
  audit_election_event_id: order_by
  bulletin_board_reference: order_by
  created_at: order_by
  description: order_by
  elections_aggregate: election_aggregate_order_by
  encryption_protocol: order_by
  id: order_by
  is_archived: order_by
  is_audit: order_by
  labels: order_by
  name: order_by
  presentation: order_by
  public_key: order_by
  statistics: order_by
  status: order_by
  tenant_id: order_by
  updated_at: order_by
  user_boards: order_by
  voting_channels: order_by
}

"""primary key columns input for table: sequent_backend.election_event"""
input election_event_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input election_event_prepend_input {
  annotations: jsonb
  bulletin_board_reference: jsonb
  labels: jsonb
  presentation: jsonb
  statistics: jsonb
  status: jsonb
  voting_channels: jsonb
}

"""
select columns of table "sequent_backend.election_event"
"""
enum election_event_select_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  audit_election_event_id
  """column name"""
  bulletin_board_reference
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  encryption_protocol
  """column name"""
  id
  """column name"""
  is_archived
  """column name"""
  is_audit
  """column name"""
  labels
  """column name"""
  name
  """column name"""
  presentation
  """column name"""
  public_key
  """column name"""
  statistics
  """column name"""
  status
  """column name"""
  tenant_id
  """column name"""
  updated_at
  """column name"""
  user_boards
  """column name"""
  voting_channels
}

"""
input type for updating data in table "sequent_backend.election_event"
"""
input election_event_set_input {
  alias: String
  annotations: jsonb
  audit_election_event_id: uuid
  bulletin_board_reference: jsonb
  created_at: timestamptz
  description: String
  encryption_protocol: String
  id: uuid
  is_archived: Boolean
  is_audit: Boolean
  labels: jsonb
  name: String
  presentation: jsonb
  public_key: String
  statistics: jsonb
  status: jsonb
  tenant_id: uuid
  updated_at: timestamptz
  user_boards: String
  voting_channels: jsonb
}

"""
Streaming cursor of the table "sequent_backend_election_event"
"""
input election_event_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: election_event_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input election_event_stream_cursor_value_input {
  alias: String
  annotations: jsonb
  audit_election_event_id: uuid
  bulletin_board_reference: jsonb
  created_at: timestamptz
  description: String
  encryption_protocol: String
  id: uuid
  is_archived: Boolean
  is_audit: Boolean
  labels: jsonb
  name: String
  presentation: jsonb
  public_key: String
  statistics: jsonb
  status: jsonb
  tenant_id: uuid
  updated_at: timestamptz
  user_boards: String
  voting_channels: jsonb
}

"""
update columns of table "sequent_backend.election_event"
"""
enum election_event_update_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  audit_election_event_id
  """column name"""
  bulletin_board_reference
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  encryption_protocol
  """column name"""
  id
  """column name"""
  is_archived
  """column name"""
  is_audit
  """column name"""
  labels
  """column name"""
  name
  """column name"""
  presentation
  """column name"""
  public_key
  """column name"""
  statistics
  """column name"""
  status
  """column name"""
  tenant_id
  """column name"""
  updated_at
  """column name"""
  user_boards
  """column name"""
  voting_channels
}

input election_event_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: election_event_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: election_event_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: election_event_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: election_event_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: election_event_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: election_event_set_input
  """filter the rows which have to be updated"""
  where: election_event_bool_exp!
}

"""
input type for incrementing numeric columns in table "sequent_backend.election"
"""
input election_inc_input {
  num_allowed_revotes: Int
}

"""
input type for inserting data into table "sequent_backend.election"
"""
input election_insert_input {
  alias: String
  annotations: jsonb
  contests: contest_arr_rel_insert_input
  created_at: timestamptz
  description: String
  election_event_id: uuid
  eml: String
  id: uuid
  image_document_id: String
  initialization_report_generated: Boolean
  is_consolidated_ballot_encoding: Boolean
  is_kiosk: Boolean
  keys_ceremony_id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  num_allowed_revotes: Int
  permission_label: String
  presentation: jsonb
  receipts: jsonb
  spoil_ballot_option: Boolean
  statistics: jsonb
  status: jsonb
  tenant_id: uuid
  voting_channels: jsonb
}

"""aggregate max on columns"""
type election_max_fields {
  alias: String
  created_at: timestamptz
  description: String
  election_event_id: uuid
  eml: String
  id: uuid
  image_document_id: String
  keys_ceremony_id: uuid
  last_updated_at: timestamptz
  name: String
  num_allowed_revotes: Int
  permission_label: String
  tenant_id: uuid
}

"""
order by max() on columns of table "sequent_backend.election"
"""
input election_max_order_by {
  alias: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  eml: order_by
  id: order_by
  image_document_id: order_by
  keys_ceremony_id: order_by
  last_updated_at: order_by
  name: order_by
  num_allowed_revotes: order_by
  permission_label: order_by
  tenant_id: order_by
}

"""aggregate min on columns"""
type election_min_fields {
  alias: String
  created_at: timestamptz
  description: String
  election_event_id: uuid
  eml: String
  id: uuid
  image_document_id: String
  keys_ceremony_id: uuid
  last_updated_at: timestamptz
  name: String
  num_allowed_revotes: Int
  permission_label: String
  tenant_id: uuid
}

"""
order by min() on columns of table "sequent_backend.election"
"""
input election_min_order_by {
  alias: order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  eml: order_by
  id: order_by
  image_document_id: order_by
  keys_ceremony_id: order_by
  last_updated_at: order_by
  name: order_by
  num_allowed_revotes: order_by
  permission_label: order_by
  tenant_id: order_by
}

"""
response of any mutation on the table "sequent_backend.election"
"""
type election_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [election!]!
}

"""
on_conflict condition type for table "sequent_backend.election"
"""
input election_on_conflict {
  constraint: election_constraint!
  update_columns: [election_update_column!]! = []
  where: election_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.election"."""
input election_order_by {
  alias: order_by
  annotations: order_by
  contests_aggregate: contest_aggregate_order_by
  created_at: order_by
  description: order_by
  election_event_id: order_by
  eml: order_by
  id: order_by
  image_document_id: order_by
  initialization_report_generated: order_by
  is_consolidated_ballot_encoding: order_by
  is_kiosk: order_by
  keys_ceremony_id: order_by
  labels: order_by
  last_updated_at: order_by
  name: order_by
  num_allowed_revotes: order_by
  permission_label: order_by
  presentation: order_by
  receipts: order_by
  spoil_ballot_option: order_by
  statistics: order_by
  status: order_by
  tenant_id: order_by
  voting_channels: order_by
}

"""primary key columns input for table: sequent_backend.election"""
input election_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input election_prepend_input {
  annotations: jsonb
  labels: jsonb
  presentation: jsonb
  receipts: jsonb
  statistics: jsonb
  status: jsonb
  voting_channels: jsonb
}

"""
columns and relationships of "sequent_backend.election_result"
"""
type election_result {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  result_eml: String
  result_eml_signature: bytea
  statistics(
    """JSON select path"""
    path: String
  ): jsonb
  tenant_id: uuid
}

"""
aggregated selection of "sequent_backend.election_result"
"""
type election_result_aggregate {
  aggregate: election_result_aggregate_fields
  nodes: [election_result!]!
}

"""
aggregate fields of "sequent_backend.election_result"
"""
type election_result_aggregate_fields {
  count(columns: [election_result_select_column!], distinct: Boolean): Int!
  max: election_result_max_fields
  min: election_result_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input election_result_append_input {
  annotations: jsonb
  labels: jsonb
  statistics: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.election_result". All fields are combined with a logical 'AND'.
"""
input election_result_bool_exp {
  _and: [election_result_bool_exp!]
  _not: election_result_bool_exp
  _or: [election_result_bool_exp!]
  annotations: jsonb_comparison_exp
  area_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  result_eml: String_comparison_exp
  result_eml_signature: bytea_comparison_exp
  statistics: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.election_result"
"""
enum election_result_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  election_result_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input election_result_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
  statistics: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input election_result_delete_elem_input {
  annotations: Int
  labels: Int
  statistics: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input election_result_delete_key_input {
  annotations: String
  labels: String
  statistics: String
}

"""
input type for inserting data into table "sequent_backend.election_result"
"""
input election_result_insert_input {
  annotations: jsonb
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  result_eml: String
  result_eml_signature: bytea
  statistics: jsonb
  tenant_id: uuid
}

"""aggregate max on columns"""
type election_result_max_fields {
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  result_eml: String
  tenant_id: uuid
}

"""aggregate min on columns"""
type election_result_min_fields {
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  result_eml: String
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.election_result"
"""
type election_result_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [election_result!]!
}

"""
on_conflict condition type for table "sequent_backend.election_result"
"""
input election_result_on_conflict {
  constraint: election_result_constraint!
  update_columns: [election_result_update_column!]! = []
  where: election_result_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.election_result".
"""
input election_result_order_by {
  annotations: order_by
  area_id: order_by
  created_at: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  result_eml: order_by
  result_eml_signature: order_by
  statistics: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.election_result"""
input election_result_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input election_result_prepend_input {
  annotations: jsonb
  labels: jsonb
  statistics: jsonb
}

"""
select columns of table "sequent_backend.election_result"
"""
enum election_result_select_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  result_eml
  """column name"""
  result_eml_signature
  """column name"""
  statistics
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.election_result"
"""
input election_result_set_input {
  annotations: jsonb
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  result_eml: String
  result_eml_signature: bytea
  statistics: jsonb
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_election_result"
"""
input election_result_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: election_result_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input election_result_stream_cursor_value_input {
  annotations: jsonb
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  result_eml: String
  result_eml_signature: bytea
  statistics: jsonb
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.election_result"
"""
enum election_result_update_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  result_eml
  """column name"""
  result_eml_signature
  """column name"""
  statistics
  """column name"""
  tenant_id
}

input election_result_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: election_result_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: election_result_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: election_result_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: election_result_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: election_result_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: election_result_set_input
  """filter the rows which have to be updated"""
  where: election_result_bool_exp!
}

"""
select columns of table "sequent_backend.election"
"""
enum election_select_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  election_event_id
  """column name"""
  eml
  """column name"""
  id
  """column name"""
  image_document_id
  """column name"""
  initialization_report_generated
  """column name"""
  is_consolidated_ballot_encoding
  """column name"""
  is_kiosk
  """column name"""
  keys_ceremony_id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  num_allowed_revotes
  """column name"""
  permission_label
  """column name"""
  presentation
  """column name"""
  receipts
  """column name"""
  spoil_ballot_option
  """column name"""
  statistics
  """column name"""
  status
  """column name"""
  tenant_id
  """column name"""
  voting_channels
}

"""
select "sequent_backend_election_aggregate_bool_exp_bool_and_arguments_columns" columns of table "sequent_backend.election"
"""
enum election_select_column_sequent_backend_election_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  initialization_report_generated
  """column name"""
  is_consolidated_ballot_encoding
  """column name"""
  is_kiosk
  """column name"""
  spoil_ballot_option
}

"""
select "sequent_backend_election_aggregate_bool_exp_bool_or_arguments_columns" columns of table "sequent_backend.election"
"""
enum election_select_column_sequent_backend_election_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  initialization_report_generated
  """column name"""
  is_consolidated_ballot_encoding
  """column name"""
  is_kiosk
  """column name"""
  spoil_ballot_option
}

"""
input type for updating data in table "sequent_backend.election"
"""
input election_set_input {
  alias: String
  annotations: jsonb
  created_at: timestamptz
  description: String
  election_event_id: uuid
  eml: String
  id: uuid
  image_document_id: String
  initialization_report_generated: Boolean
  is_consolidated_ballot_encoding: Boolean
  is_kiosk: Boolean
  keys_ceremony_id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  num_allowed_revotes: Int
  permission_label: String
  presentation: jsonb
  receipts: jsonb
  spoil_ballot_option: Boolean
  statistics: jsonb
  status: jsonb
  tenant_id: uuid
  voting_channels: jsonb
}

"""aggregate stddev on columns"""
type election_stddev_fields {
  num_allowed_revotes: Float
}

"""
order by stddev() on columns of table "sequent_backend.election"
"""
input election_stddev_order_by {
  num_allowed_revotes: order_by
}

"""aggregate stddev_pop on columns"""
type election_stddev_pop_fields {
  num_allowed_revotes: Float
}

"""
order by stddev_pop() on columns of table "sequent_backend.election"
"""
input election_stddev_pop_order_by {
  num_allowed_revotes: order_by
}

"""aggregate stddev_samp on columns"""
type election_stddev_samp_fields {
  num_allowed_revotes: Float
}

"""
order by stddev_samp() on columns of table "sequent_backend.election"
"""
input election_stddev_samp_order_by {
  num_allowed_revotes: order_by
}

"""
Streaming cursor of the table "sequent_backend_election"
"""
input election_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: election_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input election_stream_cursor_value_input {
  alias: String
  annotations: jsonb
  created_at: timestamptz
  description: String
  election_event_id: uuid
  eml: String
  id: uuid
  image_document_id: String
  initialization_report_generated: Boolean
  is_consolidated_ballot_encoding: Boolean
  is_kiosk: Boolean
  keys_ceremony_id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  num_allowed_revotes: Int
  permission_label: String
  presentation: jsonb
  receipts: jsonb
  spoil_ballot_option: Boolean
  statistics: jsonb
  status: jsonb
  tenant_id: uuid
  voting_channels: jsonb
}

"""aggregate sum on columns"""
type election_sum_fields {
  num_allowed_revotes: Int
}

"""
order by sum() on columns of table "sequent_backend.election"
"""
input election_sum_order_by {
  num_allowed_revotes: order_by
}

"""
columns and relationships of "sequent_backend.election_type"
"""
type election_type {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  name: String!
  tenant_id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "sequent_backend.election_type"
"""
type election_type_aggregate {
  aggregate: election_type_aggregate_fields
  nodes: [election_type!]!
}

"""
aggregate fields of "sequent_backend.election_type"
"""
type election_type_aggregate_fields {
  count(columns: [election_type_select_column!], distinct: Boolean): Int!
  max: election_type_max_fields
  min: election_type_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input election_type_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.election_type". All fields are combined with a logical 'AND'.
"""
input election_type_bool_exp {
  _and: [election_type_bool_exp!]
  _not: election_type_bool_exp
  _or: [election_type_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  name: String_comparison_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.election_type"
"""
enum election_type_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  election_type_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input election_type_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input election_type_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input election_type_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.election_type"
"""
input election_type_insert_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  labels: jsonb
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type election_type_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type election_type_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "sequent_backend.election_type"
"""
type election_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [election_type!]!
}

"""
on_conflict condition type for table "sequent_backend.election_type"
"""
input election_type_on_conflict {
  constraint: election_type_constraint!
  update_columns: [election_type_update_column!]! = []
  where: election_type_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.election_type".
"""
input election_type_order_by {
  annotations: order_by
  created_at: order_by
  id: order_by
  labels: order_by
  name: order_by
  tenant_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: sequent_backend.election_type"""
input election_type_pk_columns_input {
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input election_type_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.election_type"
"""
enum election_type_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  name
  """column name"""
  tenant_id
  """column name"""
  updated_at
}

"""
input type for updating data in table "sequent_backend.election_type"
"""
input election_type_set_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  labels: jsonb
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "sequent_backend_election_type"
"""
input election_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: election_type_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input election_type_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  labels: jsonb
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "sequent_backend.election_type"
"""
enum election_type_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  name
  """column name"""
  tenant_id
  """column name"""
  updated_at
}

input election_type_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: election_type_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: election_type_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: election_type_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: election_type_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: election_type_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: election_type_set_input
  """filter the rows which have to be updated"""
  where: election_type_bool_exp!
}

"""
update columns of table "sequent_backend.election"
"""
enum election_update_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  description
  """column name"""
  election_event_id
  """column name"""
  eml
  """column name"""
  id
  """column name"""
  image_document_id
  """column name"""
  initialization_report_generated
  """column name"""
  is_consolidated_ballot_encoding
  """column name"""
  is_kiosk
  """column name"""
  keys_ceremony_id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  num_allowed_revotes
  """column name"""
  permission_label
  """column name"""
  presentation
  """column name"""
  receipts
  """column name"""
  spoil_ballot_option
  """column name"""
  statistics
  """column name"""
  status
  """column name"""
  tenant_id
  """column name"""
  voting_channels
}

input election_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: election_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: election_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: election_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: election_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: election_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: election_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: election_set_input
  """filter the rows which have to be updated"""
  where: election_bool_exp!
}

"""aggregate var_pop on columns"""
type election_var_pop_fields {
  num_allowed_revotes: Float
}

"""
order by var_pop() on columns of table "sequent_backend.election"
"""
input election_var_pop_order_by {
  num_allowed_revotes: order_by
}

"""aggregate var_samp on columns"""
type election_var_samp_fields {
  num_allowed_revotes: Float
}

"""
order by var_samp() on columns of table "sequent_backend.election"
"""
input election_var_samp_order_by {
  num_allowed_revotes: order_by
}

"""aggregate variance on columns"""
type election_variance_fields {
  num_allowed_revotes: Float
}

"""
order by variance() on columns of table "sequent_backend.election"
"""
input election_variance_order_by {
  num_allowed_revotes: order_by
}

"""
columns and relationships of "sequent_backend.event_execution"
"""
type event_execution {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid
  ended_at: timestamptz
  execution_payload(
    """JSON select path"""
    path: String
  ): jsonb
  execution_state: String
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  result_payload(
    """JSON select path"""
    path: String
  ): jsonb
  scheduled_event_id: uuid!
  started_at: timestamptz
  tenant_id: uuid
}

"""
aggregated selection of "sequent_backend.event_execution"
"""
type event_execution_aggregate {
  aggregate: event_execution_aggregate_fields
  nodes: [event_execution!]!
}

"""
aggregate fields of "sequent_backend.event_execution"
"""
type event_execution_aggregate_fields {
  count(columns: [event_execution_select_column!], distinct: Boolean): Int!
  max: event_execution_max_fields
  min: event_execution_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input event_execution_append_input {
  annotations: jsonb
  execution_payload: jsonb
  labels: jsonb
  result_payload: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.event_execution". All fields are combined with a logical 'AND'.
"""
input event_execution_bool_exp {
  _and: [event_execution_bool_exp!]
  _not: event_execution_bool_exp
  _or: [event_execution_bool_exp!]
  annotations: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  ended_at: timestamptz_comparison_exp
  execution_payload: jsonb_comparison_exp
  execution_state: String_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  result_payload: jsonb_comparison_exp
  scheduled_event_id: uuid_comparison_exp
  started_at: timestamptz_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.event_execution"
"""
enum event_execution_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_execution_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input event_execution_delete_at_path_input {
  annotations: [String!]
  execution_payload: [String!]
  labels: [String!]
  result_payload: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input event_execution_delete_elem_input {
  annotations: Int
  execution_payload: Int
  labels: Int
  result_payload: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input event_execution_delete_key_input {
  annotations: String
  execution_payload: String
  labels: String
  result_payload: String
}

"""
input type for inserting data into table "sequent_backend.event_execution"
"""
input event_execution_insert_input {
  annotations: jsonb
  election_event_id: uuid
  ended_at: timestamptz
  execution_payload: jsonb
  execution_state: String
  id: uuid
  labels: jsonb
  result_payload: jsonb
  scheduled_event_id: uuid
  started_at: timestamptz
  tenant_id: uuid
}

"""aggregate max on columns"""
type event_execution_max_fields {
  election_event_id: uuid
  ended_at: timestamptz
  execution_state: String
  id: uuid
  scheduled_event_id: uuid
  started_at: timestamptz
  tenant_id: uuid
}

"""aggregate min on columns"""
type event_execution_min_fields {
  election_event_id: uuid
  ended_at: timestamptz
  execution_state: String
  id: uuid
  scheduled_event_id: uuid
  started_at: timestamptz
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.event_execution"
"""
type event_execution_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [event_execution!]!
}

"""
on_conflict condition type for table "sequent_backend.event_execution"
"""
input event_execution_on_conflict {
  constraint: event_execution_constraint!
  update_columns: [event_execution_update_column!]! = []
  where: event_execution_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.event_execution".
"""
input event_execution_order_by {
  annotations: order_by
  election_event_id: order_by
  ended_at: order_by
  execution_payload: order_by
  execution_state: order_by
  id: order_by
  labels: order_by
  result_payload: order_by
  scheduled_event_id: order_by
  started_at: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.event_execution"""
input event_execution_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input event_execution_prepend_input {
  annotations: jsonb
  execution_payload: jsonb
  labels: jsonb
  result_payload: jsonb
}

"""
select columns of table "sequent_backend.event_execution"
"""
enum event_execution_select_column {
  """column name"""
  annotations
  """column name"""
  election_event_id
  """column name"""
  ended_at
  """column name"""
  execution_payload
  """column name"""
  execution_state
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  result_payload
  """column name"""
  scheduled_event_id
  """column name"""
  started_at
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.event_execution"
"""
input event_execution_set_input {
  annotations: jsonb
  election_event_id: uuid
  ended_at: timestamptz
  execution_payload: jsonb
  execution_state: String
  id: uuid
  labels: jsonb
  result_payload: jsonb
  scheduled_event_id: uuid
  started_at: timestamptz
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_event_execution"
"""
input event_execution_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: event_execution_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input event_execution_stream_cursor_value_input {
  annotations: jsonb
  election_event_id: uuid
  ended_at: timestamptz
  execution_payload: jsonb
  execution_state: String
  id: uuid
  labels: jsonb
  result_payload: jsonb
  scheduled_event_id: uuid
  started_at: timestamptz
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.event_execution"
"""
enum event_execution_update_column {
  """column name"""
  annotations
  """column name"""
  election_event_id
  """column name"""
  ended_at
  """column name"""
  execution_payload
  """column name"""
  execution_state
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  result_payload
  """column name"""
  scheduled_event_id
  """column name"""
  started_at
  """column name"""
  tenant_id
}

input event_execution_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: event_execution_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: event_execution_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: event_execution_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: event_execution_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: event_execution_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: event_execution_set_input
  """filter the rows which have to be updated"""
  where: event_execution_bool_exp!
}

"""
columns and relationships of "sequent_backend.keys_ceremony"
"""
type keys_ceremony {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  election_event_id: uuid!
  execution_status: String
  id: uuid!
  is_default: Boolean
  """An array relationship"""
  keys_ceremony_trustee_ids(
    """distinct select on columns"""
    distinct_on: [trustee_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [trustee_order_by!]
    """filter the rows returned"""
    where: trustee_bool_exp
  ): [trustee!]!
  """An aggregate relationship"""
  keys_ceremony_trustee_ids_aggregate(
    """distinct select on columns"""
    distinct_on: [trustee_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [trustee_order_by!]
    """filter the rows returned"""
    where: trustee_bool_exp
  ): trustee_aggregate!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz!
  name: String
  permission_label: [String!]
  settings(
    """JSON select path"""
    path: String
  ): jsonb
  status(
    """JSON select path"""
    path: String
  ): jsonb
  tenant_id: uuid!
  threshold: Int!
  trustee_ids: [uuid!]!
}

"""
aggregated selection of "sequent_backend.keys_ceremony"
"""
type keys_ceremony_aggregate {
  aggregate: keys_ceremony_aggregate_fields
  nodes: [keys_ceremony!]!
}

"""
aggregate fields of "sequent_backend.keys_ceremony"
"""
type keys_ceremony_aggregate_fields {
  avg: keys_ceremony_avg_fields
  count(columns: [keys_ceremony_select_column!], distinct: Boolean): Int!
  max: keys_ceremony_max_fields
  min: keys_ceremony_min_fields
  stddev: keys_ceremony_stddev_fields
  stddev_pop: keys_ceremony_stddev_pop_fields
  stddev_samp: keys_ceremony_stddev_samp_fields
  sum: keys_ceremony_sum_fields
  var_pop: keys_ceremony_var_pop_fields
  var_samp: keys_ceremony_var_samp_fields
  variance: keys_ceremony_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input keys_ceremony_append_input {
  annotations: jsonb
  labels: jsonb
  settings: jsonb
  status: jsonb
}

"""aggregate avg on columns"""
type keys_ceremony_avg_fields {
  threshold: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.keys_ceremony". All fields are combined with a logical 'AND'.
"""
input keys_ceremony_bool_exp {
  _and: [keys_ceremony_bool_exp!]
  _not: keys_ceremony_bool_exp
  _or: [keys_ceremony_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  execution_status: String_comparison_exp
  id: uuid_comparison_exp
  is_default: Boolean_comparison_exp
  keys_ceremony_trustee_ids: trustee_bool_exp
  keys_ceremony_trustee_ids_aggregate: trustee_aggregate_bool_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  permission_label: String_array_comparison_exp
  settings: jsonb_comparison_exp
  status: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
  threshold: Int_comparison_exp
  trustee_ids: uuid_array_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.keys_ceremony"
"""
enum keys_ceremony_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  keys_ceremony_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input keys_ceremony_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
  settings: [String!]
  status: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input keys_ceremony_delete_elem_input {
  annotations: Int
  labels: Int
  settings: Int
  status: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input keys_ceremony_delete_key_input {
  annotations: String
  labels: String
  settings: String
  status: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.keys_ceremony"
"""
input keys_ceremony_inc_input {
  threshold: Int
}

"""
input type for inserting data into table "sequent_backend.keys_ceremony"
"""
input keys_ceremony_insert_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  execution_status: String
  id: uuid
  is_default: Boolean
  keys_ceremony_trustee_ids: trustee_arr_rel_insert_input
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  permission_label: [String!]
  settings: jsonb
  status: jsonb
  tenant_id: uuid
  threshold: Int
  trustee_ids: [uuid!]
}

"""aggregate max on columns"""
type keys_ceremony_max_fields {
  created_at: timestamptz
  election_event_id: uuid
  execution_status: String
  id: uuid
  last_updated_at: timestamptz
  name: String
  permission_label: [String!]
  tenant_id: uuid
  threshold: Int
  trustee_ids: [uuid!]
}

"""aggregate min on columns"""
type keys_ceremony_min_fields {
  created_at: timestamptz
  election_event_id: uuid
  execution_status: String
  id: uuid
  last_updated_at: timestamptz
  name: String
  permission_label: [String!]
  tenant_id: uuid
  threshold: Int
  trustee_ids: [uuid!]
}

"""
response of any mutation on the table "sequent_backend.keys_ceremony"
"""
type keys_ceremony_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [keys_ceremony!]!
}

"""
on_conflict condition type for table "sequent_backend.keys_ceremony"
"""
input keys_ceremony_on_conflict {
  constraint: keys_ceremony_constraint!
  update_columns: [keys_ceremony_update_column!]! = []
  where: keys_ceremony_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.keys_ceremony".
"""
input keys_ceremony_order_by {
  annotations: order_by
  created_at: order_by
  election_event_id: order_by
  execution_status: order_by
  id: order_by
  is_default: order_by
  keys_ceremony_trustee_ids_aggregate: trustee_aggregate_order_by
  labels: order_by
  last_updated_at: order_by
  name: order_by
  permission_label: order_by
  settings: order_by
  status: order_by
  tenant_id: order_by
  threshold: order_by
  trustee_ids: order_by
}

"""primary key columns input for table: sequent_backend.keys_ceremony"""
input keys_ceremony_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input keys_ceremony_prepend_input {
  annotations: jsonb
  labels: jsonb
  settings: jsonb
  status: jsonb
}

"""
select columns of table "sequent_backend.keys_ceremony"
"""
enum keys_ceremony_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  execution_status
  """column name"""
  id
  """column name"""
  is_default
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  permission_label
  """column name"""
  settings
  """column name"""
  status
  """column name"""
  tenant_id
  """column name"""
  threshold
  """column name"""
  trustee_ids
}

"""
input type for updating data in table "sequent_backend.keys_ceremony"
"""
input keys_ceremony_set_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  execution_status: String
  id: uuid
  is_default: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  permission_label: [String!]
  settings: jsonb
  status: jsonb
  tenant_id: uuid
  threshold: Int
  trustee_ids: [uuid!]
}

"""aggregate stddev on columns"""
type keys_ceremony_stddev_fields {
  threshold: Float
}

"""aggregate stddev_pop on columns"""
type keys_ceremony_stddev_pop_fields {
  threshold: Float
}

"""aggregate stddev_samp on columns"""
type keys_ceremony_stddev_samp_fields {
  threshold: Float
}

"""
Streaming cursor of the table "sequent_backend_keys_ceremony"
"""
input keys_ceremony_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: keys_ceremony_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input keys_ceremony_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  execution_status: String
  id: uuid
  is_default: Boolean
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  permission_label: [String!]
  settings: jsonb
  status: jsonb
  tenant_id: uuid
  threshold: Int
  trustee_ids: [uuid!]
}

"""aggregate sum on columns"""
type keys_ceremony_sum_fields {
  threshold: Int
}

"""
update columns of table "sequent_backend.keys_ceremony"
"""
enum keys_ceremony_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  execution_status
  """column name"""
  id
  """column name"""
  is_default
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  permission_label
  """column name"""
  settings
  """column name"""
  status
  """column name"""
  tenant_id
  """column name"""
  threshold
  """column name"""
  trustee_ids
}

input keys_ceremony_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: keys_ceremony_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: keys_ceremony_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: keys_ceremony_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: keys_ceremony_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: keys_ceremony_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: keys_ceremony_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: keys_ceremony_set_input
  """filter the rows which have to be updated"""
  where: keys_ceremony_bool_exp!
}

"""aggregate var_pop on columns"""
type keys_ceremony_var_pop_fields {
  threshold: Float
}

"""aggregate var_samp on columns"""
type keys_ceremony_var_samp_fields {
  threshold: Float
}

"""aggregate variance on columns"""
type keys_ceremony_variance_fields {
  threshold: Float
}

"""
columns and relationships of "sequent_backend.lock"
"""
type lock {
  created_at: timestamptz!
  expiry_date: timestamptz
  key: String!
  last_updated_at: timestamptz
  value: String!
}

"""
aggregated selection of "sequent_backend.lock"
"""
type lock_aggregate {
  aggregate: lock_aggregate_fields
  nodes: [lock!]!
}

"""
aggregate fields of "sequent_backend.lock"
"""
type lock_aggregate_fields {
  count(columns: [lock_select_column!], distinct: Boolean): Int!
  max: lock_max_fields
  min: lock_min_fields
}

"""
Boolean expression to filter rows from the table "sequent_backend.lock". All fields are combined with a logical 'AND'.
"""
input lock_bool_exp {
  _and: [lock_bool_exp!]
  _not: lock_bool_exp
  _or: [lock_bool_exp!]
  created_at: timestamptz_comparison_exp
  expiry_date: timestamptz_comparison_exp
  key: String_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.lock"
"""
enum lock_constraint {
  """
  unique or primary key constraint on columns "key"
  """
  lock_pkey
}

"""
input type for inserting data into table "sequent_backend.lock"
"""
input lock_insert_input {
  created_at: timestamptz
  expiry_date: timestamptz
  key: String
  last_updated_at: timestamptz
  value: String
}

"""aggregate max on columns"""
type lock_max_fields {
  created_at: timestamptz
  expiry_date: timestamptz
  key: String
  last_updated_at: timestamptz
  value: String
}

"""aggregate min on columns"""
type lock_min_fields {
  created_at: timestamptz
  expiry_date: timestamptz
  key: String
  last_updated_at: timestamptz
  value: String
}

"""
response of any mutation on the table "sequent_backend.lock"
"""
type lock_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [lock!]!
}

"""
on_conflict condition type for table "sequent_backend.lock"
"""
input lock_on_conflict {
  constraint: lock_constraint!
  update_columns: [lock_update_column!]! = []
  where: lock_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.lock"."""
input lock_order_by {
  created_at: order_by
  expiry_date: order_by
  key: order_by
  last_updated_at: order_by
  value: order_by
}

"""primary key columns input for table: sequent_backend.lock"""
input lock_pk_columns_input {
  key: String!
}

"""
select columns of table "sequent_backend.lock"
"""
enum lock_select_column {
  """column name"""
  created_at
  """column name"""
  expiry_date
  """column name"""
  key
  """column name"""
  last_updated_at
  """column name"""
  value
}

"""
input type for updating data in table "sequent_backend.lock"
"""
input lock_set_input {
  created_at: timestamptz
  expiry_date: timestamptz
  key: String
  last_updated_at: timestamptz
  value: String
}

"""
Streaming cursor of the table "sequent_backend_lock"
"""
input lock_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: lock_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input lock_stream_cursor_value_input {
  created_at: timestamptz
  expiry_date: timestamptz
  key: String
  last_updated_at: timestamptz
  value: String
}

"""
update columns of table "sequent_backend.lock"
"""
enum lock_update_column {
  """column name"""
  created_at
  """column name"""
  expiry_date
  """column name"""
  key
  """column name"""
  last_updated_at
  """column name"""
  value
}

input lock_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: lock_set_input
  """filter the rows which have to be updated"""
  where: lock_bool_exp!
}

"""
columns and relationships of "sequent_backend.notification"
"""
type notification {
  alias: String
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  election_event_id: uuid!
  election_id: uuid
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  name: String
  template_id: uuid
  tenant_id: uuid!
  type: String
  updated_at: timestamptz!
}

"""
aggregated selection of "sequent_backend.notification"
"""
type notification_aggregate {
  aggregate: notification_aggregate_fields
  nodes: [notification!]!
}

"""
aggregate fields of "sequent_backend.notification"
"""
type notification_aggregate_fields {
  count(columns: [notification_select_column!], distinct: Boolean): Int!
  max: notification_max_fields
  min: notification_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input notification_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.notification". All fields are combined with a logical 'AND'.
"""
input notification_bool_exp {
  _and: [notification_bool_exp!]
  _not: notification_bool_exp
  _or: [notification_bool_exp!]
  alias: String_comparison_exp
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  name: String_comparison_exp
  template_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.notification"
"""
enum notification_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notification_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input notification_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input notification_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input notification_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.notification"
"""
input notification_insert_input {
  alias: String
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  name: String
  template_id: uuid
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type notification_max_fields {
  alias: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  name: String
  template_id: uuid
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type notification_min_fields {
  alias: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  name: String
  template_id: uuid
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "sequent_backend.notification"
"""
type notification_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [notification!]!
}

"""
on_conflict condition type for table "sequent_backend.notification"
"""
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]! = []
  where: notification_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.notification".
"""
input notification_order_by {
  alias: order_by
  annotations: order_by
  created_at: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  labels: order_by
  name: order_by
  template_id: order_by
  tenant_id: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: sequent_backend.notification"""
input notification_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input notification_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.notification"
"""
enum notification_select_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  name
  """column name"""
  template_id
  """column name"""
  tenant_id
  """column name"""
  type
  """column name"""
  updated_at
}

"""
input type for updating data in table "sequent_backend.notification"
"""
input notification_set_input {
  alias: String
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  name: String
  template_id: uuid
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "sequent_backend_notification"
"""
input notification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notification_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notification_stream_cursor_value_input {
  alias: String
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  name: String
  template_id: uuid
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""
update columns of table "sequent_backend.notification"
"""
enum notification_update_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  name
  """column name"""
  template_id
  """column name"""
  tenant_id
  """column name"""
  type
  """column name"""
  updated_at
}

input notification_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: notification_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: notification_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: notification_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: notification_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: notification_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: notification_set_input
  """filter the rows which have to be updated"""
  where: notification_bool_exp!
}

"""
columns and relationships of "sequent_backend.report"
"""
type report {
  created_at: timestamptz
  cron_config(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  election_id: uuid
  encryption_policy: String!
  id: uuid!
  permission_label: [String!]
  report_type: String!
  template_alias: String
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.report"
"""
type report_aggregate {
  aggregate: report_aggregate_fields
  nodes: [report!]!
}

"""
aggregate fields of "sequent_backend.report"
"""
type report_aggregate_fields {
  count(columns: [report_select_column!], distinct: Boolean): Int!
  max: report_max_fields
  min: report_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input report_append_input {
  cron_config: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.report". All fields are combined with a logical 'AND'.
"""
input report_bool_exp {
  _and: [report_bool_exp!]
  _not: report_bool_exp
  _or: [report_bool_exp!]
  created_at: timestamptz_comparison_exp
  cron_config: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  encryption_policy: String_comparison_exp
  id: uuid_comparison_exp
  permission_label: String_array_comparison_exp
  report_type: String_comparison_exp
  template_alias: String_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.report"
"""
enum report_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  report_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input report_delete_at_path_input {
  cron_config: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input report_delete_elem_input {
  cron_config: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input report_delete_key_input {
  cron_config: String
}

"""
input type for inserting data into table "sequent_backend.report"
"""
input report_insert_input {
  created_at: timestamptz
  cron_config: jsonb
  election_event_id: uuid
  election_id: uuid
  encryption_policy: String
  id: uuid
  permission_label: [String!]
  report_type: String
  template_alias: String
  tenant_id: uuid
}

"""aggregate max on columns"""
type report_max_fields {
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  encryption_policy: String
  id: uuid
  permission_label: [String!]
  report_type: String
  template_alias: String
  tenant_id: uuid
}

"""aggregate min on columns"""
type report_min_fields {
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  encryption_policy: String
  id: uuid
  permission_label: [String!]
  report_type: String
  template_alias: String
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.report"
"""
type report_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [report!]!
}

"""
on_conflict condition type for table "sequent_backend.report"
"""
input report_on_conflict {
  constraint: report_constraint!
  update_columns: [report_update_column!]! = []
  where: report_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.report"."""
input report_order_by {
  created_at: order_by
  cron_config: order_by
  election_event_id: order_by
  election_id: order_by
  encryption_policy: order_by
  id: order_by
  permission_label: order_by
  report_type: order_by
  template_alias: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.report"""
input report_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input report_prepend_input {
  cron_config: jsonb
}

"""
select columns of table "sequent_backend.report"
"""
enum report_select_column {
  """column name"""
  created_at
  """column name"""
  cron_config
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  encryption_policy
  """column name"""
  id
  """column name"""
  permission_label
  """column name"""
  report_type
  """column name"""
  template_alias
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.report"
"""
input report_set_input {
  created_at: timestamptz
  cron_config: jsonb
  election_event_id: uuid
  election_id: uuid
  encryption_policy: String
  id: uuid
  permission_label: [String!]
  report_type: String
  template_alias: String
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_report"
"""
input report_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: report_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input report_stream_cursor_value_input {
  created_at: timestamptz
  cron_config: jsonb
  election_event_id: uuid
  election_id: uuid
  encryption_policy: String
  id: uuid
  permission_label: [String!]
  report_type: String
  template_alias: String
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.report"
"""
enum report_update_column {
  """column name"""
  created_at
  """column name"""
  cron_config
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  encryption_policy
  """column name"""
  id
  """column name"""
  permission_label
  """column name"""
  report_type
  """column name"""
  template_alias
  """column name"""
  tenant_id
}

input report_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: report_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: report_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: report_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: report_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: report_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: report_set_input
  """filter the rows which have to be updated"""
  where: report_bool_exp!
}

"""
columns and relationships of "sequent_backend.results_area_contest"
"""
type results_area_contest {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  area_id: uuid!
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid!
  created_at: timestamptz
  documents(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  election_id: uuid!
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid!
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  results_event_id: uuid!
  tenant_id: uuid!
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""
aggregated selection of "sequent_backend.results_area_contest"
"""
type results_area_contest_aggregate {
  aggregate: results_area_contest_aggregate_fields
  nodes: [results_area_contest!]!
}

"""
aggregate fields of "sequent_backend.results_area_contest"
"""
type results_area_contest_aggregate_fields {
  avg: results_area_contest_avg_fields
  count(columns: [results_area_contest_select_column!], distinct: Boolean): Int!
  max: results_area_contest_max_fields
  min: results_area_contest_min_fields
  stddev: results_area_contest_stddev_fields
  stddev_pop: results_area_contest_stddev_pop_fields
  stddev_samp: results_area_contest_stddev_samp_fields
  sum: results_area_contest_sum_fields
  var_pop: results_area_contest_var_pop_fields
  var_samp: results_area_contest_var_samp_fields
  variance: results_area_contest_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input results_area_contest_append_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""aggregate avg on columns"""
type results_area_contest_avg_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.results_area_contest". All fields are combined with a logical 'AND'.
"""
input results_area_contest_bool_exp {
  _and: [results_area_contest_bool_exp!]
  _not: results_area_contest_bool_exp
  _or: [results_area_contest_bool_exp!]
  annotations: jsonb_comparison_exp
  area_id: uuid_comparison_exp
  blank_votes: Int_comparison_exp
  blank_votes_percent: numeric_comparison_exp
  contest_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  documents: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  elegible_census: Int_comparison_exp
  explicit_invalid_votes: Int_comparison_exp
  explicit_invalid_votes_percent: numeric_comparison_exp
  id: uuid_comparison_exp
  implicit_invalid_votes: Int_comparison_exp
  implicit_invalid_votes_percent: numeric_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  results_event_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
  total_auditable_votes: Int_comparison_exp
  total_auditable_votes_percent: numeric_comparison_exp
  total_invalid_votes: Int_comparison_exp
  total_invalid_votes_percent: numeric_comparison_exp
  total_valid_votes: Int_comparison_exp
  total_valid_votes_percent: numeric_comparison_exp
  total_votes: Int_comparison_exp
  total_votes_percent: numeric_comparison_exp
}

"""
columns and relationships of "sequent_backend.results_area_contest_candidate"
"""
type results_area_contest_candidate {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  area_id: uuid!
  candidate_id: uuid!
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid!
  created_at: timestamptz
  documents(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  election_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid!
  tenant_id: uuid!
  winning_position: Int
}

"""
aggregated selection of "sequent_backend.results_area_contest_candidate"
"""
type results_area_contest_candidate_aggregate {
  aggregate: results_area_contest_candidate_aggregate_fields
  nodes: [results_area_contest_candidate!]!
}

"""
aggregate fields of "sequent_backend.results_area_contest_candidate"
"""
type results_area_contest_candidate_aggregate_fields {
  avg: results_area_contest_candidate_avg_fields
  count(columns: [results_area_contest_candidate_select_column!], distinct: Boolean): Int!
  max: results_area_contest_candidate_max_fields
  min: results_area_contest_candidate_min_fields
  stddev: results_area_contest_candidate_stddev_fields
  stddev_pop: results_area_contest_candidate_stddev_pop_fields
  stddev_samp: results_area_contest_candidate_stddev_samp_fields
  sum: results_area_contest_candidate_sum_fields
  var_pop: results_area_contest_candidate_var_pop_fields
  var_samp: results_area_contest_candidate_var_samp_fields
  variance: results_area_contest_candidate_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input results_area_contest_candidate_append_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""aggregate avg on columns"""
type results_area_contest_candidate_avg_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.results_area_contest_candidate". All fields are combined with a logical 'AND'.
"""
input results_area_contest_candidate_bool_exp {
  _and: [results_area_contest_candidate_bool_exp!]
  _not: results_area_contest_candidate_bool_exp
  _or: [results_area_contest_candidate_bool_exp!]
  annotations: jsonb_comparison_exp
  area_id: uuid_comparison_exp
  candidate_id: uuid_comparison_exp
  cast_votes: Int_comparison_exp
  cast_votes_percent: numeric_comparison_exp
  contest_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  documents: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  points: Int_comparison_exp
  results_event_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
  winning_position: Int_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.results_area_contest_candidate"
"""
enum results_area_contest_candidate_constraint {
  """
  unique or primary key constraint on columns "id", "results_event_id", "tenant_id", "election_event_id"
  """
  results_area_contest_candidate_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input results_area_contest_candidate_delete_at_path_input {
  annotations: [String!]
  documents: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input results_area_contest_candidate_delete_elem_input {
  annotations: Int
  documents: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input results_area_contest_candidate_delete_key_input {
  annotations: String
  documents: String
  labels: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.results_area_contest_candidate"
"""
input results_area_contest_candidate_inc_input {
  cast_votes: Int
  cast_votes_percent: numeric
  points: Int
  winning_position: Int
}

"""
input type for inserting data into table "sequent_backend.results_area_contest_candidate"
"""
input results_area_contest_candidate_insert_input {
  annotations: jsonb
  area_id: uuid
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""aggregate max on columns"""
type results_area_contest_candidate_max_fields {
  area_id: uuid
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""aggregate min on columns"""
type results_area_contest_candidate_min_fields {
  area_id: uuid
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""
response of any mutation on the table "sequent_backend.results_area_contest_candidate"
"""
type results_area_contest_candidate_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [results_area_contest_candidate!]!
}

"""
on_conflict condition type for table "sequent_backend.results_area_contest_candidate"
"""
input results_area_contest_candidate_on_conflict {
  constraint: results_area_contest_candidate_constraint!
  update_columns: [results_area_contest_candidate_update_column!]! = []
  where: results_area_contest_candidate_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.results_area_contest_candidate".
"""
input results_area_contest_candidate_order_by {
  annotations: order_by
  area_id: order_by
  candidate_id: order_by
  cast_votes: order_by
  cast_votes_percent: order_by
  contest_id: order_by
  created_at: order_by
  documents: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  points: order_by
  results_event_id: order_by
  tenant_id: order_by
  winning_position: order_by
}

"""
primary key columns input for table: sequent_backend.results_area_contest_candidate
"""
input results_area_contest_candidate_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  results_event_id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input results_area_contest_candidate_prepend_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.results_area_contest_candidate"
"""
enum results_area_contest_candidate_select_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  candidate_id
  """column name"""
  cast_votes
  """column name"""
  cast_votes_percent
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  points
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  winning_position
}

"""
input type for updating data in table "sequent_backend.results_area_contest_candidate"
"""
input results_area_contest_candidate_set_input {
  annotations: jsonb
  area_id: uuid
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""aggregate stddev on columns"""
type results_area_contest_candidate_stddev_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""aggregate stddev_pop on columns"""
type results_area_contest_candidate_stddev_pop_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""aggregate stddev_samp on columns"""
type results_area_contest_candidate_stddev_samp_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""
Streaming cursor of the table "sequent_backend_results_area_contest_candidate"
"""
input results_area_contest_candidate_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: results_area_contest_candidate_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input results_area_contest_candidate_stream_cursor_value_input {
  annotations: jsonb
  area_id: uuid
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""aggregate sum on columns"""
type results_area_contest_candidate_sum_fields {
  cast_votes: Int
  cast_votes_percent: numeric
  points: Int
  winning_position: Int
}

"""
update columns of table "sequent_backend.results_area_contest_candidate"
"""
enum results_area_contest_candidate_update_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  candidate_id
  """column name"""
  cast_votes
  """column name"""
  cast_votes_percent
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  points
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  winning_position
}

input results_area_contest_candidate_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: results_area_contest_candidate_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: results_area_contest_candidate_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: results_area_contest_candidate_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: results_area_contest_candidate_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: results_area_contest_candidate_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: results_area_contest_candidate_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: results_area_contest_candidate_set_input
  """filter the rows which have to be updated"""
  where: results_area_contest_candidate_bool_exp!
}

"""aggregate var_pop on columns"""
type results_area_contest_candidate_var_pop_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""aggregate var_samp on columns"""
type results_area_contest_candidate_var_samp_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""aggregate variance on columns"""
type results_area_contest_candidate_variance_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""
unique or primary key constraints on table "sequent_backend.results_area_contest"
"""
enum results_area_contest_constraint {
  """
  unique or primary key constraint on columns "id", "results_event_id", "tenant_id", "election_event_id"
  """
  results_area_contest_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input results_area_contest_delete_at_path_input {
  annotations: [String!]
  documents: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input results_area_contest_delete_elem_input {
  annotations: Int
  documents: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input results_area_contest_delete_key_input {
  annotations: String
  documents: String
  labels: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.results_area_contest"
"""
input results_area_contest_inc_input {
  blank_votes: Int
  blank_votes_percent: numeric
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""
input type for inserting data into table "sequent_backend.results_area_contest"
"""
input results_area_contest_insert_input {
  annotations: jsonb
  area_id: uuid
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  labels: jsonb
  last_updated_at: timestamptz
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""aggregate max on columns"""
type results_area_contest_max_fields {
  area_id: uuid
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  last_updated_at: timestamptz
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""aggregate min on columns"""
type results_area_contest_min_fields {
  area_id: uuid
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  last_updated_at: timestamptz
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""
response of any mutation on the table "sequent_backend.results_area_contest"
"""
type results_area_contest_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [results_area_contest!]!
}

"""
on_conflict condition type for table "sequent_backend.results_area_contest"
"""
input results_area_contest_on_conflict {
  constraint: results_area_contest_constraint!
  update_columns: [results_area_contest_update_column!]! = []
  where: results_area_contest_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.results_area_contest".
"""
input results_area_contest_order_by {
  annotations: order_by
  area_id: order_by
  blank_votes: order_by
  blank_votes_percent: order_by
  contest_id: order_by
  created_at: order_by
  documents: order_by
  election_event_id: order_by
  election_id: order_by
  elegible_census: order_by
  explicit_invalid_votes: order_by
  explicit_invalid_votes_percent: order_by
  id: order_by
  implicit_invalid_votes: order_by
  implicit_invalid_votes_percent: order_by
  labels: order_by
  last_updated_at: order_by
  results_event_id: order_by
  tenant_id: order_by
  total_auditable_votes: order_by
  total_auditable_votes_percent: order_by
  total_invalid_votes: order_by
  total_invalid_votes_percent: order_by
  total_valid_votes: order_by
  total_valid_votes_percent: order_by
  total_votes: order_by
  total_votes_percent: order_by
}

"""
primary key columns input for table: sequent_backend.results_area_contest
"""
input results_area_contest_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  results_event_id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input results_area_contest_prepend_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.results_area_contest"
"""
enum results_area_contest_select_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  blank_votes
  """column name"""
  blank_votes_percent
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  elegible_census
  """column name"""
  explicit_invalid_votes
  """column name"""
  explicit_invalid_votes_percent
  """column name"""
  id
  """column name"""
  implicit_invalid_votes
  """column name"""
  implicit_invalid_votes_percent
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  total_auditable_votes
  """column name"""
  total_auditable_votes_percent
  """column name"""
  total_invalid_votes
  """column name"""
  total_invalid_votes_percent
  """column name"""
  total_valid_votes
  """column name"""
  total_valid_votes_percent
  """column name"""
  total_votes
  """column name"""
  total_votes_percent
}

"""
input type for updating data in table "sequent_backend.results_area_contest"
"""
input results_area_contest_set_input {
  annotations: jsonb
  area_id: uuid
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  labels: jsonb
  last_updated_at: timestamptz
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""aggregate stddev on columns"""
type results_area_contest_stddev_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""aggregate stddev_pop on columns"""
type results_area_contest_stddev_pop_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""aggregate stddev_samp on columns"""
type results_area_contest_stddev_samp_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""
Streaming cursor of the table "sequent_backend_results_area_contest"
"""
input results_area_contest_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: results_area_contest_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input results_area_contest_stream_cursor_value_input {
  annotations: jsonb
  area_id: uuid
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  labels: jsonb
  last_updated_at: timestamptz
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""aggregate sum on columns"""
type results_area_contest_sum_fields {
  blank_votes: Int
  blank_votes_percent: numeric
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""
update columns of table "sequent_backend.results_area_contest"
"""
enum results_area_contest_update_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  blank_votes
  """column name"""
  blank_votes_percent
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  elegible_census
  """column name"""
  explicit_invalid_votes
  """column name"""
  explicit_invalid_votes_percent
  """column name"""
  id
  """column name"""
  implicit_invalid_votes
  """column name"""
  implicit_invalid_votes_percent
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  total_auditable_votes
  """column name"""
  total_auditable_votes_percent
  """column name"""
  total_invalid_votes
  """column name"""
  total_invalid_votes_percent
  """column name"""
  total_valid_votes
  """column name"""
  total_valid_votes_percent
  """column name"""
  total_votes
  """column name"""
  total_votes_percent
}

input results_area_contest_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: results_area_contest_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: results_area_contest_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: results_area_contest_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: results_area_contest_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: results_area_contest_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: results_area_contest_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: results_area_contest_set_input
  """filter the rows which have to be updated"""
  where: results_area_contest_bool_exp!
}

"""aggregate var_pop on columns"""
type results_area_contest_var_pop_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""aggregate var_samp on columns"""
type results_area_contest_var_samp_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""aggregate variance on columns"""
type results_area_contest_variance_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""
columns and relationships of "sequent_backend.results_contest"
"""
type results_contest {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid!
  counting_algorithm: String
  created_at: timestamptz
  documents(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  election_id: uuid!
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid!
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid!
  tenant_id: uuid!
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
  voting_type: String
}

"""
aggregated selection of "sequent_backend.results_contest"
"""
type results_contest_aggregate {
  aggregate: results_contest_aggregate_fields
  nodes: [results_contest!]!
}

"""
aggregate fields of "sequent_backend.results_contest"
"""
type results_contest_aggregate_fields {
  avg: results_contest_avg_fields
  count(columns: [results_contest_select_column!], distinct: Boolean): Int!
  max: results_contest_max_fields
  min: results_contest_min_fields
  stddev: results_contest_stddev_fields
  stddev_pop: results_contest_stddev_pop_fields
  stddev_samp: results_contest_stddev_samp_fields
  sum: results_contest_sum_fields
  var_pop: results_contest_var_pop_fields
  var_samp: results_contest_var_samp_fields
  variance: results_contest_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input results_contest_append_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""aggregate avg on columns"""
type results_contest_avg_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.results_contest". All fields are combined with a logical 'AND'.
"""
input results_contest_bool_exp {
  _and: [results_contest_bool_exp!]
  _not: results_contest_bool_exp
  _or: [results_contest_bool_exp!]
  annotations: jsonb_comparison_exp
  blank_votes: Int_comparison_exp
  blank_votes_percent: numeric_comparison_exp
  contest_id: uuid_comparison_exp
  counting_algorithm: String_comparison_exp
  created_at: timestamptz_comparison_exp
  documents: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  elegible_census: Int_comparison_exp
  explicit_invalid_votes: Int_comparison_exp
  explicit_invalid_votes_percent: numeric_comparison_exp
  id: uuid_comparison_exp
  implicit_invalid_votes: Int_comparison_exp
  implicit_invalid_votes_percent: numeric_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  results_event_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
  total_auditable_votes: Int_comparison_exp
  total_auditable_votes_percent: numeric_comparison_exp
  total_invalid_votes: Int_comparison_exp
  total_invalid_votes_percent: numeric_comparison_exp
  total_valid_votes: Int_comparison_exp
  total_valid_votes_percent: numeric_comparison_exp
  total_votes: Int_comparison_exp
  total_votes_percent: numeric_comparison_exp
  voting_type: String_comparison_exp
}

"""
columns and relationships of "sequent_backend.results_contest_candidate"
"""
type results_contest_candidate {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  candidate_id: uuid!
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid!
  created_at: timestamptz
  documents(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  election_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid!
  tenant_id: uuid!
  winning_position: Int
}

"""
aggregated selection of "sequent_backend.results_contest_candidate"
"""
type results_contest_candidate_aggregate {
  aggregate: results_contest_candidate_aggregate_fields
  nodes: [results_contest_candidate!]!
}

"""
aggregate fields of "sequent_backend.results_contest_candidate"
"""
type results_contest_candidate_aggregate_fields {
  avg: results_contest_candidate_avg_fields
  count(columns: [results_contest_candidate_select_column!], distinct: Boolean): Int!
  max: results_contest_candidate_max_fields
  min: results_contest_candidate_min_fields
  stddev: results_contest_candidate_stddev_fields
  stddev_pop: results_contest_candidate_stddev_pop_fields
  stddev_samp: results_contest_candidate_stddev_samp_fields
  sum: results_contest_candidate_sum_fields
  var_pop: results_contest_candidate_var_pop_fields
  var_samp: results_contest_candidate_var_samp_fields
  variance: results_contest_candidate_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input results_contest_candidate_append_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""aggregate avg on columns"""
type results_contest_candidate_avg_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.results_contest_candidate". All fields are combined with a logical 'AND'.
"""
input results_contest_candidate_bool_exp {
  _and: [results_contest_candidate_bool_exp!]
  _not: results_contest_candidate_bool_exp
  _or: [results_contest_candidate_bool_exp!]
  annotations: jsonb_comparison_exp
  candidate_id: uuid_comparison_exp
  cast_votes: Int_comparison_exp
  cast_votes_percent: numeric_comparison_exp
  contest_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  documents: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  points: Int_comparison_exp
  results_event_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
  winning_position: Int_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.results_contest_candidate"
"""
enum results_contest_candidate_constraint {
  """
  unique or primary key constraint on columns "id", "results_event_id", "tenant_id", "election_event_id"
  """
  results_contest_candidate_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input results_contest_candidate_delete_at_path_input {
  annotations: [String!]
  documents: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input results_contest_candidate_delete_elem_input {
  annotations: Int
  documents: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input results_contest_candidate_delete_key_input {
  annotations: String
  documents: String
  labels: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.results_contest_candidate"
"""
input results_contest_candidate_inc_input {
  cast_votes: Int
  cast_votes_percent: numeric
  points: Int
  winning_position: Int
}

"""
input type for inserting data into table "sequent_backend.results_contest_candidate"
"""
input results_contest_candidate_insert_input {
  annotations: jsonb
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""aggregate max on columns"""
type results_contest_candidate_max_fields {
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""aggregate min on columns"""
type results_contest_candidate_min_fields {
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""
response of any mutation on the table "sequent_backend.results_contest_candidate"
"""
type results_contest_candidate_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [results_contest_candidate!]!
}

"""
on_conflict condition type for table "sequent_backend.results_contest_candidate"
"""
input results_contest_candidate_on_conflict {
  constraint: results_contest_candidate_constraint!
  update_columns: [results_contest_candidate_update_column!]! = []
  where: results_contest_candidate_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.results_contest_candidate".
"""
input results_contest_candidate_order_by {
  annotations: order_by
  candidate_id: order_by
  cast_votes: order_by
  cast_votes_percent: order_by
  contest_id: order_by
  created_at: order_by
  documents: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  points: order_by
  results_event_id: order_by
  tenant_id: order_by
  winning_position: order_by
}

"""
primary key columns input for table: sequent_backend.results_contest_candidate
"""
input results_contest_candidate_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  results_event_id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input results_contest_candidate_prepend_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.results_contest_candidate"
"""
enum results_contest_candidate_select_column {
  """column name"""
  annotations
  """column name"""
  candidate_id
  """column name"""
  cast_votes
  """column name"""
  cast_votes_percent
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  points
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  winning_position
}

"""
input type for updating data in table "sequent_backend.results_contest_candidate"
"""
input results_contest_candidate_set_input {
  annotations: jsonb
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""aggregate stddev on columns"""
type results_contest_candidate_stddev_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""aggregate stddev_pop on columns"""
type results_contest_candidate_stddev_pop_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""aggregate stddev_samp on columns"""
type results_contest_candidate_stddev_samp_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""
Streaming cursor of the table "sequent_backend_results_contest_candidate"
"""
input results_contest_candidate_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: results_contest_candidate_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input results_contest_candidate_stream_cursor_value_input {
  annotations: jsonb
  candidate_id: uuid
  cast_votes: Int
  cast_votes_percent: numeric
  contest_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  points: Int
  results_event_id: uuid
  tenant_id: uuid
  winning_position: Int
}

"""aggregate sum on columns"""
type results_contest_candidate_sum_fields {
  cast_votes: Int
  cast_votes_percent: numeric
  points: Int
  winning_position: Int
}

"""
update columns of table "sequent_backend.results_contest_candidate"
"""
enum results_contest_candidate_update_column {
  """column name"""
  annotations
  """column name"""
  candidate_id
  """column name"""
  cast_votes
  """column name"""
  cast_votes_percent
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  points
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  winning_position
}

input results_contest_candidate_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: results_contest_candidate_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: results_contest_candidate_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: results_contest_candidate_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: results_contest_candidate_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: results_contest_candidate_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: results_contest_candidate_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: results_contest_candidate_set_input
  """filter the rows which have to be updated"""
  where: results_contest_candidate_bool_exp!
}

"""aggregate var_pop on columns"""
type results_contest_candidate_var_pop_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""aggregate var_samp on columns"""
type results_contest_candidate_var_samp_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""aggregate variance on columns"""
type results_contest_candidate_variance_fields {
  cast_votes: Float
  cast_votes_percent: Float
  points: Float
  winning_position: Float
}

"""
unique or primary key constraints on table "sequent_backend.results_contest"
"""
enum results_contest_constraint {
  """
  unique or primary key constraint on columns "id", "results_event_id", "tenant_id", "election_event_id"
  """
  results_contest_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input results_contest_delete_at_path_input {
  annotations: [String!]
  documents: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input results_contest_delete_elem_input {
  annotations: Int
  documents: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input results_contest_delete_key_input {
  annotations: String
  documents: String
  labels: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.results_contest"
"""
input results_contest_inc_input {
  blank_votes: Int
  blank_votes_percent: numeric
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""
input type for inserting data into table "sequent_backend.results_contest"
"""
input results_contest_insert_input {
  annotations: jsonb
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  counting_algorithm: String
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
  voting_type: String
}

"""aggregate max on columns"""
type results_contest_max_fields {
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  counting_algorithm: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
  voting_type: String
}

"""aggregate min on columns"""
type results_contest_min_fields {
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  counting_algorithm: String
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
  voting_type: String
}

"""
response of any mutation on the table "sequent_backend.results_contest"
"""
type results_contest_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [results_contest!]!
}

"""
on_conflict condition type for table "sequent_backend.results_contest"
"""
input results_contest_on_conflict {
  constraint: results_contest_constraint!
  update_columns: [results_contest_update_column!]! = []
  where: results_contest_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.results_contest".
"""
input results_contest_order_by {
  annotations: order_by
  blank_votes: order_by
  blank_votes_percent: order_by
  contest_id: order_by
  counting_algorithm: order_by
  created_at: order_by
  documents: order_by
  election_event_id: order_by
  election_id: order_by
  elegible_census: order_by
  explicit_invalid_votes: order_by
  explicit_invalid_votes_percent: order_by
  id: order_by
  implicit_invalid_votes: order_by
  implicit_invalid_votes_percent: order_by
  labels: order_by
  last_updated_at: order_by
  name: order_by
  results_event_id: order_by
  tenant_id: order_by
  total_auditable_votes: order_by
  total_auditable_votes_percent: order_by
  total_invalid_votes: order_by
  total_invalid_votes_percent: order_by
  total_valid_votes: order_by
  total_valid_votes_percent: order_by
  total_votes: order_by
  total_votes_percent: order_by
  voting_type: order_by
}

"""primary key columns input for table: sequent_backend.results_contest"""
input results_contest_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  results_event_id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input results_contest_prepend_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.results_contest"
"""
enum results_contest_select_column {
  """column name"""
  annotations
  """column name"""
  blank_votes
  """column name"""
  blank_votes_percent
  """column name"""
  contest_id
  """column name"""
  counting_algorithm
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  elegible_census
  """column name"""
  explicit_invalid_votes
  """column name"""
  explicit_invalid_votes_percent
  """column name"""
  id
  """column name"""
  implicit_invalid_votes
  """column name"""
  implicit_invalid_votes_percent
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  total_auditable_votes
  """column name"""
  total_auditable_votes_percent
  """column name"""
  total_invalid_votes
  """column name"""
  total_invalid_votes_percent
  """column name"""
  total_valid_votes
  """column name"""
  total_valid_votes_percent
  """column name"""
  total_votes
  """column name"""
  total_votes_percent
  """column name"""
  voting_type
}

"""
input type for updating data in table "sequent_backend.results_contest"
"""
input results_contest_set_input {
  annotations: jsonb
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  counting_algorithm: String
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
  voting_type: String
}

"""aggregate stddev on columns"""
type results_contest_stddev_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""aggregate stddev_pop on columns"""
type results_contest_stddev_pop_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""aggregate stddev_samp on columns"""
type results_contest_stddev_samp_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""
Streaming cursor of the table "sequent_backend_results_contest"
"""
input results_contest_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: results_contest_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input results_contest_stream_cursor_value_input {
  annotations: jsonb
  blank_votes: Int
  blank_votes_percent: numeric
  contest_id: uuid
  counting_algorithm: String
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  id: uuid
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
  voting_type: String
}

"""aggregate sum on columns"""
type results_contest_sum_fields {
  blank_votes: Int
  blank_votes_percent: numeric
  elegible_census: Int
  explicit_invalid_votes: Int
  explicit_invalid_votes_percent: numeric
  implicit_invalid_votes: Int
  implicit_invalid_votes_percent: numeric
  total_auditable_votes: Int
  total_auditable_votes_percent: numeric
  total_invalid_votes: Int
  total_invalid_votes_percent: numeric
  total_valid_votes: Int
  total_valid_votes_percent: numeric
  total_votes: Int
  total_votes_percent: numeric
}

"""
update columns of table "sequent_backend.results_contest"
"""
enum results_contest_update_column {
  """column name"""
  annotations
  """column name"""
  blank_votes
  """column name"""
  blank_votes_percent
  """column name"""
  contest_id
  """column name"""
  counting_algorithm
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  elegible_census
  """column name"""
  explicit_invalid_votes
  """column name"""
  explicit_invalid_votes_percent
  """column name"""
  id
  """column name"""
  implicit_invalid_votes
  """column name"""
  implicit_invalid_votes_percent
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  total_auditable_votes
  """column name"""
  total_auditable_votes_percent
  """column name"""
  total_invalid_votes
  """column name"""
  total_invalid_votes_percent
  """column name"""
  total_valid_votes
  """column name"""
  total_valid_votes_percent
  """column name"""
  total_votes
  """column name"""
  total_votes_percent
  """column name"""
  voting_type
}

input results_contest_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: results_contest_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: results_contest_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: results_contest_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: results_contest_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: results_contest_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: results_contest_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: results_contest_set_input
  """filter the rows which have to be updated"""
  where: results_contest_bool_exp!
}

"""aggregate var_pop on columns"""
type results_contest_var_pop_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""aggregate var_samp on columns"""
type results_contest_var_samp_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""aggregate variance on columns"""
type results_contest_variance_fields {
  blank_votes: Float
  blank_votes_percent: Float
  elegible_census: Float
  explicit_invalid_votes: Float
  explicit_invalid_votes_percent: Float
  implicit_invalid_votes: Float
  implicit_invalid_votes_percent: Float
  total_auditable_votes: Float
  total_auditable_votes_percent: Float
  total_invalid_votes: Float
  total_invalid_votes_percent: Float
  total_valid_votes: Float
  total_valid_votes_percent: Float
  total_votes: Float
  total_votes_percent: Float
}

"""
columns and relationships of "sequent_backend.results_election"
"""
type results_election {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  documents(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  election_id: uuid!
  elegible_census: Int
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid!
  tenant_id: uuid!
  total_voters: Int
  total_voters_percent: numeric
}

"""
aggregated selection of "sequent_backend.results_election"
"""
type results_election_aggregate {
  aggregate: results_election_aggregate_fields
  nodes: [results_election!]!
}

"""
aggregate fields of "sequent_backend.results_election"
"""
type results_election_aggregate_fields {
  avg: results_election_avg_fields
  count(columns: [results_election_select_column!], distinct: Boolean): Int!
  max: results_election_max_fields
  min: results_election_min_fields
  stddev: results_election_stddev_fields
  stddev_pop: results_election_stddev_pop_fields
  stddev_samp: results_election_stddev_samp_fields
  sum: results_election_sum_fields
  var_pop: results_election_var_pop_fields
  var_samp: results_election_var_samp_fields
  variance: results_election_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input results_election_append_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""
columns and relationships of "sequent_backend.results_election_area"
"""
type results_election_area {
  area_id: uuid!
  created_at: timestamptz!
  documents(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  election_id: uuid!
  id: uuid!
  last_updated_at: timestamptz!
  name: String
  results_event_id: uuid!
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.results_election_area"
"""
type results_election_area_aggregate {
  aggregate: results_election_area_aggregate_fields
  nodes: [results_election_area!]!
}

"""
aggregate fields of "sequent_backend.results_election_area"
"""
type results_election_area_aggregate_fields {
  count(columns: [results_election_area_select_column!], distinct: Boolean): Int!
  max: results_election_area_max_fields
  min: results_election_area_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input results_election_area_append_input {
  documents: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.results_election_area". All fields are combined with a logical 'AND'.
"""
input results_election_area_bool_exp {
  _and: [results_election_area_bool_exp!]
  _not: results_election_area_bool_exp
  _or: [results_election_area_bool_exp!]
  area_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  documents: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  results_event_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.results_election_area"
"""
enum results_election_area_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  results_election_area_id_key
  """
  unique or primary key constraint on columns "id", "results_event_id", "tenant_id", "election_event_id"
  """
  results_election_area_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input results_election_area_delete_at_path_input {
  documents: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input results_election_area_delete_elem_input {
  documents: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input results_election_area_delete_key_input {
  documents: String
}

"""
input type for inserting data into table "sequent_backend.results_election_area"
"""
input results_election_area_insert_input {
  area_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
}

"""aggregate max on columns"""
type results_election_area_max_fields {
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
}

"""aggregate min on columns"""
type results_election_area_min_fields {
  area_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.results_election_area"
"""
type results_election_area_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [results_election_area!]!
}

"""
on_conflict condition type for table "sequent_backend.results_election_area"
"""
input results_election_area_on_conflict {
  constraint: results_election_area_constraint!
  update_columns: [results_election_area_update_column!]! = []
  where: results_election_area_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.results_election_area".
"""
input results_election_area_order_by {
  area_id: order_by
  created_at: order_by
  documents: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  last_updated_at: order_by
  name: order_by
  results_event_id: order_by
  tenant_id: order_by
}

"""
primary key columns input for table: sequent_backend.results_election_area
"""
input results_election_area_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  results_event_id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input results_election_area_prepend_input {
  documents: jsonb
}

"""
select columns of table "sequent_backend.results_election_area"
"""
enum results_election_area_select_column {
  """column name"""
  area_id
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  results_event_id
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.results_election_area"
"""
input results_election_area_set_input {
  area_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_results_election_area"
"""
input results_election_area_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: results_election_area_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input results_election_area_stream_cursor_value_input {
  area_id: uuid
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.results_election_area"
"""
enum results_election_area_update_column {
  """column name"""
  area_id
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  results_event_id
  """column name"""
  tenant_id
}

input results_election_area_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: results_election_area_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: results_election_area_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: results_election_area_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: results_election_area_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: results_election_area_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: results_election_area_set_input
  """filter the rows which have to be updated"""
  where: results_election_area_bool_exp!
}

"""aggregate avg on columns"""
type results_election_avg_fields {
  elegible_census: Float
  total_voters: Float
  total_voters_percent: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.results_election". All fields are combined with a logical 'AND'.
"""
input results_election_bool_exp {
  _and: [results_election_bool_exp!]
  _not: results_election_bool_exp
  _or: [results_election_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  documents: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  elegible_census: Int_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  results_event_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
  total_voters: Int_comparison_exp
  total_voters_percent: numeric_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.results_election"
"""
enum results_election_constraint {
  """
  unique or primary key constraint on columns "id", "results_event_id", "tenant_id", "election_event_id"
  """
  results_election_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input results_election_delete_at_path_input {
  annotations: [String!]
  documents: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input results_election_delete_elem_input {
  annotations: Int
  documents: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input results_election_delete_key_input {
  annotations: String
  documents: String
  labels: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.results_election"
"""
input results_election_inc_input {
  elegible_census: Int
  total_voters: Int
  total_voters_percent: numeric
}

"""
input type for inserting data into table "sequent_backend.results_election"
"""
input results_election_insert_input {
  annotations: jsonb
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_voters: Int
  total_voters_percent: numeric
}

"""aggregate max on columns"""
type results_election_max_fields {
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  id: uuid
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_voters: Int
  total_voters_percent: numeric
}

"""aggregate min on columns"""
type results_election_min_fields {
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  id: uuid
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_voters: Int
  total_voters_percent: numeric
}

"""
response of any mutation on the table "sequent_backend.results_election"
"""
type results_election_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [results_election!]!
}

"""
on_conflict condition type for table "sequent_backend.results_election"
"""
input results_election_on_conflict {
  constraint: results_election_constraint!
  update_columns: [results_election_update_column!]! = []
  where: results_election_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.results_election".
"""
input results_election_order_by {
  annotations: order_by
  created_at: order_by
  documents: order_by
  election_event_id: order_by
  election_id: order_by
  elegible_census: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  name: order_by
  results_event_id: order_by
  tenant_id: order_by
  total_voters: order_by
  total_voters_percent: order_by
}

"""primary key columns input for table: sequent_backend.results_election"""
input results_election_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  results_event_id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input results_election_prepend_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.results_election"
"""
enum results_election_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  elegible_census
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  total_voters
  """column name"""
  total_voters_percent
}

"""
input type for updating data in table "sequent_backend.results_election"
"""
input results_election_set_input {
  annotations: jsonb
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_voters: Int
  total_voters_percent: numeric
}

"""aggregate stddev on columns"""
type results_election_stddev_fields {
  elegible_census: Float
  total_voters: Float
  total_voters_percent: Float
}

"""aggregate stddev_pop on columns"""
type results_election_stddev_pop_fields {
  elegible_census: Float
  total_voters: Float
  total_voters_percent: Float
}

"""aggregate stddev_samp on columns"""
type results_election_stddev_samp_fields {
  elegible_census: Float
  total_voters: Float
  total_voters_percent: Float
}

"""
Streaming cursor of the table "sequent_backend_results_election"
"""
input results_election_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: results_election_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input results_election_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  election_id: uuid
  elegible_census: Int
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  results_event_id: uuid
  tenant_id: uuid
  total_voters: Int
  total_voters_percent: numeric
}

"""aggregate sum on columns"""
type results_election_sum_fields {
  elegible_census: Int
  total_voters: Int
  total_voters_percent: numeric
}

"""
update columns of table "sequent_backend.results_election"
"""
enum results_election_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  elegible_census
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  results_event_id
  """column name"""
  tenant_id
  """column name"""
  total_voters
  """column name"""
  total_voters_percent
}

input results_election_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: results_election_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: results_election_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: results_election_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: results_election_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: results_election_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: results_election_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: results_election_set_input
  """filter the rows which have to be updated"""
  where: results_election_bool_exp!
}

"""aggregate var_pop on columns"""
type results_election_var_pop_fields {
  elegible_census: Float
  total_voters: Float
  total_voters_percent: Float
}

"""aggregate var_samp on columns"""
type results_election_var_samp_fields {
  elegible_census: Float
  total_voters: Float
  total_voters_percent: Float
}

"""aggregate variance on columns"""
type results_election_variance_fields {
  elegible_census: Float
  total_voters: Float
  total_voters_percent: Float
}

"""
columns and relationships of "sequent_backend.results_event"
"""
type results_event {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  documents(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  name: String
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.results_event"
"""
type results_event_aggregate {
  aggregate: results_event_aggregate_fields
  nodes: [results_event!]!
}

"""
aggregate fields of "sequent_backend.results_event"
"""
type results_event_aggregate_fields {
  count(columns: [results_event_select_column!], distinct: Boolean): Int!
  max: results_event_max_fields
  min: results_event_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input results_event_append_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.results_event". All fields are combined with a logical 'AND'.
"""
input results_event_bool_exp {
  _and: [results_event_bool_exp!]
  _not: results_event_bool_exp
  _or: [results_event_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  documents: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.results_event"
"""
enum results_event_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  results_event_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input results_event_delete_at_path_input {
  annotations: [String!]
  documents: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input results_event_delete_elem_input {
  annotations: Int
  documents: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input results_event_delete_key_input {
  annotations: String
  documents: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.results_event"
"""
input results_event_insert_input {
  annotations: jsonb
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  tenant_id: uuid
}

"""aggregate max on columns"""
type results_event_max_fields {
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  tenant_id: uuid
}

"""aggregate min on columns"""
type results_event_min_fields {
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  name: String
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.results_event"
"""
type results_event_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [results_event!]!
}

"""
on_conflict condition type for table "sequent_backend.results_event"
"""
input results_event_on_conflict {
  constraint: results_event_constraint!
  update_columns: [results_event_update_column!]! = []
  where: results_event_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.results_event".
"""
input results_event_order_by {
  annotations: order_by
  created_at: order_by
  documents: order_by
  election_event_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  name: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.results_event"""
input results_event_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input results_event_prepend_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.results_event"
"""
enum results_event_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.results_event"
"""
input results_event_set_input {
  annotations: jsonb
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_results_event"
"""
input results_event_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: results_event_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input results_event_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  documents: jsonb
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.results_event"
"""
enum results_event_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  tenant_id
}

input results_event_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: results_event_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: results_event_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: results_event_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: results_event_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: results_event_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: results_event_set_input
  """filter the rows which have to be updated"""
  where: results_event_bool_exp!
}

"""
columns and relationships of "sequent_backend.scheduled_event"
"""
type scheduled_event {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  archived_at: timestamptz
  created_at: timestamptz
  created_by: String
  cron_config(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid
  event_payload(
    """JSON select path"""
    path: String
  ): jsonb
  event_processor: String
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  stopped_at: timestamptz
  task_id: String
  tenant_id: uuid
}

"""
aggregated selection of "sequent_backend.scheduled_event"
"""
type scheduled_event_aggregate {
  aggregate: scheduled_event_aggregate_fields
  nodes: [scheduled_event!]!
}

"""
aggregate fields of "sequent_backend.scheduled_event"
"""
type scheduled_event_aggregate_fields {
  count(columns: [scheduled_event_select_column!], distinct: Boolean): Int!
  max: scheduled_event_max_fields
  min: scheduled_event_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input scheduled_event_append_input {
  annotations: jsonb
  cron_config: jsonb
  event_payload: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.scheduled_event". All fields are combined with a logical 'AND'.
"""
input scheduled_event_bool_exp {
  _and: [scheduled_event_bool_exp!]
  _not: scheduled_event_bool_exp
  _or: [scheduled_event_bool_exp!]
  annotations: jsonb_comparison_exp
  archived_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  cron_config: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  event_payload: jsonb_comparison_exp
  event_processor: String_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  stopped_at: timestamptz_comparison_exp
  task_id: String_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.scheduled_event"
"""
enum scheduled_event_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  scheduled_event_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input scheduled_event_delete_at_path_input {
  annotations: [String!]
  cron_config: [String!]
  event_payload: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input scheduled_event_delete_elem_input {
  annotations: Int
  cron_config: Int
  event_payload: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input scheduled_event_delete_key_input {
  annotations: String
  cron_config: String
  event_payload: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.scheduled_event"
"""
input scheduled_event_insert_input {
  annotations: jsonb
  archived_at: timestamptz
  created_at: timestamptz
  created_by: String
  cron_config: jsonb
  election_event_id: uuid
  event_payload: jsonb
  event_processor: String
  id: uuid
  labels: jsonb
  stopped_at: timestamptz
  task_id: String
  tenant_id: uuid
}

"""aggregate max on columns"""
type scheduled_event_max_fields {
  archived_at: timestamptz
  created_at: timestamptz
  created_by: String
  election_event_id: uuid
  event_processor: String
  id: uuid
  stopped_at: timestamptz
  task_id: String
  tenant_id: uuid
}

"""aggregate min on columns"""
type scheduled_event_min_fields {
  archived_at: timestamptz
  created_at: timestamptz
  created_by: String
  election_event_id: uuid
  event_processor: String
  id: uuid
  stopped_at: timestamptz
  task_id: String
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.scheduled_event"
"""
type scheduled_event_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [scheduled_event!]!
}

"""
on_conflict condition type for table "sequent_backend.scheduled_event"
"""
input scheduled_event_on_conflict {
  constraint: scheduled_event_constraint!
  update_columns: [scheduled_event_update_column!]! = []
  where: scheduled_event_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.scheduled_event".
"""
input scheduled_event_order_by {
  annotations: order_by
  archived_at: order_by
  created_at: order_by
  created_by: order_by
  cron_config: order_by
  election_event_id: order_by
  event_payload: order_by
  event_processor: order_by
  id: order_by
  labels: order_by
  stopped_at: order_by
  task_id: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.scheduled_event"""
input scheduled_event_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input scheduled_event_prepend_input {
  annotations: jsonb
  cron_config: jsonb
  event_payload: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.scheduled_event"
"""
enum scheduled_event_select_column {
  """column name"""
  annotations
  """column name"""
  archived_at
  """column name"""
  created_at
  """column name"""
  created_by
  """column name"""
  cron_config
  """column name"""
  election_event_id
  """column name"""
  event_payload
  """column name"""
  event_processor
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  stopped_at
  """column name"""
  task_id
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.scheduled_event"
"""
input scheduled_event_set_input {
  annotations: jsonb
  archived_at: timestamptz
  created_at: timestamptz
  created_by: String
  cron_config: jsonb
  election_event_id: uuid
  event_payload: jsonb
  event_processor: String
  id: uuid
  labels: jsonb
  stopped_at: timestamptz
  task_id: String
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_scheduled_event"
"""
input scheduled_event_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: scheduled_event_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input scheduled_event_stream_cursor_value_input {
  annotations: jsonb
  archived_at: timestamptz
  created_at: timestamptz
  created_by: String
  cron_config: jsonb
  election_event_id: uuid
  event_payload: jsonb
  event_processor: String
  id: uuid
  labels: jsonb
  stopped_at: timestamptz
  task_id: String
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.scheduled_event"
"""
enum scheduled_event_update_column {
  """column name"""
  annotations
  """column name"""
  archived_at
  """column name"""
  created_at
  """column name"""
  created_by
  """column name"""
  cron_config
  """column name"""
  election_event_id
  """column name"""
  event_payload
  """column name"""
  event_processor
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  stopped_at
  """column name"""
  task_id
  """column name"""
  tenant_id
}

input scheduled_event_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: scheduled_event_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: scheduled_event_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: scheduled_event_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: scheduled_event_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: scheduled_event_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: scheduled_event_set_input
  """filter the rows which have to be updated"""
  where: scheduled_event_bool_exp!
}

"""
columns and relationships of "sequent_backend.secret"
"""
type secret {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  election_event_id: uuid
  id: uuid!
  key: String!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  tenant_id: uuid!
  value: bytea!
}

"""
aggregated selection of "sequent_backend.secret"
"""
type secret_aggregate {
  aggregate: secret_aggregate_fields
  nodes: [secret!]!
}

"""
aggregate fields of "sequent_backend.secret"
"""
type secret_aggregate_fields {
  count(columns: [secret_select_column!], distinct: Boolean): Int!
  max: secret_max_fields
  min: secret_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input secret_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.secret". All fields are combined with a logical 'AND'.
"""
input secret_bool_exp {
  _and: [secret_bool_exp!]
  _not: secret_bool_exp
  _or: [secret_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  labels: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
  value: bytea_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.secret"
"""
enum secret_constraint {
  """
  unique or primary key constraint on columns "key"
  """
  secret_key_key
  """
  unique or primary key constraint on columns "key", "id", "tenant_id"
  """
  secret_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input secret_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input secret_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input secret_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.secret"
"""
input secret_insert_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  key: String
  labels: jsonb
  tenant_id: uuid
  value: bytea
}

"""aggregate max on columns"""
type secret_max_fields {
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  key: String
  tenant_id: uuid
}

"""aggregate min on columns"""
type secret_min_fields {
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  key: String
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.secret"
"""
type secret_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [secret!]!
}

"""
on_conflict condition type for table "sequent_backend.secret"
"""
input secret_on_conflict {
  constraint: secret_constraint!
  update_columns: [secret_update_column!]! = []
  where: secret_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.secret"."""
input secret_order_by {
  annotations: order_by
  created_at: order_by
  election_event_id: order_by
  id: order_by
  key: order_by
  labels: order_by
  tenant_id: order_by
  value: order_by
}

"""primary key columns input for table: sequent_backend.secret"""
input secret_pk_columns_input {
  id: uuid!
  key: String!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input secret_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.secret"
"""
enum secret_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  key
  """column name"""
  labels
  """column name"""
  tenant_id
  """column name"""
  value
}

"""
input type for updating data in table "sequent_backend.secret"
"""
input secret_set_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  key: String
  labels: jsonb
  tenant_id: uuid
  value: bytea
}

"""
Streaming cursor of the table "sequent_backend_secret"
"""
input secret_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: secret_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input secret_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  id: uuid
  key: String
  labels: jsonb
  tenant_id: uuid
  value: bytea
}

"""
update columns of table "sequent_backend.secret"
"""
enum secret_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  key
  """column name"""
  labels
  """column name"""
  tenant_id
  """column name"""
  value
}

input secret_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: secret_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: secret_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: secret_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: secret_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: secret_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: secret_set_input
  """filter the rows which have to be updated"""
  where: secret_bool_exp!
}

"""
columns and relationships of "sequent_backend.support_material"
"""
type support_material {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb!
  created_at: timestamptz!
  data(
    """JSON select path"""
    path: String
  ): jsonb!
  document_id: String
  election_event_id: uuid!
  id: uuid!
  is_hidden: Boolean
  kind: String!
  labels(
    """JSON select path"""
    path: String
  ): jsonb!
  last_updated_at: timestamptz!
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.support_material"
"""
type support_material_aggregate {
  aggregate: support_material_aggregate_fields
  nodes: [support_material!]!
}

"""
aggregate fields of "sequent_backend.support_material"
"""
type support_material_aggregate_fields {
  count(columns: [support_material_select_column!], distinct: Boolean): Int!
  max: support_material_max_fields
  min: support_material_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input support_material_append_input {
  annotations: jsonb
  data: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.support_material". All fields are combined with a logical 'AND'.
"""
input support_material_bool_exp {
  _and: [support_material_bool_exp!]
  _not: support_material_bool_exp
  _or: [support_material_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  document_id: String_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  is_hidden: Boolean_comparison_exp
  kind: String_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.support_material"
"""
enum support_material_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  support_material_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input support_material_delete_at_path_input {
  annotations: [String!]
  data: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input support_material_delete_elem_input {
  annotations: Int
  data: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input support_material_delete_key_input {
  annotations: String
  data: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.support_material"
"""
input support_material_insert_input {
  annotations: jsonb
  created_at: timestamptz
  data: jsonb
  document_id: String
  election_event_id: uuid
  id: uuid
  is_hidden: Boolean
  kind: String
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""aggregate max on columns"""
type support_material_max_fields {
  created_at: timestamptz
  document_id: String
  election_event_id: uuid
  id: uuid
  kind: String
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""aggregate min on columns"""
type support_material_min_fields {
  created_at: timestamptz
  document_id: String
  election_event_id: uuid
  id: uuid
  kind: String
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.support_material"
"""
type support_material_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [support_material!]!
}

"""
on_conflict condition type for table "sequent_backend.support_material"
"""
input support_material_on_conflict {
  constraint: support_material_constraint!
  update_columns: [support_material_update_column!]! = []
  where: support_material_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.support_material".
"""
input support_material_order_by {
  annotations: order_by
  created_at: order_by
  data: order_by
  document_id: order_by
  election_event_id: order_by
  id: order_by
  is_hidden: order_by
  kind: order_by
  labels: order_by
  last_updated_at: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.support_material"""
input support_material_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input support_material_prepend_input {
  annotations: jsonb
  data: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.support_material"
"""
enum support_material_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  data
  """column name"""
  document_id
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  is_hidden
  """column name"""
  kind
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.support_material"
"""
input support_material_set_input {
  annotations: jsonb
  created_at: timestamptz
  data: jsonb
  document_id: String
  election_event_id: uuid
  id: uuid
  is_hidden: Boolean
  kind: String
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_support_material"
"""
input support_material_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: support_material_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input support_material_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  data: jsonb
  document_id: String
  election_event_id: uuid
  id: uuid
  is_hidden: Boolean
  kind: String
  labels: jsonb
  last_updated_at: timestamptz
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.support_material"
"""
enum support_material_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  data
  """column name"""
  document_id
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  is_hidden
  """column name"""
  kind
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  tenant_id
}

input support_material_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: support_material_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: support_material_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: support_material_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: support_material_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: support_material_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: support_material_set_input
  """filter the rows which have to be updated"""
  where: support_material_bool_exp!
}

"""
columns and relationships of "sequent_backend.tally_session"
"""
type tally_session {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  area_ids: [uuid!]
  configuration(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  election_event_id: uuid!
  election_ids: [uuid!]
  execution_status: String
  id: uuid!
  is_execution_completed: Boolean!
  keys_ceremony_id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  permission_label: [String!]
  tally_type: String
  tenant_id: uuid!
  threshold: Int!
}

"""
aggregated selection of "sequent_backend.tally_session"
"""
type tally_session_aggregate {
  aggregate: tally_session_aggregate_fields
  nodes: [tally_session!]!
}

"""
aggregate fields of "sequent_backend.tally_session"
"""
type tally_session_aggregate_fields {
  avg: tally_session_avg_fields
  count(columns: [tally_session_select_column!], distinct: Boolean): Int!
  max: tally_session_max_fields
  min: tally_session_min_fields
  stddev: tally_session_stddev_fields
  stddev_pop: tally_session_stddev_pop_fields
  stddev_samp: tally_session_stddev_samp_fields
  sum: tally_session_sum_fields
  var_pop: tally_session_var_pop_fields
  var_samp: tally_session_var_samp_fields
  variance: tally_session_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tally_session_append_input {
  annotations: jsonb
  configuration: jsonb
  labels: jsonb
}

"""aggregate avg on columns"""
type tally_session_avg_fields {
  threshold: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.tally_session". All fields are combined with a logical 'AND'.
"""
input tally_session_bool_exp {
  _and: [tally_session_bool_exp!]
  _not: tally_session_bool_exp
  _or: [tally_session_bool_exp!]
  annotations: jsonb_comparison_exp
  area_ids: uuid_array_comparison_exp
  configuration: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  election_ids: uuid_array_comparison_exp
  execution_status: String_comparison_exp
  id: uuid_comparison_exp
  is_execution_completed: Boolean_comparison_exp
  keys_ceremony_id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  permission_label: String_array_comparison_exp
  tally_type: String_comparison_exp
  tenant_id: uuid_comparison_exp
  threshold: Int_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.tally_session"
"""
enum tally_session_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  tally_pkey
}

"""
columns and relationships of "sequent_backend.tally_session_contest"
"""
type tally_session_contest {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  area_id: uuid!
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid!
  election_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  session_id: Int!
  tally_session_id: uuid!
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.tally_session_contest"
"""
type tally_session_contest_aggregate {
  aggregate: tally_session_contest_aggregate_fields
  nodes: [tally_session_contest!]!
}

"""
aggregate fields of "sequent_backend.tally_session_contest"
"""
type tally_session_contest_aggregate_fields {
  avg: tally_session_contest_avg_fields
  count(columns: [tally_session_contest_select_column!], distinct: Boolean): Int!
  max: tally_session_contest_max_fields
  min: tally_session_contest_min_fields
  stddev: tally_session_contest_stddev_fields
  stddev_pop: tally_session_contest_stddev_pop_fields
  stddev_samp: tally_session_contest_stddev_samp_fields
  sum: tally_session_contest_sum_fields
  var_pop: tally_session_contest_var_pop_fields
  var_samp: tally_session_contest_var_samp_fields
  variance: tally_session_contest_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tally_session_contest_append_input {
  annotations: jsonb
  labels: jsonb
}

"""aggregate avg on columns"""
type tally_session_contest_avg_fields {
  session_id: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.tally_session_contest". All fields are combined with a logical 'AND'.
"""
input tally_session_contest_bool_exp {
  _and: [tally_session_contest_bool_exp!]
  _not: tally_session_contest_bool_exp
  _or: [tally_session_contest_bool_exp!]
  annotations: jsonb_comparison_exp
  area_id: uuid_comparison_exp
  contest_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  session_id: Int_comparison_exp
  tally_session_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.tally_session_contest"
"""
enum tally_session_contest_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  tally_contest_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tally_session_contest_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input tally_session_contest_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tally_session_contest_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.tally_session_contest"
"""
input tally_session_contest_inc_input {
  session_id: Int
}

"""
input type for inserting data into table "sequent_backend.tally_session_contest"
"""
input tally_session_contest_insert_input {
  annotations: jsonb
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  session_id: Int
  tally_session_id: uuid
  tenant_id: uuid
}

"""aggregate max on columns"""
type tally_session_contest_max_fields {
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  session_id: Int
  tally_session_id: uuid
  tenant_id: uuid
}

"""aggregate min on columns"""
type tally_session_contest_min_fields {
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  session_id: Int
  tally_session_id: uuid
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.tally_session_contest"
"""
type tally_session_contest_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [tally_session_contest!]!
}

"""
on_conflict condition type for table "sequent_backend.tally_session_contest"
"""
input tally_session_contest_on_conflict {
  constraint: tally_session_contest_constraint!
  update_columns: [tally_session_contest_update_column!]! = []
  where: tally_session_contest_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.tally_session_contest".
"""
input tally_session_contest_order_by {
  annotations: order_by
  area_id: order_by
  contest_id: order_by
  created_at: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  session_id: order_by
  tally_session_id: order_by
  tenant_id: order_by
}

"""
primary key columns input for table: sequent_backend.tally_session_contest
"""
input tally_session_contest_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tally_session_contest_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.tally_session_contest"
"""
enum tally_session_contest_select_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  session_id
  """column name"""
  tally_session_id
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.tally_session_contest"
"""
input tally_session_contest_set_input {
  annotations: jsonb
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  session_id: Int
  tally_session_id: uuid
  tenant_id: uuid
}

"""aggregate stddev on columns"""
type tally_session_contest_stddev_fields {
  session_id: Float
}

"""aggregate stddev_pop on columns"""
type tally_session_contest_stddev_pop_fields {
  session_id: Float
}

"""aggregate stddev_samp on columns"""
type tally_session_contest_stddev_samp_fields {
  session_id: Float
}

"""
Streaming cursor of the table "sequent_backend_tally_session_contest"
"""
input tally_session_contest_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tally_session_contest_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tally_session_contest_stream_cursor_value_input {
  annotations: jsonb
  area_id: uuid
  contest_id: uuid
  created_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  session_id: Int
  tally_session_id: uuid
  tenant_id: uuid
}

"""aggregate sum on columns"""
type tally_session_contest_sum_fields {
  session_id: Int
}

"""
update columns of table "sequent_backend.tally_session_contest"
"""
enum tally_session_contest_update_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  session_id
  """column name"""
  tally_session_id
  """column name"""
  tenant_id
}

input tally_session_contest_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: tally_session_contest_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: tally_session_contest_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: tally_session_contest_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: tally_session_contest_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: tally_session_contest_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: tally_session_contest_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: tally_session_contest_set_input
  """filter the rows which have to be updated"""
  where: tally_session_contest_bool_exp!
}

"""aggregate var_pop on columns"""
type tally_session_contest_var_pop_fields {
  session_id: Float
}

"""aggregate var_samp on columns"""
type tally_session_contest_var_samp_fields {
  session_id: Float
}

"""aggregate variance on columns"""
type tally_session_contest_variance_fields {
  session_id: Float
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tally_session_delete_at_path_input {
  annotations: [String!]
  configuration: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input tally_session_delete_elem_input {
  annotations: Int
  configuration: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tally_session_delete_key_input {
  annotations: String
  configuration: String
  labels: String
}

"""
columns and relationships of "sequent_backend.tally_session_execution"
"""
type tally_session_execution {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  current_message_id: Int!
  documents(
    """JSON select path"""
    path: String
  ): jsonb
  election_event_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  results_event_id: uuid
  session_ids: [Int!]
  status(
    """JSON select path"""
    path: String
  ): jsonb
  tally_session_id: uuid!
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.tally_session_execution"
"""
type tally_session_execution_aggregate {
  aggregate: tally_session_execution_aggregate_fields
  nodes: [tally_session_execution!]!
}

"""
aggregate fields of "sequent_backend.tally_session_execution"
"""
type tally_session_execution_aggregate_fields {
  avg: tally_session_execution_avg_fields
  count(columns: [tally_session_execution_select_column!], distinct: Boolean): Int!
  max: tally_session_execution_max_fields
  min: tally_session_execution_min_fields
  stddev: tally_session_execution_stddev_fields
  stddev_pop: tally_session_execution_stddev_pop_fields
  stddev_samp: tally_session_execution_stddev_samp_fields
  sum: tally_session_execution_sum_fields
  var_pop: tally_session_execution_var_pop_fields
  var_samp: tally_session_execution_var_samp_fields
  variance: tally_session_execution_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tally_session_execution_append_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
  status: jsonb
}

"""aggregate avg on columns"""
type tally_session_execution_avg_fields {
  current_message_id: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.tally_session_execution". All fields are combined with a logical 'AND'.
"""
input tally_session_execution_bool_exp {
  _and: [tally_session_execution_bool_exp!]
  _not: tally_session_execution_bool_exp
  _or: [tally_session_execution_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  current_message_id: Int_comparison_exp
  documents: jsonb_comparison_exp
  election_event_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  results_event_id: uuid_comparison_exp
  session_ids: Int_array_comparison_exp
  status: jsonb_comparison_exp
  tally_session_id: uuid_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.tally_session_execution"
"""
enum tally_session_execution_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  tally_session_execution_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tally_session_execution_delete_at_path_input {
  annotations: [String!]
  documents: [String!]
  labels: [String!]
  status: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input tally_session_execution_delete_elem_input {
  annotations: Int
  documents: Int
  labels: Int
  status: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tally_session_execution_delete_key_input {
  annotations: String
  documents: String
  labels: String
  status: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.tally_session_execution"
"""
input tally_session_execution_inc_input {
  current_message_id: Int
}

"""
input type for inserting data into table "sequent_backend.tally_session_execution"
"""
input tally_session_execution_insert_input {
  annotations: jsonb
  created_at: timestamptz
  current_message_id: Int
  documents: jsonb
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  results_event_id: uuid
  session_ids: [Int!]
  status: jsonb
  tally_session_id: uuid
  tenant_id: uuid
}

"""aggregate max on columns"""
type tally_session_execution_max_fields {
  created_at: timestamptz
  current_message_id: Int
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  results_event_id: uuid
  session_ids: [Int!]
  tally_session_id: uuid
  tenant_id: uuid
}

"""aggregate min on columns"""
type tally_session_execution_min_fields {
  created_at: timestamptz
  current_message_id: Int
  election_event_id: uuid
  id: uuid
  last_updated_at: timestamptz
  results_event_id: uuid
  session_ids: [Int!]
  tally_session_id: uuid
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.tally_session_execution"
"""
type tally_session_execution_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [tally_session_execution!]!
}

"""
on_conflict condition type for table "sequent_backend.tally_session_execution"
"""
input tally_session_execution_on_conflict {
  constraint: tally_session_execution_constraint!
  update_columns: [tally_session_execution_update_column!]! = []
  where: tally_session_execution_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.tally_session_execution".
"""
input tally_session_execution_order_by {
  annotations: order_by
  created_at: order_by
  current_message_id: order_by
  documents: order_by
  election_event_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  results_event_id: order_by
  session_ids: order_by
  status: order_by
  tally_session_id: order_by
  tenant_id: order_by
}

"""
primary key columns input for table: sequent_backend.tally_session_execution
"""
input tally_session_execution_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tally_session_execution_prepend_input {
  annotations: jsonb
  documents: jsonb
  labels: jsonb
  status: jsonb
}

"""
select columns of table "sequent_backend.tally_session_execution"
"""
enum tally_session_execution_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  current_message_id
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  results_event_id
  """column name"""
  session_ids
  """column name"""
  status
  """column name"""
  tally_session_id
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.tally_session_execution"
"""
input tally_session_execution_set_input {
  annotations: jsonb
  created_at: timestamptz
  current_message_id: Int
  documents: jsonb
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  results_event_id: uuid
  session_ids: [Int!]
  status: jsonb
  tally_session_id: uuid
  tenant_id: uuid
}

"""aggregate stddev on columns"""
type tally_session_execution_stddev_fields {
  current_message_id: Float
}

"""aggregate stddev_pop on columns"""
type tally_session_execution_stddev_pop_fields {
  current_message_id: Float
}

"""aggregate stddev_samp on columns"""
type tally_session_execution_stddev_samp_fields {
  current_message_id: Float
}

"""
Streaming cursor of the table "sequent_backend_tally_session_execution"
"""
input tally_session_execution_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tally_session_execution_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tally_session_execution_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  current_message_id: Int
  documents: jsonb
  election_event_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  results_event_id: uuid
  session_ids: [Int!]
  status: jsonb
  tally_session_id: uuid
  tenant_id: uuid
}

"""aggregate sum on columns"""
type tally_session_execution_sum_fields {
  current_message_id: Int
}

"""
update columns of table "sequent_backend.tally_session_execution"
"""
enum tally_session_execution_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  current_message_id
  """column name"""
  documents
  """column name"""
  election_event_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  results_event_id
  """column name"""
  session_ids
  """column name"""
  status
  """column name"""
  tally_session_id
  """column name"""
  tenant_id
}

input tally_session_execution_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: tally_session_execution_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: tally_session_execution_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: tally_session_execution_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: tally_session_execution_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: tally_session_execution_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: tally_session_execution_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: tally_session_execution_set_input
  """filter the rows which have to be updated"""
  where: tally_session_execution_bool_exp!
}

"""aggregate var_pop on columns"""
type tally_session_execution_var_pop_fields {
  current_message_id: Float
}

"""aggregate var_samp on columns"""
type tally_session_execution_var_samp_fields {
  current_message_id: Float
}

"""aggregate variance on columns"""
type tally_session_execution_variance_fields {
  current_message_id: Float
}

"""
input type for incrementing numeric columns in table "sequent_backend.tally_session"
"""
input tally_session_inc_input {
  threshold: Int
}

"""
input type for inserting data into table "sequent_backend.tally_session"
"""
input tally_session_insert_input {
  annotations: jsonb
  area_ids: [uuid!]
  configuration: jsonb
  created_at: timestamptz
  election_event_id: uuid
  election_ids: [uuid!]
  execution_status: String
  id: uuid
  is_execution_completed: Boolean
  keys_ceremony_id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  permission_label: [String!]
  tally_type: String
  tenant_id: uuid
  threshold: Int
}

"""aggregate max on columns"""
type tally_session_max_fields {
  area_ids: [uuid!]
  created_at: timestamptz
  election_event_id: uuid
  election_ids: [uuid!]
  execution_status: String
  id: uuid
  keys_ceremony_id: uuid
  last_updated_at: timestamptz
  permission_label: [String!]
  tally_type: String
  tenant_id: uuid
  threshold: Int
}

"""aggregate min on columns"""
type tally_session_min_fields {
  area_ids: [uuid!]
  created_at: timestamptz
  election_event_id: uuid
  election_ids: [uuid!]
  execution_status: String
  id: uuid
  keys_ceremony_id: uuid
  last_updated_at: timestamptz
  permission_label: [String!]
  tally_type: String
  tenant_id: uuid
  threshold: Int
}

"""
response of any mutation on the table "sequent_backend.tally_session"
"""
type tally_session_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [tally_session!]!
}

"""
on_conflict condition type for table "sequent_backend.tally_session"
"""
input tally_session_on_conflict {
  constraint: tally_session_constraint!
  update_columns: [tally_session_update_column!]! = []
  where: tally_session_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.tally_session".
"""
input tally_session_order_by {
  annotations: order_by
  area_ids: order_by
  configuration: order_by
  created_at: order_by
  election_event_id: order_by
  election_ids: order_by
  execution_status: order_by
  id: order_by
  is_execution_completed: order_by
  keys_ceremony_id: order_by
  labels: order_by
  last_updated_at: order_by
  permission_label: order_by
  tally_type: order_by
  tenant_id: order_by
  threshold: order_by
}

"""primary key columns input for table: sequent_backend.tally_session"""
input tally_session_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tally_session_prepend_input {
  annotations: jsonb
  configuration: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.tally_session"
"""
enum tally_session_select_column {
  """column name"""
  annotations
  """column name"""
  area_ids
  """column name"""
  configuration
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_ids
  """column name"""
  execution_status
  """column name"""
  id
  """column name"""
  is_execution_completed
  """column name"""
  keys_ceremony_id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  permission_label
  """column name"""
  tally_type
  """column name"""
  tenant_id
  """column name"""
  threshold
}

"""
input type for updating data in table "sequent_backend.tally_session"
"""
input tally_session_set_input {
  annotations: jsonb
  area_ids: [uuid!]
  configuration: jsonb
  created_at: timestamptz
  election_event_id: uuid
  election_ids: [uuid!]
  execution_status: String
  id: uuid
  is_execution_completed: Boolean
  keys_ceremony_id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  permission_label: [String!]
  tally_type: String
  tenant_id: uuid
  threshold: Int
}

"""aggregate stddev on columns"""
type tally_session_stddev_fields {
  threshold: Float
}

"""aggregate stddev_pop on columns"""
type tally_session_stddev_pop_fields {
  threshold: Float
}

"""aggregate stddev_samp on columns"""
type tally_session_stddev_samp_fields {
  threshold: Float
}

"""
Streaming cursor of the table "sequent_backend_tally_session"
"""
input tally_session_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tally_session_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tally_session_stream_cursor_value_input {
  annotations: jsonb
  area_ids: [uuid!]
  configuration: jsonb
  created_at: timestamptz
  election_event_id: uuid
  election_ids: [uuid!]
  execution_status: String
  id: uuid
  is_execution_completed: Boolean
  keys_ceremony_id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  permission_label: [String!]
  tally_type: String
  tenant_id: uuid
  threshold: Int
}

"""aggregate sum on columns"""
type tally_session_sum_fields {
  threshold: Int
}

"""
update columns of table "sequent_backend.tally_session"
"""
enum tally_session_update_column {
  """column name"""
  annotations
  """column name"""
  area_ids
  """column name"""
  configuration
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  election_ids
  """column name"""
  execution_status
  """column name"""
  id
  """column name"""
  is_execution_completed
  """column name"""
  keys_ceremony_id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  permission_label
  """column name"""
  tally_type
  """column name"""
  tenant_id
  """column name"""
  threshold
}

input tally_session_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: tally_session_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: tally_session_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: tally_session_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: tally_session_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: tally_session_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: tally_session_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: tally_session_set_input
  """filter the rows which have to be updated"""
  where: tally_session_bool_exp!
}

"""aggregate var_pop on columns"""
type tally_session_var_pop_fields {
  threshold: Float
}

"""aggregate var_samp on columns"""
type tally_session_var_samp_fields {
  threshold: Float
}

"""aggregate variance on columns"""
type tally_session_variance_fields {
  threshold: Float
}

"""
columns and relationships of "sequent_backend.tally_sheet"
"""
type tally_sheet {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  area_id: uuid!
  channel: String
  content(
    """JSON select path"""
    path: String
  ): jsonb
  contest_id: uuid!
  created_at: timestamptz!
  created_by_user_id: String!
  deleted_at: timestamptz
  election_event_id: uuid!
  election_id: uuid!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz!
  published_at: timestamptz
  published_by_user_id: String
  tenant_id: uuid!
}

"""
aggregated selection of "sequent_backend.tally_sheet"
"""
type tally_sheet_aggregate {
  aggregate: tally_sheet_aggregate_fields
  nodes: [tally_sheet!]!
}

"""
aggregate fields of "sequent_backend.tally_sheet"
"""
type tally_sheet_aggregate_fields {
  count(columns: [tally_sheet_select_column!], distinct: Boolean): Int!
  max: tally_sheet_max_fields
  min: tally_sheet_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tally_sheet_append_input {
  annotations: jsonb
  content: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.tally_sheet". All fields are combined with a logical 'AND'.
"""
input tally_sheet_bool_exp {
  _and: [tally_sheet_bool_exp!]
  _not: tally_sheet_bool_exp
  _or: [tally_sheet_bool_exp!]
  annotations: jsonb_comparison_exp
  area_id: uuid_comparison_exp
  channel: String_comparison_exp
  content: jsonb_comparison_exp
  contest_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by_user_id: String_comparison_exp
  deleted_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  election_id: uuid_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  published_at: timestamptz_comparison_exp
  published_by_user_id: String_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.tally_sheet"
"""
enum tally_sheet_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id", "election_event_id"
  """
  tally_sheet_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tally_sheet_delete_at_path_input {
  annotations: [String!]
  content: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input tally_sheet_delete_elem_input {
  annotations: Int
  content: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tally_sheet_delete_key_input {
  annotations: String
  content: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.tally_sheet"
"""
input tally_sheet_insert_input {
  annotations: jsonb
  area_id: uuid
  channel: String
  content: jsonb
  contest_id: uuid
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  published_at: timestamptz
  published_by_user_id: String
  tenant_id: uuid
}

"""aggregate max on columns"""
type tally_sheet_max_fields {
  area_id: uuid
  channel: String
  contest_id: uuid
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  published_at: timestamptz
  published_by_user_id: String
  tenant_id: uuid
}

"""aggregate min on columns"""
type tally_sheet_min_fields {
  area_id: uuid
  channel: String
  contest_id: uuid
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  last_updated_at: timestamptz
  published_at: timestamptz
  published_by_user_id: String
  tenant_id: uuid
}

"""
response of any mutation on the table "sequent_backend.tally_sheet"
"""
type tally_sheet_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [tally_sheet!]!
}

"""
on_conflict condition type for table "sequent_backend.tally_sheet"
"""
input tally_sheet_on_conflict {
  constraint: tally_sheet_constraint!
  update_columns: [tally_sheet_update_column!]! = []
  where: tally_sheet_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.tally_sheet".
"""
input tally_sheet_order_by {
  annotations: order_by
  area_id: order_by
  channel: order_by
  content: order_by
  contest_id: order_by
  created_at: order_by
  created_by_user_id: order_by
  deleted_at: order_by
  election_event_id: order_by
  election_id: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  published_at: order_by
  published_by_user_id: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.tally_sheet"""
input tally_sheet_pk_columns_input {
  election_event_id: uuid!
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tally_sheet_prepend_input {
  annotations: jsonb
  content: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.tally_sheet"
"""
enum tally_sheet_select_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  channel
  """column name"""
  content
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  created_by_user_id
  """column name"""
  deleted_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  published_at
  """column name"""
  published_by_user_id
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.tally_sheet"
"""
input tally_sheet_set_input {
  annotations: jsonb
  area_id: uuid
  channel: String
  content: jsonb
  contest_id: uuid
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  published_at: timestamptz
  published_by_user_id: String
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_tally_sheet"
"""
input tally_sheet_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tally_sheet_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tally_sheet_stream_cursor_value_input {
  annotations: jsonb
  area_id: uuid
  channel: String
  content: jsonb
  contest_id: uuid
  created_at: timestamptz
  created_by_user_id: String
  deleted_at: timestamptz
  election_event_id: uuid
  election_id: uuid
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  published_at: timestamptz
  published_by_user_id: String
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.tally_sheet"
"""
enum tally_sheet_update_column {
  """column name"""
  annotations
  """column name"""
  area_id
  """column name"""
  channel
  """column name"""
  content
  """column name"""
  contest_id
  """column name"""
  created_at
  """column name"""
  created_by_user_id
  """column name"""
  deleted_at
  """column name"""
  election_event_id
  """column name"""
  election_id
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  published_at
  """column name"""
  published_by_user_id
  """column name"""
  tenant_id
}

input tally_sheet_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: tally_sheet_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: tally_sheet_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: tally_sheet_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: tally_sheet_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: tally_sheet_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: tally_sheet_set_input
  """filter the rows which have to be updated"""
  where: tally_sheet_bool_exp!
}

"""
columns and relationships of "sequent_backend.tasks_execution"
"""
type tasks_execution {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  election_event_id: uuid
  end_at: timestamptz
  executed_by_user: String!
  execution_status: String!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  logs(
    """JSON select path"""
    path: String
  ): json
  name: String!
  start_at: timestamptz!
  """An object relationship"""
  tenant: tenant!
  tenant_id: uuid!
  type: String!
}

"""
aggregated selection of "sequent_backend.tasks_execution"
"""
type tasks_execution_aggregate {
  aggregate: tasks_execution_aggregate_fields
  nodes: [tasks_execution!]!
}

"""
aggregate fields of "sequent_backend.tasks_execution"
"""
type tasks_execution_aggregate_fields {
  count(columns: [tasks_execution_select_column!], distinct: Boolean): Int!
  max: tasks_execution_max_fields
  min: tasks_execution_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tasks_execution_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.tasks_execution". All fields are combined with a logical 'AND'.
"""
input tasks_execution_bool_exp {
  _and: [tasks_execution_bool_exp!]
  _not: tasks_execution_bool_exp
  _or: [tasks_execution_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  election_event_id: uuid_comparison_exp
  end_at: timestamptz_comparison_exp
  executed_by_user: String_comparison_exp
  execution_status: String_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  logs: json_comparison_exp
  name: String_comparison_exp
  start_at: timestamptz_comparison_exp
  tenant: tenant_bool_exp
  tenant_id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.tasks_execution"
"""
enum tasks_execution_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  tasks_execution_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tasks_execution_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input tasks_execution_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tasks_execution_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.tasks_execution"
"""
input tasks_execution_insert_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  end_at: timestamptz
  executed_by_user: String
  execution_status: String
  id: uuid
  labels: jsonb
  logs: json
  name: String
  start_at: timestamptz
  tenant: tenant_obj_rel_insert_input
  tenant_id: uuid
  type: String
}

"""aggregate max on columns"""
type tasks_execution_max_fields {
  created_at: timestamptz
  election_event_id: uuid
  end_at: timestamptz
  executed_by_user: String
  execution_status: String
  id: uuid
  name: String
  start_at: timestamptz
  tenant_id: uuid
  type: String
}

"""aggregate min on columns"""
type tasks_execution_min_fields {
  created_at: timestamptz
  election_event_id: uuid
  end_at: timestamptz
  executed_by_user: String
  execution_status: String
  id: uuid
  name: String
  start_at: timestamptz
  tenant_id: uuid
  type: String
}

"""
response of any mutation on the table "sequent_backend.tasks_execution"
"""
type tasks_execution_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [tasks_execution!]!
}

"""
on_conflict condition type for table "sequent_backend.tasks_execution"
"""
input tasks_execution_on_conflict {
  constraint: tasks_execution_constraint!
  update_columns: [tasks_execution_update_column!]! = []
  where: tasks_execution_bool_exp
}

"""
Ordering options when selecting data from "sequent_backend.tasks_execution".
"""
input tasks_execution_order_by {
  annotations: order_by
  created_at: order_by
  election_event_id: order_by
  end_at: order_by
  executed_by_user: order_by
  execution_status: order_by
  id: order_by
  labels: order_by
  logs: order_by
  name: order_by
  start_at: order_by
  tenant: tenant_order_by
  tenant_id: order_by
  type: order_by
}

"""primary key columns input for table: sequent_backend.tasks_execution"""
input tasks_execution_pk_columns_input {
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tasks_execution_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.tasks_execution"
"""
enum tasks_execution_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  end_at
  """column name"""
  executed_by_user
  """column name"""
  execution_status
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  logs
  """column name"""
  name
  """column name"""
  start_at
  """column name"""
  tenant_id
  """column name"""
  type
}

"""
input type for updating data in table "sequent_backend.tasks_execution"
"""
input tasks_execution_set_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  end_at: timestamptz
  executed_by_user: String
  execution_status: String
  id: uuid
  labels: jsonb
  logs: json
  name: String
  start_at: timestamptz
  tenant_id: uuid
  type: String
}

"""
Streaming cursor of the table "sequent_backend_tasks_execution"
"""
input tasks_execution_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tasks_execution_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tasks_execution_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  election_event_id: uuid
  end_at: timestamptz
  executed_by_user: String
  execution_status: String
  id: uuid
  labels: jsonb
  logs: json
  name: String
  start_at: timestamptz
  tenant_id: uuid
  type: String
}

"""
update columns of table "sequent_backend.tasks_execution"
"""
enum tasks_execution_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  election_event_id
  """column name"""
  end_at
  """column name"""
  executed_by_user
  """column name"""
  execution_status
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  logs
  """column name"""
  name
  """column name"""
  start_at
  """column name"""
  tenant_id
  """column name"""
  type
}

input tasks_execution_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: tasks_execution_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: tasks_execution_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: tasks_execution_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: tasks_execution_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: tasks_execution_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: tasks_execution_set_input
  """filter the rows which have to be updated"""
  where: tasks_execution_bool_exp!
}

"""
columns and relationships of "sequent_backend.template"
"""
type template {
  alias: String
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  communication_method: String!
  created_at: timestamptz!
  created_by: String!
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  template(
    """JSON select path"""
    path: String
  ): jsonb!
  tenant_id: uuid!
  type: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "sequent_backend.template"
"""
type template_aggregate {
  aggregate: template_aggregate_fields
  nodes: [template!]!
}

"""
aggregate fields of "sequent_backend.template"
"""
type template_aggregate_fields {
  count(columns: [template_select_column!], distinct: Boolean): Int!
  max: template_max_fields
  min: template_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input template_append_input {
  annotations: jsonb
  labels: jsonb
  template: jsonb
}

"""
Boolean expression to filter rows from the table "sequent_backend.template". All fields are combined with a logical 'AND'.
"""
input template_bool_exp {
  _and: [template_bool_exp!]
  _not: template_bool_exp
  _or: [template_bool_exp!]
  alias: String_comparison_exp
  annotations: jsonb_comparison_exp
  communication_method: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  template: jsonb_comparison_exp
  tenant_id: uuid_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.template"
"""
enum template_constraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  communication_template_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input template_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
  template: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input template_delete_elem_input {
  annotations: Int
  labels: Int
  template: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input template_delete_key_input {
  annotations: String
  labels: String
  template: String
}

"""
input type for inserting data into table "sequent_backend.template"
"""
input template_insert_input {
  alias: String
  annotations: jsonb
  communication_method: String
  created_at: timestamptz
  created_by: String
  id: uuid
  labels: jsonb
  template: jsonb
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type template_max_fields {
  alias: String
  communication_method: String
  created_at: timestamptz
  created_by: String
  id: uuid
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type template_min_fields {
  alias: String
  communication_method: String
  created_at: timestamptz
  created_by: String
  id: uuid
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "sequent_backend.template"
"""
type template_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [template!]!
}

"""
on_conflict condition type for table "sequent_backend.template"
"""
input template_on_conflict {
  constraint: template_constraint!
  update_columns: [template_update_column!]! = []
  where: template_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.template"."""
input template_order_by {
  alias: order_by
  annotations: order_by
  communication_method: order_by
  created_at: order_by
  created_by: order_by
  id: order_by
  labels: order_by
  template: order_by
  tenant_id: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: sequent_backend.template"""
input template_pk_columns_input {
  id: uuid!
  tenant_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input template_prepend_input {
  annotations: jsonb
  labels: jsonb
  template: jsonb
}

"""
select columns of table "sequent_backend.template"
"""
enum template_select_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  communication_method
  """column name"""
  created_at
  """column name"""
  created_by
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  template
  """column name"""
  tenant_id
  """column name"""
  type
  """column name"""
  updated_at
}

"""
input type for updating data in table "sequent_backend.template"
"""
input template_set_input {
  alias: String
  annotations: jsonb
  communication_method: String
  created_at: timestamptz
  created_by: String
  id: uuid
  labels: jsonb
  template: jsonb
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "sequent_backend_template"
"""
input template_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: template_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input template_stream_cursor_value_input {
  alias: String
  annotations: jsonb
  communication_method: String
  created_at: timestamptz
  created_by: String
  id: uuid
  labels: jsonb
  template: jsonb
  tenant_id: uuid
  type: String
  updated_at: timestamptz
}

"""
update columns of table "sequent_backend.template"
"""
enum template_update_column {
  """column name"""
  alias
  """column name"""
  annotations
  """column name"""
  communication_method
  """column name"""
  created_at
  """column name"""
  created_by
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  template
  """column name"""
  tenant_id
  """column name"""
  type
  """column name"""
  updated_at
}

input template_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: template_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: template_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: template_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: template_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: template_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: template_set_input
  """filter the rows which have to be updated"""
  where: template_bool_exp!
}

"""
columns and relationships of "sequent_backend.tenant"
"""
type tenant {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  id: uuid!
  is_active: Boolean!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  settings(
    """JSON select path"""
    path: String
  ): jsonb
  slug: String!
  test: Int
  updated_at: timestamptz!
  voting_channels(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "sequent_backend.tenant"
"""
type tenant_aggregate {
  aggregate: tenant_aggregate_fields
  nodes: [tenant!]!
}

"""
aggregate fields of "sequent_backend.tenant"
"""
type tenant_aggregate_fields {
  avg: tenant_avg_fields
  count(columns: [tenant_select_column!], distinct: Boolean): Int!
  max: tenant_max_fields
  min: tenant_min_fields
  stddev: tenant_stddev_fields
  stddev_pop: tenant_stddev_pop_fields
  stddev_samp: tenant_stddev_samp_fields
  sum: tenant_sum_fields
  var_pop: tenant_var_pop_fields
  var_samp: tenant_var_samp_fields
  variance: tenant_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tenant_append_input {
  annotations: jsonb
  labels: jsonb
  settings: jsonb
  voting_channels: jsonb
}

"""aggregate avg on columns"""
type tenant_avg_fields {
  test: Float
}

"""
Boolean expression to filter rows from the table "sequent_backend.tenant". All fields are combined with a logical 'AND'.
"""
input tenant_bool_exp {
  _and: [tenant_bool_exp!]
  _not: tenant_bool_exp
  _or: [tenant_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  labels: jsonb_comparison_exp
  settings: jsonb_comparison_exp
  slug: String_comparison_exp
  test: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  voting_channels: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.tenant"
"""
enum tenant_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tenant_pkey
  """
  unique or primary key constraint on columns "slug"
  """
  tenant_slug_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tenant_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
  settings: [String!]
  voting_channels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input tenant_delete_elem_input {
  annotations: Int
  labels: Int
  settings: Int
  voting_channels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tenant_delete_key_input {
  annotations: String
  labels: String
  settings: String
  voting_channels: String
}

"""
input type for incrementing numeric columns in table "sequent_backend.tenant"
"""
input tenant_inc_input {
  test: Int
}

"""
input type for inserting data into table "sequent_backend.tenant"
"""
input tenant_insert_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  is_active: Boolean
  labels: jsonb
  settings: jsonb
  slug: String
  test: Int
  updated_at: timestamptz
  voting_channels: jsonb
}

"""aggregate max on columns"""
type tenant_max_fields {
  created_at: timestamptz
  id: uuid
  slug: String
  test: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type tenant_min_fields {
  created_at: timestamptz
  id: uuid
  slug: String
  test: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "sequent_backend.tenant"
"""
type tenant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [tenant!]!
}

"""
input type for inserting object relation for remote table "sequent_backend.tenant"
"""
input tenant_obj_rel_insert_input {
  data: tenant_insert_input!
  """upsert condition"""
  on_conflict: tenant_on_conflict
}

"""
on_conflict condition type for table "sequent_backend.tenant"
"""
input tenant_on_conflict {
  constraint: tenant_constraint!
  update_columns: [tenant_update_column!]! = []
  where: tenant_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.tenant"."""
input tenant_order_by {
  annotations: order_by
  created_at: order_by
  id: order_by
  is_active: order_by
  labels: order_by
  settings: order_by
  slug: order_by
  test: order_by
  updated_at: order_by
  voting_channels: order_by
}

"""primary key columns input for table: sequent_backend.tenant"""
input tenant_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tenant_prepend_input {
  annotations: jsonb
  labels: jsonb
  settings: jsonb
  voting_channels: jsonb
}

"""
select columns of table "sequent_backend.tenant"
"""
enum tenant_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  id
  """column name"""
  is_active
  """column name"""
  labels
  """column name"""
  settings
  """column name"""
  slug
  """column name"""
  test
  """column name"""
  updated_at
  """column name"""
  voting_channels
}

"""
input type for updating data in table "sequent_backend.tenant"
"""
input tenant_set_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  is_active: Boolean
  labels: jsonb
  settings: jsonb
  slug: String
  test: Int
  updated_at: timestamptz
  voting_channels: jsonb
}

"""aggregate stddev on columns"""
type tenant_stddev_fields {
  test: Float
}

"""aggregate stddev_pop on columns"""
type tenant_stddev_pop_fields {
  test: Float
}

"""aggregate stddev_samp on columns"""
type tenant_stddev_samp_fields {
  test: Float
}

"""
Streaming cursor of the table "sequent_backend_tenant"
"""
input tenant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tenant_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tenant_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  is_active: Boolean
  labels: jsonb
  settings: jsonb
  slug: String
  test: Int
  updated_at: timestamptz
  voting_channels: jsonb
}

"""aggregate sum on columns"""
type tenant_sum_fields {
  test: Int
}

"""
update columns of table "sequent_backend.tenant"
"""
enum tenant_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  id
  """column name"""
  is_active
  """column name"""
  labels
  """column name"""
  settings
  """column name"""
  slug
  """column name"""
  test
  """column name"""
  updated_at
  """column name"""
  voting_channels
}

input tenant_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: tenant_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: tenant_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: tenant_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: tenant_delete_key_input
  """increments the numeric columns with given value of the filtered values"""
  _inc: tenant_inc_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: tenant_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: tenant_set_input
  """filter the rows which have to be updated"""
  where: tenant_bool_exp!
}

"""aggregate var_pop on columns"""
type tenant_var_pop_fields {
  test: Float
}

"""aggregate var_samp on columns"""
type tenant_var_samp_fields {
  test: Float
}

"""aggregate variance on columns"""
type tenant_variance_fields {
  test: Float
}

"""
columns and relationships of "sequent_backend.trustee"
"""
type trustee {
  annotations(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  id: uuid!
  labels(
    """JSON select path"""
    path: String
  ): jsonb
  last_updated_at: timestamptz
  name: String
  public_key: String
  tenant_id: uuid
}

"""
aggregated selection of "sequent_backend.trustee"
"""
type trustee_aggregate {
  aggregate: trustee_aggregate_fields
  nodes: [trustee!]!
}

input trustee_aggregate_bool_exp {
  count: trustee_aggregate_bool_exp_count
}

input trustee_aggregate_bool_exp_count {
  arguments: [trustee_select_column!]
  distinct: Boolean
  filter: trustee_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sequent_backend.trustee"
"""
type trustee_aggregate_fields {
  count(columns: [trustee_select_column!], distinct: Boolean): Int!
  max: trustee_max_fields
  min: trustee_min_fields
}

"""
order by aggregate values of table "sequent_backend.trustee"
"""
input trustee_aggregate_order_by {
  count: order_by
  max: trustee_max_order_by
  min: trustee_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input trustee_append_input {
  annotations: jsonb
  labels: jsonb
}

"""
input type for inserting array relation for remote table "sequent_backend.trustee"
"""
input trustee_arr_rel_insert_input {
  data: [trustee_insert_input!]!
  """upsert condition"""
  on_conflict: trustee_on_conflict
}

"""
Boolean expression to filter rows from the table "sequent_backend.trustee". All fields are combined with a logical 'AND'.
"""
input trustee_bool_exp {
  _and: [trustee_bool_exp!]
  _not: trustee_bool_exp
  _or: [trustee_bool_exp!]
  annotations: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  labels: jsonb_comparison_exp
  last_updated_at: timestamptz_comparison_exp
  name: String_comparison_exp
  public_key: String_comparison_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sequent_backend.trustee"
"""
enum trustee_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  trustee_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input trustee_delete_at_path_input {
  annotations: [String!]
  labels: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input trustee_delete_elem_input {
  annotations: Int
  labels: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input trustee_delete_key_input {
  annotations: String
  labels: String
}

"""
input type for inserting data into table "sequent_backend.trustee"
"""
input trustee_insert_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  public_key: String
  tenant_id: uuid
}

"""aggregate max on columns"""
type trustee_max_fields {
  created_at: timestamptz
  id: uuid
  last_updated_at: timestamptz
  name: String
  public_key: String
  tenant_id: uuid
}

"""
order by max() on columns of table "sequent_backend.trustee"
"""
input trustee_max_order_by {
  created_at: order_by
  id: order_by
  last_updated_at: order_by
  name: order_by
  public_key: order_by
  tenant_id: order_by
}

"""aggregate min on columns"""
type trustee_min_fields {
  created_at: timestamptz
  id: uuid
  last_updated_at: timestamptz
  name: String
  public_key: String
  tenant_id: uuid
}

"""
order by min() on columns of table "sequent_backend.trustee"
"""
input trustee_min_order_by {
  created_at: order_by
  id: order_by
  last_updated_at: order_by
  name: order_by
  public_key: order_by
  tenant_id: order_by
}

"""
response of any mutation on the table "sequent_backend.trustee"
"""
type trustee_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!
  """data from the rows affected by the mutation"""
  returning: [trustee!]!
}

"""
on_conflict condition type for table "sequent_backend.trustee"
"""
input trustee_on_conflict {
  constraint: trustee_constraint!
  update_columns: [trustee_update_column!]! = []
  where: trustee_bool_exp
}

"""Ordering options when selecting data from "sequent_backend.trustee"."""
input trustee_order_by {
  annotations: order_by
  created_at: order_by
  id: order_by
  labels: order_by
  last_updated_at: order_by
  name: order_by
  public_key: order_by
  tenant_id: order_by
}

"""primary key columns input for table: sequent_backend.trustee"""
input trustee_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input trustee_prepend_input {
  annotations: jsonb
  labels: jsonb
}

"""
select columns of table "sequent_backend.trustee"
"""
enum trustee_select_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  public_key
  """column name"""
  tenant_id
}

"""
input type for updating data in table "sequent_backend.trustee"
"""
input trustee_set_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  public_key: String
  tenant_id: uuid
}

"""
Streaming cursor of the table "sequent_backend_trustee"
"""
input trustee_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: trustee_stream_cursor_value_input!
  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input trustee_stream_cursor_value_input {
  annotations: jsonb
  created_at: timestamptz
  id: uuid
  labels: jsonb
  last_updated_at: timestamptz
  name: String
  public_key: String
  tenant_id: uuid
}

"""
update columns of table "sequent_backend.trustee"
"""
enum trustee_update_column {
  """column name"""
  annotations
  """column name"""
  created_at
  """column name"""
  id
  """column name"""
  labels
  """column name"""
  last_updated_at
  """column name"""
  name
  """column name"""
  public_key
  """column name"""
  tenant_id
}

input trustee_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: trustee_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: trustee_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: trustee_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: trustee_delete_key_input
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: trustee_prepend_input
  """sets the columns of the filtered rows to the given values"""
  _set: trustee_set_input
  """filter the rows which have to be updated"""
  where: trustee_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "sequent_backend.applications"
  """
  sequent_backend_applications(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]
    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!
  """
  fetch aggregated fields from the table: "sequent_backend.applications"
  """
  sequent_backend_applications_aggregate(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]
    """filter the rows returned"""
    where: applications_bool_exp
  ): applications_aggregate!
  """
  fetch data from the table: "sequent_backend.applications" using primary key columns
  """
  sequent_backend_applications_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): applications
  """
  fetch data from the table in a streaming manner: "sequent_backend.applications"
  """
  sequent_backend_applications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [applications_stream_cursor_input]!
    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!
  """
  fetch data from the table: "sequent_backend.area"
  """
  sequent_backend_area(
    """distinct select on columns"""
    distinct_on: [area_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [area_order_by!]
    """filter the rows returned"""
    where: area_bool_exp
  ): [area!]!
  """
  fetch aggregated fields from the table: "sequent_backend.area"
  """
  sequent_backend_area_aggregate(
    """distinct select on columns"""
    distinct_on: [area_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [area_order_by!]
    """filter the rows returned"""
    where: area_bool_exp
  ): area_aggregate!
  """
  fetch data from the table: "sequent_backend.area" using primary key columns
  """
  sequent_backend_area_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): area
  """
  fetch data from the table: "sequent_backend.area_contest"
  """
  sequent_backend_area_contest(
    """distinct select on columns"""
    distinct_on: [area_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [area_contest_order_by!]
    """filter the rows returned"""
    where: area_contest_bool_exp
  ): [area_contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.area_contest"
  """
  sequent_backend_area_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [area_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [area_contest_order_by!]
    """filter the rows returned"""
    where: area_contest_bool_exp
  ): area_contest_aggregate!
  """
  fetch data from the table: "sequent_backend.area_contest" using primary key columns
  """
  sequent_backend_area_contest_by_pk(id: uuid!): area_contest
  """
  fetch data from the table in a streaming manner: "sequent_backend.area_contest"
  """
  sequent_backend_area_contest_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [area_contest_stream_cursor_input]!
    """filter the rows returned"""
    where: area_contest_bool_exp
  ): [area_contest!]!
  """
  fetch data from the table in a streaming manner: "sequent_backend.area"
  """
  sequent_backend_area_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [area_stream_cursor_input]!
    """filter the rows returned"""
    where: area_bool_exp
  ): [area!]!
  """
  fetch data from the table: "sequent_backend.ballot_publication"
  """
  sequent_backend_ballot_publication(
    """distinct select on columns"""
    distinct_on: [ballot_publication_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [ballot_publication_order_by!]
    """filter the rows returned"""
    where: ballot_publication_bool_exp
  ): [ballot_publication!]!
  """
  fetch aggregated fields from the table: "sequent_backend.ballot_publication"
  """
  sequent_backend_ballot_publication_aggregate(
    """distinct select on columns"""
    distinct_on: [ballot_publication_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [ballot_publication_order_by!]
    """filter the rows returned"""
    where: ballot_publication_bool_exp
  ): ballot_publication_aggregate!
  """
  fetch data from the table: "sequent_backend.ballot_publication" using primary key columns
  """
  sequent_backend_ballot_publication_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): ballot_publication
  """
  fetch data from the table in a streaming manner: "sequent_backend.ballot_publication"
  """
  sequent_backend_ballot_publication_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ballot_publication_stream_cursor_input]!
    """filter the rows returned"""
    where: ballot_publication_bool_exp
  ): [ballot_publication!]!
  """
  fetch data from the table: "sequent_backend.ballot_style"
  """
  sequent_backend_ballot_style(
    """distinct select on columns"""
    distinct_on: [ballot_style_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [ballot_style_order_by!]
    """filter the rows returned"""
    where: ballot_style_bool_exp
  ): [ballot_style!]!
  """
  fetch aggregated fields from the table: "sequent_backend.ballot_style"
  """
  sequent_backend_ballot_style_aggregate(
    """distinct select on columns"""
    distinct_on: [ballot_style_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [ballot_style_order_by!]
    """filter the rows returned"""
    where: ballot_style_bool_exp
  ): ballot_style_aggregate!
  """
  fetch data from the table: "sequent_backend.ballot_style" using primary key columns
  """
  sequent_backend_ballot_style_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): ballot_style
  """
  fetch data from the table in a streaming manner: "sequent_backend.ballot_style"
  """
  sequent_backend_ballot_style_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ballot_style_stream_cursor_input]!
    """filter the rows returned"""
    where: ballot_style_bool_exp
  ): [ballot_style!]!
  """
  fetch data from the table: "sequent_backend.candidate"
  """
  sequent_backend_candidate(
    """distinct select on columns"""
    distinct_on: [candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [candidate_order_by!]
    """filter the rows returned"""
    where: candidate_bool_exp
  ): [candidate!]!
  """
  fetch aggregated fields from the table: "sequent_backend.candidate"
  """
  sequent_backend_candidate_aggregate(
    """distinct select on columns"""
    distinct_on: [candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [candidate_order_by!]
    """filter the rows returned"""
    where: candidate_bool_exp
  ): candidate_aggregate!
  """
  fetch data from the table: "sequent_backend.candidate" using primary key columns
  """
  sequent_backend_candidate_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): candidate
  """
  fetch data from the table in a streaming manner: "sequent_backend.candidate"
  """
  sequent_backend_candidate_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [candidate_stream_cursor_input]!
    """filter the rows returned"""
    where: candidate_bool_exp
  ): [candidate!]!
  """
  fetch data from the table: "sequent_backend.cast_vote"
  """
  sequent_backend_cast_vote(
    """distinct select on columns"""
    distinct_on: [cast_vote_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [cast_vote_order_by!]
    """filter the rows returned"""
    where: cast_vote_bool_exp
  ): [cast_vote!]!
  """
  fetch aggregated fields from the table: "sequent_backend.cast_vote"
  """
  sequent_backend_cast_vote_aggregate(
    """distinct select on columns"""
    distinct_on: [cast_vote_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [cast_vote_order_by!]
    """filter the rows returned"""
    where: cast_vote_bool_exp
  ): cast_vote_aggregate!
  """
  fetch data from the table: "sequent_backend.cast_vote" using primary key columns
  """
  sequent_backend_cast_vote_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): cast_vote
  """
  fetch data from the table in a streaming manner: "sequent_backend.cast_vote"
  """
  sequent_backend_cast_vote_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [cast_vote_stream_cursor_input]!
    """filter the rows returned"""
    where: cast_vote_bool_exp
  ): [cast_vote!]!
  """
  fetch data from the table: "sequent_backend.contest"
  """
  sequent_backend_contest(
    """distinct select on columns"""
    distinct_on: [contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [contest_order_by!]
    """filter the rows returned"""
    where: contest_bool_exp
  ): [contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.contest"
  """
  sequent_backend_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [contest_order_by!]
    """filter the rows returned"""
    where: contest_bool_exp
  ): contest_aggregate!
  """
  fetch data from the table: "sequent_backend.contest" using primary key columns
  """
  sequent_backend_contest_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): contest
  """
  fetch data from the table in a streaming manner: "sequent_backend.contest"
  """
  sequent_backend_contest_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [contest_stream_cursor_input]!
    """filter the rows returned"""
    where: contest_bool_exp
  ): [contest!]!
  """
  fetch data from the table: "sequent_backend.document"
  """
  sequent_backend_document(
    """distinct select on columns"""
    distinct_on: [document_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [document_order_by!]
    """filter the rows returned"""
    where: document_bool_exp
  ): [document!]!
  """
  fetch aggregated fields from the table: "sequent_backend.document"
  """
  sequent_backend_document_aggregate(
    """distinct select on columns"""
    distinct_on: [document_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [document_order_by!]
    """filter the rows returned"""
    where: document_bool_exp
  ): document_aggregate!
  """
  fetch data from the table: "sequent_backend.document" using primary key columns
  """
  sequent_backend_document_by_pk(id: uuid!): document
  """
  fetch data from the table in a streaming manner: "sequent_backend.document"
  """
  sequent_backend_document_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [document_stream_cursor_input]!
    """filter the rows returned"""
    where: document_bool_exp
  ): [document!]!
  """
  fetch data from the table: "sequent_backend.election"
  """
  sequent_backend_election(
    """distinct select on columns"""
    distinct_on: [election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_order_by!]
    """filter the rows returned"""
    where: election_bool_exp
  ): [election!]!
  """
  fetch aggregated fields from the table: "sequent_backend.election"
  """
  sequent_backend_election_aggregate(
    """distinct select on columns"""
    distinct_on: [election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_order_by!]
    """filter the rows returned"""
    where: election_bool_exp
  ): election_aggregate!
  """
  fetch data from the table: "sequent_backend.election" using primary key columns
  """
  sequent_backend_election_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): election
  """
  fetch data from the table: "sequent_backend.election_event"
  """
  sequent_backend_election_event(
    """distinct select on columns"""
    distinct_on: [election_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_event_order_by!]
    """filter the rows returned"""
    where: election_event_bool_exp
  ): [election_event!]!
  """
  fetch aggregated fields from the table: "sequent_backend.election_event"
  """
  sequent_backend_election_event_aggregate(
    """distinct select on columns"""
    distinct_on: [election_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_event_order_by!]
    """filter the rows returned"""
    where: election_event_bool_exp
  ): election_event_aggregate!
  """
  fetch data from the table: "sequent_backend.election_event" using primary key columns
  """
  sequent_backend_election_event_by_pk(id: uuid!): election_event
  """
  fetch data from the table in a streaming manner: "sequent_backend.election_event"
  """
  sequent_backend_election_event_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [election_event_stream_cursor_input]!
    """filter the rows returned"""
    where: election_event_bool_exp
  ): [election_event!]!
  """
  fetch data from the table: "sequent_backend.election_result"
  """
  sequent_backend_election_result(
    """distinct select on columns"""
    distinct_on: [election_result_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_result_order_by!]
    """filter the rows returned"""
    where: election_result_bool_exp
  ): [election_result!]!
  """
  fetch aggregated fields from the table: "sequent_backend.election_result"
  """
  sequent_backend_election_result_aggregate(
    """distinct select on columns"""
    distinct_on: [election_result_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_result_order_by!]
    """filter the rows returned"""
    where: election_result_bool_exp
  ): election_result_aggregate!
  """
  fetch data from the table: "sequent_backend.election_result" using primary key columns
  """
  sequent_backend_election_result_by_pk(id: uuid!): election_result
  """
  fetch data from the table in a streaming manner: "sequent_backend.election_result"
  """
  sequent_backend_election_result_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [election_result_stream_cursor_input]!
    """filter the rows returned"""
    where: election_result_bool_exp
  ): [election_result!]!
  """
  fetch data from the table in a streaming manner: "sequent_backend.election"
  """
  sequent_backend_election_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [election_stream_cursor_input]!
    """filter the rows returned"""
    where: election_bool_exp
  ): [election!]!
  """
  fetch data from the table: "sequent_backend.election_type"
  """
  sequent_backend_election_type(
    """distinct select on columns"""
    distinct_on: [election_type_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_type_order_by!]
    """filter the rows returned"""
    where: election_type_bool_exp
  ): [election_type!]!
  """
  fetch aggregated fields from the table: "sequent_backend.election_type"
  """
  sequent_backend_election_type_aggregate(
    """distinct select on columns"""
    distinct_on: [election_type_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [election_type_order_by!]
    """filter the rows returned"""
    where: election_type_bool_exp
  ): election_type_aggregate!
  """
  fetch data from the table: "sequent_backend.election_type" using primary key columns
  """
  sequent_backend_election_type_by_pk(id: uuid!, tenant_id: uuid!): election_type
  """
  fetch data from the table in a streaming manner: "sequent_backend.election_type"
  """
  sequent_backend_election_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [election_type_stream_cursor_input]!
    """filter the rows returned"""
    where: election_type_bool_exp
  ): [election_type!]!
  """
  fetch data from the table: "sequent_backend.event_execution"
  """
  sequent_backend_event_execution(
    """distinct select on columns"""
    distinct_on: [event_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [event_execution_order_by!]
    """filter the rows returned"""
    where: event_execution_bool_exp
  ): [event_execution!]!
  """
  fetch aggregated fields from the table: "sequent_backend.event_execution"
  """
  sequent_backend_event_execution_aggregate(
    """distinct select on columns"""
    distinct_on: [event_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [event_execution_order_by!]
    """filter the rows returned"""
    where: event_execution_bool_exp
  ): event_execution_aggregate!
  """
  fetch data from the table: "sequent_backend.event_execution" using primary key columns
  """
  sequent_backend_event_execution_by_pk(id: uuid!): event_execution
  """
  fetch data from the table in a streaming manner: "sequent_backend.event_execution"
  """
  sequent_backend_event_execution_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [event_execution_stream_cursor_input]!
    """filter the rows returned"""
    where: event_execution_bool_exp
  ): [event_execution!]!
  """
  fetch data from the table: "sequent_backend.keys_ceremony"
  """
  sequent_backend_keys_ceremony(
    """distinct select on columns"""
    distinct_on: [keys_ceremony_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [keys_ceremony_order_by!]
    """filter the rows returned"""
    where: keys_ceremony_bool_exp
  ): [keys_ceremony!]!
  """
  fetch aggregated fields from the table: "sequent_backend.keys_ceremony"
  """
  sequent_backend_keys_ceremony_aggregate(
    """distinct select on columns"""
    distinct_on: [keys_ceremony_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [keys_ceremony_order_by!]
    """filter the rows returned"""
    where: keys_ceremony_bool_exp
  ): keys_ceremony_aggregate!
  """
  fetch data from the table: "sequent_backend.keys_ceremony" using primary key columns
  """
  sequent_backend_keys_ceremony_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): keys_ceremony
  """
  fetch data from the table in a streaming manner: "sequent_backend.keys_ceremony"
  """
  sequent_backend_keys_ceremony_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [keys_ceremony_stream_cursor_input]!
    """filter the rows returned"""
    where: keys_ceremony_bool_exp
  ): [keys_ceremony!]!
  """
  fetch data from the table: "sequent_backend.lock"
  """
  sequent_backend_lock(
    """distinct select on columns"""
    distinct_on: [lock_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [lock_order_by!]
    """filter the rows returned"""
    where: lock_bool_exp
  ): [lock!]!
  """
  fetch aggregated fields from the table: "sequent_backend.lock"
  """
  sequent_backend_lock_aggregate(
    """distinct select on columns"""
    distinct_on: [lock_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [lock_order_by!]
    """filter the rows returned"""
    where: lock_bool_exp
  ): lock_aggregate!
  """
  fetch data from the table: "sequent_backend.lock" using primary key columns
  """
  sequent_backend_lock_by_pk(key: String!): lock
  """
  fetch data from the table in a streaming manner: "sequent_backend.lock"
  """
  sequent_backend_lock_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [lock_stream_cursor_input]!
    """filter the rows returned"""
    where: lock_bool_exp
  ): [lock!]!
  """
  fetch data from the table: "sequent_backend.notification"
  """
  sequent_backend_notification(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]
    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!
  """
  fetch aggregated fields from the table: "sequent_backend.notification"
  """
  sequent_backend_notification_aggregate(
    """distinct select on columns"""
    distinct_on: [notification_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [notification_order_by!]
    """filter the rows returned"""
    where: notification_bool_exp
  ): notification_aggregate!
  """
  fetch data from the table: "sequent_backend.notification" using primary key columns
  """
  sequent_backend_notification_by_pk(id: uuid!): notification
  """
  fetch data from the table in a streaming manner: "sequent_backend.notification"
  """
  sequent_backend_notification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [notification_stream_cursor_input]!
    """filter the rows returned"""
    where: notification_bool_exp
  ): [notification!]!
  """
  fetch data from the table: "sequent_backend.report"
  """
  sequent_backend_report(
    """distinct select on columns"""
    distinct_on: [report_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [report_order_by!]
    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!
  """
  fetch aggregated fields from the table: "sequent_backend.report"
  """
  sequent_backend_report_aggregate(
    """distinct select on columns"""
    distinct_on: [report_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [report_order_by!]
    """filter the rows returned"""
    where: report_bool_exp
  ): report_aggregate!
  """
  fetch data from the table: "sequent_backend.report" using primary key columns
  """
  sequent_backend_report_by_pk(id: uuid!): report
  """
  fetch data from the table in a streaming manner: "sequent_backend.report"
  """
  sequent_backend_report_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [report_stream_cursor_input]!
    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!
  """
  fetch data from the table: "sequent_backend.results_area_contest"
  """
  sequent_backend_results_area_contest(
    """distinct select on columns"""
    distinct_on: [results_area_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_area_contest_order_by!]
    """filter the rows returned"""
    where: results_area_contest_bool_exp
  ): [results_area_contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_area_contest"
  """
  sequent_backend_results_area_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [results_area_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_area_contest_order_by!]
    """filter the rows returned"""
    where: results_area_contest_bool_exp
  ): results_area_contest_aggregate!
  """
  fetch data from the table: "sequent_backend.results_area_contest" using primary key columns
  """
  sequent_backend_results_area_contest_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_area_contest
  """
  fetch data from the table: "sequent_backend.results_area_contest_candidate"
  """
  sequent_backend_results_area_contest_candidate(
    """distinct select on columns"""
    distinct_on: [results_area_contest_candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_area_contest_candidate_order_by!]
    """filter the rows returned"""
    where: results_area_contest_candidate_bool_exp
  ): [results_area_contest_candidate!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_area_contest_candidate"
  """
  sequent_backend_results_area_contest_candidate_aggregate(
    """distinct select on columns"""
    distinct_on: [results_area_contest_candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_area_contest_candidate_order_by!]
    """filter the rows returned"""
    where: results_area_contest_candidate_bool_exp
  ): results_area_contest_candidate_aggregate!
  """
  fetch data from the table: "sequent_backend.results_area_contest_candidate" using primary key columns
  """
  sequent_backend_results_area_contest_candidate_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_area_contest_candidate
  """
  fetch data from the table in a streaming manner: "sequent_backend.results_area_contest_candidate"
  """
  sequent_backend_results_area_contest_candidate_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [results_area_contest_candidate_stream_cursor_input]!
    """filter the rows returned"""
    where: results_area_contest_candidate_bool_exp
  ): [results_area_contest_candidate!]!
  """
  fetch data from the table in a streaming manner: "sequent_backend.results_area_contest"
  """
  sequent_backend_results_area_contest_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [results_area_contest_stream_cursor_input]!
    """filter the rows returned"""
    where: results_area_contest_bool_exp
  ): [results_area_contest!]!
  """
  fetch data from the table: "sequent_backend.results_contest"
  """
  sequent_backend_results_contest(
    """distinct select on columns"""
    distinct_on: [results_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_contest_order_by!]
    """filter the rows returned"""
    where: results_contest_bool_exp
  ): [results_contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_contest"
  """
  sequent_backend_results_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [results_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_contest_order_by!]
    """filter the rows returned"""
    where: results_contest_bool_exp
  ): results_contest_aggregate!
  """
  fetch data from the table: "sequent_backend.results_contest" using primary key columns
  """
  sequent_backend_results_contest_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_contest
  """
  fetch data from the table: "sequent_backend.results_contest_candidate"
  """
  sequent_backend_results_contest_candidate(
    """distinct select on columns"""
    distinct_on: [results_contest_candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_contest_candidate_order_by!]
    """filter the rows returned"""
    where: results_contest_candidate_bool_exp
  ): [results_contest_candidate!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_contest_candidate"
  """
  sequent_backend_results_contest_candidate_aggregate(
    """distinct select on columns"""
    distinct_on: [results_contest_candidate_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_contest_candidate_order_by!]
    """filter the rows returned"""
    where: results_contest_candidate_bool_exp
  ): results_contest_candidate_aggregate!
  """
  fetch data from the table: "sequent_backend.results_contest_candidate" using primary key columns
  """
  sequent_backend_results_contest_candidate_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_contest_candidate
  """
  fetch data from the table in a streaming manner: "sequent_backend.results_contest_candidate"
  """
  sequent_backend_results_contest_candidate_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [results_contest_candidate_stream_cursor_input]!
    """filter the rows returned"""
    where: results_contest_candidate_bool_exp
  ): [results_contest_candidate!]!
  """
  fetch data from the table in a streaming manner: "sequent_backend.results_contest"
  """
  sequent_backend_results_contest_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [results_contest_stream_cursor_input]!
    """filter the rows returned"""
    where: results_contest_bool_exp
  ): [results_contest!]!
  """
  fetch data from the table: "sequent_backend.results_election"
  """
  sequent_backend_results_election(
    """distinct select on columns"""
    distinct_on: [results_election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_election_order_by!]
    """filter the rows returned"""
    where: results_election_bool_exp
  ): [results_election!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_election"
  """
  sequent_backend_results_election_aggregate(
    """distinct select on columns"""
    distinct_on: [results_election_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_election_order_by!]
    """filter the rows returned"""
    where: results_election_bool_exp
  ): results_election_aggregate!
  """
  fetch data from the table: "sequent_backend.results_election_area"
  """
  sequent_backend_results_election_area(
    """distinct select on columns"""
    distinct_on: [results_election_area_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_election_area_order_by!]
    """filter the rows returned"""
    where: results_election_area_bool_exp
  ): [results_election_area!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_election_area"
  """
  sequent_backend_results_election_area_aggregate(
    """distinct select on columns"""
    distinct_on: [results_election_area_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_election_area_order_by!]
    """filter the rows returned"""
    where: results_election_area_bool_exp
  ): results_election_area_aggregate!
  """
  fetch data from the table: "sequent_backend.results_election_area" using primary key columns
  """
  sequent_backend_results_election_area_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_election_area
  """
  fetch data from the table in a streaming manner: "sequent_backend.results_election_area"
  """
  sequent_backend_results_election_area_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [results_election_area_stream_cursor_input]!
    """filter the rows returned"""
    where: results_election_area_bool_exp
  ): [results_election_area!]!
  """
  fetch data from the table: "sequent_backend.results_election" using primary key columns
  """
  sequent_backend_results_election_by_pk(election_event_id: uuid!, id: uuid!, results_event_id: uuid!, tenant_id: uuid!): results_election
  """
  fetch data from the table in a streaming manner: "sequent_backend.results_election"
  """
  sequent_backend_results_election_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [results_election_stream_cursor_input]!
    """filter the rows returned"""
    where: results_election_bool_exp
  ): [results_election!]!
  """
  fetch data from the table: "sequent_backend.results_event"
  """
  sequent_backend_results_event(
    """distinct select on columns"""
    distinct_on: [results_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_event_order_by!]
    """filter the rows returned"""
    where: results_event_bool_exp
  ): [results_event!]!
  """
  fetch aggregated fields from the table: "sequent_backend.results_event"
  """
  sequent_backend_results_event_aggregate(
    """distinct select on columns"""
    distinct_on: [results_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [results_event_order_by!]
    """filter the rows returned"""
    where: results_event_bool_exp
  ): results_event_aggregate!
  """
  fetch data from the table: "sequent_backend.results_event" using primary key columns
  """
  sequent_backend_results_event_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): results_event
  """
  fetch data from the table in a streaming manner: "sequent_backend.results_event"
  """
  sequent_backend_results_event_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [results_event_stream_cursor_input]!
    """filter the rows returned"""
    where: results_event_bool_exp
  ): [results_event!]!
  """
  fetch data from the table: "sequent_backend.scheduled_event"
  """
  sequent_backend_scheduled_event(
    """distinct select on columns"""
    distinct_on: [scheduled_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [scheduled_event_order_by!]
    """filter the rows returned"""
    where: scheduled_event_bool_exp
  ): [scheduled_event!]!
  """
  fetch aggregated fields from the table: "sequent_backend.scheduled_event"
  """
  sequent_backend_scheduled_event_aggregate(
    """distinct select on columns"""
    distinct_on: [scheduled_event_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [scheduled_event_order_by!]
    """filter the rows returned"""
    where: scheduled_event_bool_exp
  ): scheduled_event_aggregate!
  """
  fetch data from the table: "sequent_backend.scheduled_event" using primary key columns
  """
  sequent_backend_scheduled_event_by_pk(id: uuid!): scheduled_event
  """
  fetch data from the table in a streaming manner: "sequent_backend.scheduled_event"
  """
  sequent_backend_scheduled_event_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [scheduled_event_stream_cursor_input]!
    """filter the rows returned"""
    where: scheduled_event_bool_exp
  ): [scheduled_event!]!
  """
  fetch data from the table: "sequent_backend.secret"
  """
  sequent_backend_secret(
    """distinct select on columns"""
    distinct_on: [secret_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [secret_order_by!]
    """filter the rows returned"""
    where: secret_bool_exp
  ): [secret!]!
  """
  fetch aggregated fields from the table: "sequent_backend.secret"
  """
  sequent_backend_secret_aggregate(
    """distinct select on columns"""
    distinct_on: [secret_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [secret_order_by!]
    """filter the rows returned"""
    where: secret_bool_exp
  ): secret_aggregate!
  """
  fetch data from the table: "sequent_backend.secret" using primary key columns
  """
  sequent_backend_secret_by_pk(id: uuid!, key: String!, tenant_id: uuid!): secret
  """
  fetch data from the table in a streaming manner: "sequent_backend.secret"
  """
  sequent_backend_secret_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [secret_stream_cursor_input]!
    """filter the rows returned"""
    where: secret_bool_exp
  ): [secret!]!
  """
  fetch data from the table: "sequent_backend.support_material"
  """
  sequent_backend_support_material(
    """distinct select on columns"""
    distinct_on: [support_material_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [support_material_order_by!]
    """filter the rows returned"""
    where: support_material_bool_exp
  ): [support_material!]!
  """
  fetch aggregated fields from the table: "sequent_backend.support_material"
  """
  sequent_backend_support_material_aggregate(
    """distinct select on columns"""
    distinct_on: [support_material_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [support_material_order_by!]
    """filter the rows returned"""
    where: support_material_bool_exp
  ): support_material_aggregate!
  """
  fetch data from the table: "sequent_backend.support_material" using primary key columns
  """
  sequent_backend_support_material_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): support_material
  """
  fetch data from the table in a streaming manner: "sequent_backend.support_material"
  """
  sequent_backend_support_material_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [support_material_stream_cursor_input]!
    """filter the rows returned"""
    where: support_material_bool_exp
  ): [support_material!]!
  """
  fetch data from the table: "sequent_backend.tally_session"
  """
  sequent_backend_tally_session(
    """distinct select on columns"""
    distinct_on: [tally_session_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_order_by!]
    """filter the rows returned"""
    where: tally_session_bool_exp
  ): [tally_session!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tally_session"
  """
  sequent_backend_tally_session_aggregate(
    """distinct select on columns"""
    distinct_on: [tally_session_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_order_by!]
    """filter the rows returned"""
    where: tally_session_bool_exp
  ): tally_session_aggregate!
  """
  fetch data from the table: "sequent_backend.tally_session" using primary key columns
  """
  sequent_backend_tally_session_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session
  """
  fetch data from the table: "sequent_backend.tally_session_contest"
  """
  sequent_backend_tally_session_contest(
    """distinct select on columns"""
    distinct_on: [tally_session_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_contest_order_by!]
    """filter the rows returned"""
    where: tally_session_contest_bool_exp
  ): [tally_session_contest!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tally_session_contest"
  """
  sequent_backend_tally_session_contest_aggregate(
    """distinct select on columns"""
    distinct_on: [tally_session_contest_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_contest_order_by!]
    """filter the rows returned"""
    where: tally_session_contest_bool_exp
  ): tally_session_contest_aggregate!
  """
  fetch data from the table: "sequent_backend.tally_session_contest" using primary key columns
  """
  sequent_backend_tally_session_contest_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session_contest
  """
  fetch data from the table in a streaming manner: "sequent_backend.tally_session_contest"
  """
  sequent_backend_tally_session_contest_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [tally_session_contest_stream_cursor_input]!
    """filter the rows returned"""
    where: tally_session_contest_bool_exp
  ): [tally_session_contest!]!
  """
  fetch data from the table: "sequent_backend.tally_session_execution"
  """
  sequent_backend_tally_session_execution(
    """distinct select on columns"""
    distinct_on: [tally_session_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_execution_order_by!]
    """filter the rows returned"""
    where: tally_session_execution_bool_exp
  ): [tally_session_execution!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tally_session_execution"
  """
  sequent_backend_tally_session_execution_aggregate(
    """distinct select on columns"""
    distinct_on: [tally_session_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_session_execution_order_by!]
    """filter the rows returned"""
    where: tally_session_execution_bool_exp
  ): tally_session_execution_aggregate!
  """
  fetch data from the table: "sequent_backend.tally_session_execution" using primary key columns
  """
  sequent_backend_tally_session_execution_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_session_execution
  """
  fetch data from the table in a streaming manner: "sequent_backend.tally_session_execution"
  """
  sequent_backend_tally_session_execution_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [tally_session_execution_stream_cursor_input]!
    """filter the rows returned"""
    where: tally_session_execution_bool_exp
  ): [tally_session_execution!]!
  """
  fetch data from the table in a streaming manner: "sequent_backend.tally_session"
  """
  sequent_backend_tally_session_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [tally_session_stream_cursor_input]!
    """filter the rows returned"""
    where: tally_session_bool_exp
  ): [tally_session!]!
  """
  fetch data from the table: "sequent_backend.tally_sheet"
  """
  sequent_backend_tally_sheet(
    """distinct select on columns"""
    distinct_on: [tally_sheet_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_sheet_order_by!]
    """filter the rows returned"""
    where: tally_sheet_bool_exp
  ): [tally_sheet!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tally_sheet"
  """
  sequent_backend_tally_sheet_aggregate(
    """distinct select on columns"""
    distinct_on: [tally_sheet_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tally_sheet_order_by!]
    """filter the rows returned"""
    where: tally_sheet_bool_exp
  ): tally_sheet_aggregate!
  """
  fetch data from the table: "sequent_backend.tally_sheet" using primary key columns
  """
  sequent_backend_tally_sheet_by_pk(election_event_id: uuid!, id: uuid!, tenant_id: uuid!): tally_sheet
  """
  fetch data from the table in a streaming manner: "sequent_backend.tally_sheet"
  """
  sequent_backend_tally_sheet_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [tally_sheet_stream_cursor_input]!
    """filter the rows returned"""
    where: tally_sheet_bool_exp
  ): [tally_sheet!]!
  """
  fetch data from the table: "sequent_backend.tasks_execution"
  """
  sequent_backend_tasks_execution(
    """distinct select on columns"""
    distinct_on: [tasks_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tasks_execution_order_by!]
    """filter the rows returned"""
    where: tasks_execution_bool_exp
  ): [tasks_execution!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tasks_execution"
  """
  sequent_backend_tasks_execution_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_execution_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tasks_execution_order_by!]
    """filter the rows returned"""
    where: tasks_execution_bool_exp
  ): tasks_execution_aggregate!
  """
  fetch data from the table: "sequent_backend.tasks_execution" using primary key columns
  """
  sequent_backend_tasks_execution_by_pk(id: uuid!, tenant_id: uuid!): tasks_execution
  """
  fetch data from the table in a streaming manner: "sequent_backend.tasks_execution"
  """
  sequent_backend_tasks_execution_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [tasks_execution_stream_cursor_input]!
    """filter the rows returned"""
    where: tasks_execution_bool_exp
  ): [tasks_execution!]!
  """
  fetch data from the table: "sequent_backend.template"
  """
  sequent_backend_template(
    """distinct select on columns"""
    distinct_on: [template_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [template_order_by!]
    """filter the rows returned"""
    where: template_bool_exp
  ): [template!]!
  """
  fetch aggregated fields from the table: "sequent_backend.template"
  """
  sequent_backend_template_aggregate(
    """distinct select on columns"""
    distinct_on: [template_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [template_order_by!]
    """filter the rows returned"""
    where: template_bool_exp
  ): template_aggregate!
  """
  fetch data from the table: "sequent_backend.template" using primary key columns
  """
  sequent_backend_template_by_pk(id: uuid!, tenant_id: uuid!): template
  """
  fetch data from the table in a streaming manner: "sequent_backend.template"
  """
  sequent_backend_template_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [template_stream_cursor_input]!
    """filter the rows returned"""
    where: template_bool_exp
  ): [template!]!
  """
  fetch data from the table: "sequent_backend.tenant"
  """
  sequent_backend_tenant(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]
    """filter the rows returned"""
    where: tenant_bool_exp
  ): [tenant!]!
  """
  fetch aggregated fields from the table: "sequent_backend.tenant"
  """
  sequent_backend_tenant_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]
    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenant_aggregate!
  """
  fetch data from the table: "sequent_backend.tenant" using primary key columns
  """
  sequent_backend_tenant_by_pk(id: uuid!): tenant
  """
  fetch data from the table in a streaming manner: "sequent_backend.tenant"
  """
  sequent_backend_tenant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [tenant_stream_cursor_input]!
    """filter the rows returned"""
    where: tenant_bool_exp
  ): [tenant!]!
  """
  fetch data from the table: "sequent_backend.trustee"
  """
  sequent_backend_trustee(
    """distinct select on columns"""
    distinct_on: [trustee_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [trustee_order_by!]
    """filter the rows returned"""
    where: trustee_bool_exp
  ): [trustee!]!
  """
  fetch aggregated fields from the table: "sequent_backend.trustee"
  """
  sequent_backend_trustee_aggregate(
    """distinct select on columns"""
    distinct_on: [trustee_select_column!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [trustee_order_by!]
    """filter the rows returned"""
    where: trustee_bool_exp
  ): trustee_aggregate!
  """
  fetch data from the table: "sequent_backend.trustee" using primary key columns
  """
  sequent_backend_trustee_by_pk(id: uuid!): trustee
  """
  fetch data from the table in a streaming manner: "sequent_backend.trustee"
  """
  sequent_backend_trustee_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!
    """cursor to stream the results returned by the query"""
    cursor: [trustee_stream_cursor_input]!
    """filter the rows returned"""
    where: trustee_bool_exp
  ): [trustee!]!
}

type taskOutput {
  task_execution: tasks_execution_type!
}

type tasks_execution_type {
  annotations: jsonb
  created_at: timestamptz!
  election_event_id: uuid!
  end_at: timestamptz
  executed_by_user: String!
  execution_status: String!
  id: uuid!
  labels: jsonb
  logs: json
  name: String!
  start_at: timestamptz!
  tenant_id: uuid!
  type: String!
}

type templateOutput {
  document_id: String!
  error_msg: String
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [uuid!]
  """does the array contain the given value"""
  _contains: [uuid!]
  _eq: [uuid!]
  _gt: [uuid!]
  _gte: [uuid!]
  _in: [[uuid!]!]
  _is_null: Boolean
  _lt: [uuid!]
  _lte: [uuid!]
  _neq: [uuid!]
  _nin: [[uuid!]!]
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}